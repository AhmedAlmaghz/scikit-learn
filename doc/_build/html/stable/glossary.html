
<!DOCTYPE html>


<html lang="ar" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="مسرد المصطلحات الشائعة وعناصر واجهة برمجة التطبيقات" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://scikit-learn/stable/glossary.html" />
<meta property="og:site_name" content="scikit-learn" />
<meta property="og:description" content="يأمل هذا المسرد في تمثيل الاصطلاحات الضمنية والصريحة المطبقة في Scikit-learn وواجهة برمجة التطبيقات الخاصة به بشكل نهائي، مع توفير مرجع للمستخدمين والمساهمين. يهدف إلى وصف المفاهيم وإما تفصيل واجهة..." />
<meta property="og:image" content="https://scikit-learn.org/stable/_static/scikit-learn-logo-small.png" />
<meta property="og:image:alt" content="scikit-learn" />
<meta name="description" content="يأمل هذا المسرد في تمثيل الاصطلاحات الضمنية والصريحة المطبقة في Scikit-learn وواجهة برمجة التطبيقات الخاصة به بشكل نهائي، مع توفير مرجع للمستخدمين والمساهمين. يهدف إلى وصف المفاهيم وإما تفصيل واجهة..." />

    <title>مسرد المصطلحات الشائعة وعناصر واجهة برمجة التطبيقات &#8212; scikit-learn 1.6.dev0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/plot_directive.css?v=7f9a90b1" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Vibur" />
    <link rel="stylesheet" type="text/css" href="_static/jupyterlite_sphinx.css?v=ca70e7f1" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/styles/colors.css?v=cc94ab7d" />
    <link rel="stylesheet" type="text/css" href="_static/styles/custom.css?v=85b0813d" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="_static/documentation_options.js?v=3cd28d06"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=97f0b27d"></script>
    <script src="_static/jupyterlite_sphinx.js?v=d6bdf5f8"></script>
    <script src="_static/translations.js?v=87cb2081"></script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script data-domain="scikit-learn.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'glossary';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.16.0';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://scikit-learn.org/dev/_static/versions.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '1.6.dev0';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <script src="_static/scripts/dropdown.js?v=e2048168"></script>
    <script src="_static/scripts/version-switcher.js?v=a6dd8357"></script>
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="search" title="بحث" href="search.html" />
    <link rel="next" title="دليل المطورين" href="developers/index.html" />
    <link rel="prev" title="الإصدرات القديمة" href="whats_new/older_versions.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="ar"/>
  <meta name="docsearch:version" content="1.6" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/scikit-learn-logo-small.png" class="logo__image only-light" alt="scikit-learn homepage"/>
    <img src="_static/scikit-learn-logo-small.png" class="logo__image only-dark pst-js-only" alt="scikit-learn homepage"/>
  
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="user_guide.html">
    دليل المستخدم
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://blog.scikit-learn.org/">
    Community
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="getting_started.html">
    البدء
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="whats_new.html">
    Release History
  </a>
</li>


<li class=" current active">
  <a class="nav-link dropdown-item nav-internal" href="#">
    Glossary
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="developers/index.html">
    Development
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="faq.html">
    FAQ
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="support.html">
    الدعم الفني
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="related_projects.html">
    مشاريع ذات علاقة
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="roadmap.html">
    Roadmap
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="governance.html">
    Governance
  </a>
</li>


<li class=" ">
  <a class="nav-link dropdown-item nav-internal" href="about.html">
    من نحن
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="بحث" aria-label="بحث" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-learn/scikit-learn" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="بحث" aria-label="بحث" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="user_guide.html">
    دليل المستخدم
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="auto_examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://blog.scikit-learn.org/">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="getting_started.html">
    البدء
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="whats_new.html">
    Release History
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="#">
    Glossary
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="developers/index.html">
    Development
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="faq.html">
    FAQ
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="support.html">
    الدعم الفني
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="related_projects.html">
    مشاريع ذات علاقة
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="roadmap.html">
    Roadmap
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="governance.html">
    Governance
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="about.html">
    من نحن
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/scikit-learn/scikit-learn" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">مسرد المصطلحات الشائعة وعناصر واجهة برمجة التطبيقات</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="glossary">
<span id="id1"></span><h1>مسرد المصطلحات الشائعة وعناصر واجهة برمجة التطبيقات<a class="headerlink" href="#glossary" title="Link to this heading">#</a></h1>
<p>يأمل هذا المسرد في تمثيل الاصطلاحات الضمنية والصريحة
المطبقة في Scikit-learn وواجهة برمجة التطبيقات الخاصة به بشكل نهائي، مع توفير مرجع
للمستخدمين والمساهمين. يهدف إلى وصف المفاهيم وإما تفصيل
واجهة برمجة التطبيقات المقابلة لها أو ربطها بأجزاء أخرى ذات صلة من الوثائق
التي تقوم بذلك. من خلال ربط إدخالات المسرد من مرجع واجهة برمجة التطبيقات ودليل
المستخدم، قد نقلل من التكرار وعدم التناسق.</p>
<p>نبدأ بإدراج المفاهيم العامة (وأي مفاهيم لم تكن مناسبة في أي مكان آخر)، ولكن
يتم سرد مجموعات أكثر تحديدًا من المصطلحات ذات الصلة أدناه:
<a class="reference internal" href="#glossary-estimator-types"><span class="std std-ref">واجهات برمجة تطبيقات الفئات وأنواع المقدرات</span></a>، <a class="reference internal" href="#glossary-target-types"><span class="std std-ref">أنواع الأهداف</span></a>،
<a class="reference internal" href="#glossary-methods"><span class="std std-ref">الأساليب</span></a>، <a class="reference internal" href="#glossary-parameters"><span class="std std-ref">المعلمات</span></a>،
<a class="reference internal" href="#glossary-attributes"><span class="std std-ref">السمات</span></a>، <a class="reference internal" href="#glossary-sample-props"><span class="std std-ref">خصائص البيانات والعينة</span></a>.</p>
<section id="id2">
<h2>مفاهيم عامة<a class="headerlink" href="#id2" title="Link to this heading">#</a></h2>
<dl class="glossary">
<dt id="term-1d">1d<a class="headerlink" href="#term-1d" title="Link to this term">#</a></dt><dt id="term-0">مصفوفة أحادية البعد<a class="headerlink" href="#term-0" title="Link to this term">#</a></dt><dd><p>مصفوفة أحادية البعد. مصفوفة NumPy التي يبلغ طول <code class="docutils literal notranslate"><span class="pre">.shape</span></code> الخاص بها 1.
متجه.</p>
</dd>
<dt id="term-2d">2d<a class="headerlink" href="#term-2d" title="Link to this term">#</a></dt><dt id="term-1">مصفوفة ثنائية الأبعاد<a class="headerlink" href="#term-1" title="Link to this term">#</a></dt><dd><p>مصفوفة ثنائية الأبعاد. مصفوفة NumPy التي يبلغ طول <code class="docutils literal notranslate"><span class="pre">.shape</span></code> الخاص بها 2.
غالبًا ما تُمثل مصفوفة.</p>
</dd>
<dt id="term-2">واجهة برمجة التطبيقات<a class="headerlink" href="#term-2" title="Link to this term">#</a></dt><dd><p>تشير إلى كل من الواجهات <em>المحددة</em> للمقدرات المُنفذة في
Scikit-learn والاصطلاحات <em>المعممة</em> عبر أنواع
المقدرات كما هو موضح في هذا المسرد و <a class="reference internal" href="developers/develop.html#api-overview"><span class="std std-ref">نظرة عامة في وثائق
المساهم</span></a>.</p>
<p>تم توثيق الواجهات المحددة التي تُشكل واجهة برمجة التطبيقات العامة لـ Scikit-learn
إلى حد كبير في <a class="reference internal" href="api/index.html#api-ref"><span class="std std-ref">API Reference</span></a>. ومع ذلك، فإننا نعتبر أي شيء أقل رسمية
كواجهة برمجة تطبيقات عامة إذا لم يبدأ أي من المُعرِّفات المطلوبة للوصول إليه
بـ <code class="docutils literal notranslate"><span class="pre">_</span></code>. نحاول عمومًا الحفاظ على <a class="reference internal" href="#term-6"><span class="xref std std-term">التوافق مع الإصدارات السابقة</span></a> لجميع
الكائنات في واجهة برمجة التطبيقات العامة.</p>
<p>واجهة برمجة التطبيقات الخاصة، بما في ذلك الدوال والوحدات النمطية والأساليب التي تبدأ
بـ <code class="docutils literal notranslate"><span class="pre">_</span></code> غير مضمونة لتكون مستقرة.</p>
</dd>
<dt id="term-3">يشبه المصفوفة<a class="headerlink" href="#term-3" title="Link to this term">#</a></dt><dd><p>تنسيق البيانات الأكثر شيوعًا <em>لإدخال</em> مقدرات ودوال Scikit-learn،
يشبه المصفوفة هو أي كائن من نوع تنتج <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.asarray.html#numpy.asarray" title="(in NumPy v2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.asarray</span></code></a> له
مصفوفة ذات شكل مناسب (عادةً ما تكون أحادية أو ثنائية الأبعاد) من نوع بيانات
مناسب (عادةً ما يكون رقميًا).</p>
<p>يتضمن هذا:</p>
<ul class="simple">
<li><p>مصفوفة numpy</p></li>
<li><p>قائمة من الأرقام</p></li>
<li><p>قائمة من قوائم الأرقام بطول k لطول ثابت k</p></li>
<li><p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v2.2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></a> مع جميع الأعمدة الرقمية</p></li>
<li><p><a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series" title="(in pandas v2.2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series</span></code></a> رقمية</p></li>
</ul>
<p>يستبعد:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#term-64"><span class="xref std std-term">مصفوفة متفرقة</span></a></p></li>
<li><p>مصفوفة متفرقة</p></li>
<li><p>مُكرِّر</p></li>
<li><p>مُولِّد</p></li>
</ul>
<p>لاحظ أن <em>ناتج</em> مقدرات ودوال scikit-learn (على سبيل المثال،
التنبؤات) يجب أن يكون عمومًا مصفوفات أو مصفوفات متفرقة، أو قوائم
منها (كما هو الحال في <a class="reference internal" href="#term-111"><span class="xref std std-term">متعدد المخرجات</span></a> <a class="reference internal" href="modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier" title="sklearn.tree.DecisionTreeClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">tree.DecisionTreeClassifier</span></code></a>
<code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>). المقدر الذي يُعيد <code class="docutils literal notranslate"><span class="pre">predict()</span></code> الخاص به قائمة أو
<code class="docutils literal notranslate"><span class="pre">pandas.Series</span></code> غير صالح.</p>
</dd>
<dt id="term-4">سمة<a class="headerlink" href="#term-4" title="Link to this term">#</a></dt><dt id="term-5">السمات<a class="headerlink" href="#term-5" title="Link to this term">#</a></dt><dd><p>نستخدم السمة في الغالب للإشارة إلى كيفية تخزين معلومات النموذج في
مقدر أثناء التوفيق. أي سمة عامة مخزنة في نموذج
مقدر مطلوب أن تبدأ بحرف أبجدي وتنتهي بشرطة سفلية واحدة إذا تم تعيينها في
<a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> أو <a class="reference internal" href="#term-partial_fit"><span class="xref std std-term">partial_fit</span></a>. هذه هي ما يتم توثيقه ضمن
وثائق <em>السمات</em> الخاصة بالمقدر. المعلومات المخزنة في السمات
عادةً ما تكون إما: إحصائيات كافية تُستخدم للتنبؤ أو
التحويل؛ نواتج <span class="xref std std-term">استنتاجية</span> مثل <a class="reference internal" href="#term-labels_"><span class="xref std std-term">labels_</span></a> أو
<a class="reference internal" href="#term-embedding_"><span class="xref std std-term">embedding_</span></a>؛ أو بيانات تشخيصية، مثل
<a class="reference internal" href="#term-feature_importances_"><span class="xref std std-term">feature_importances_</span></a>.
السمات الشائعة مُدرجة <a class="reference internal" href="#glossary-attributes"><span class="std std-ref">أدناه</span></a>.</p>
<p>قد يكون للسمة العامة نفس اسم مُنشئ
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-parameter" title="(in Python v3.13)"><span class="xref std std-term">parameter</span></a>، مع إلحاق <code class="docutils literal notranslate"><span class="pre">_</span></code>. يُستخدم هذا لتخزين
إصدار تم التحقق من صحته أو تقديره من إدخال المستخدم. على سبيل المثال،
يتم إنشاء <a class="reference internal" href="modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">decomposition.PCA</span></code></a> باستخدام معلمة <code class="docutils literal notranslate"><span class="pre">n_components</span></code>.
من هذا، جنبًا إلى جنب مع المعلمات الأخرى والبيانات،
يُقدِّر PCA السمة <code class="docutils literal notranslate"><span class="pre">n_components_</span></code>.</p>
<p>قد يتم أيضًا تعيين سمات خاصة أخرى تُستخدم في التنبؤ/التحويل/إلخ.
عند التوفيق. تبدأ هذه بشرطة سفلية واحدة ولا يُضمن
أن تكون مستقرة للوصول العام.</p>
<p>يجب أن تكون السمة العامة في نموذج مقدر لا ينتهي بشرطة سفلية
هي القيمة المخزنة وغير المعدلة لـ <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
<a class="reference external" href="https://docs.python.org/3/glossary.html#term-parameter" title="(in Python v3.13)"><span class="xref std std-term">parameter</span></a> التي تحمل نفس الاسم. نظرًا لهذا التكافؤ، يتم
توثيق هذه ضمن وثائق <em>المعلمات</em> الخاصة بالمقدر.</p>
</dd>
<dt id="term-6">التوافق مع الإصدارات السابقة<a class="headerlink" href="#term-6" title="Link to this term">#</a></dt><dd><p>نحاول عمومًا الحفاظ على التوافق مع الإصدارات السابقة (أي يمكن تمديد
الواجهات والسلوكيات ولكن لا يمكن تغييرها أو إزالتها) من إصدار
إلى إصدار، لكن هذا يأتي مع بعض الاستثناءات:</p>
<dl class="simple">
<dt>واجهة برمجة التطبيقات العامة فقط</dt><dd><p>قد يتغير سلوك الكائنات التي يتم الوصول إليها من خلال المُعرِّفات الخاصة
(تلك التي تبدأ بـ <code class="docutils literal notranslate"><span class="pre">_</span></code>) بشكل تعسفي بين
الإصدارات.</p>
</dd>
<dt>كما هو موثق</dt><dd><p>سنفترض عمومًا أن المستخدمين قد التزموا بأنواع
المعلمات الموثقة ونطاقاتها. إذا طلبت الوثائق
قائمة وأعطى المستخدم tuple، فإننا لا نضمن سلوكًا
متسقًا من إصدار إلى إصدار.</p>
</dd>
<dt>الإهمال</dt><dd><p>قد تتغير السلوكيات بعد فترة <span class="xref std std-term">إهمال</span>
(عادة ما تكون إصدارين). يتم إصدار التحذيرات باستخدام وحدة
<a class="reference external" href="https://docs.python.org/3/library/warnings.html#module-warnings" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> الخاصة بـ Python.</p>
</dd>
<dt>وسيطات الكلمات الرئيسية</dt><dd><p>قد نفترض أحيانًا أنه يتم تمرير جميع المعلمات الاختيارية (بخلاف X
و y إلى <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> والأساليب المماثلة) كوسيطات ذات
كلمات رئيسية فقط وقد يتم إعادة ترتيبها موضعيًا.</p>
</dd>
<dt>إصلاحات الأخطاء والتحسينات</dt><dd><p>قد تُغيِّر إصلاحات الأخطاء - وفي كثير من الأحيان - التحسينات سلوك
المقدرات، بما في ذلك تنبؤات المقدر المُدرَّب على
نفس البيانات و <a class="reference internal" href="#term-random_state"><span class="xref std std-term">random_state</span></a>. عندما يحدث هذا،
نحاول ملاحظته بوضوح في سجل التغيير.</p>
</dd>
<dt>التسلسل</dt><dd><p>لا نقدم أي ضمانات بأن تخليل المقدر في إصدار واحد
سيسمح بإلغاء تخليله إلى نموذج مكافئ في
الإصدار اللاحق. (بالنسبة للمقدرات في حزمة sklearn،
نُصدر تحذيرًا عند محاولة إلغاء التخليل هذا، حتى لو
حدث أنه يعمل.) انظر <a class="reference internal" href="model_persistence.html#persistence-limitations"><span class="std std-ref">قيود الأمان والصيانة</span></a>.</p>
</dd>
<dt><a class="reference internal" href="modules/generated/sklearn.utils.estimator_checks.check_estimator.html#sklearn.utils.estimator_checks.check_estimator" title="sklearn.utils.estimator_checks.check_estimator"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.estimator_checks.check_estimator</span></code></a></dt><dd><p>نحن نقدم ضمانات توافق محدودة مع الإصدارات السابقة لفحوصات
المقدر: قد نضيف متطلبات إضافية على المقدرات
التي تم اختبارها باستخدام هذه الدالة، عادةً عندما كان يتم افتراضها بشكل غير رسمي
ولكن لم يتم اختبارها رسميًا.</p>
</dd>
</dl>
<p>على الرغم من هذا العقد غير الرسمي مع مستخدمينا، يتم توفير البرنامج
كما هو، كما هو مذكور في الترخيص. عندما يُسبب إصدار عن غير قصد
تغييرات غير متوافقة مع الإصدارات السابقة، تُعرف هذه
باسم انحدارات البرامج.</p>
</dd>
<dt id="term-7">قابل للاستدعاء<a class="headerlink" href="#term-7" title="Link to this term">#</a></dt><dd><p>دالة أو فئة أو كائن ينفذ أسلوب <code class="docutils literal notranslate"><span class="pre">__call__</span></code>؛ أي شيء يُعيد True عندما تكون وسيطة <a class="reference external" href="https://docs.python.org/3/library/functions.html#callable">callable()</a>.</p>
</dd>
<dt id="term-8">ميزة فئوية<a class="headerlink" href="#term-8" title="Link to this term">#</a></dt><dd><p>الميزة الفئوية أو الاسمية هي الميزة التي تحتوي على
مجموعة محدودة من القيم المنفصلة عبر مجموعة البيانات.
يتم تمثيلها عادةً كأعمدة من الأعداد الصحيحة أو
السلاسل. سيتم رفض السلاسل من قبل معظم مقدرات scikit-learn،
وسيتم التعامل مع الأعداد الصحيحة على أنها ترتيبية أو
قائمة على العد. للاستخدام مع معظم المقدرات،
يجب تشفير المتغيرات الفئوية بشكل أحادي الاتجاه. تشمل الاستثناءات البارزة
النماذج المستندة إلى الشجرة مثل الغابات العشوائية ونماذج التعزيز المتدرج
التي غالبًا ما تعمل بشكل أفضل وأسرع مع المتغيرات الفئوية المُرمَّزة بالأعداد الصحيحة.
<a class="reference internal" href="modules/generated/sklearn.preprocessing.OrdinalEncoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrdinalEncoder</span></code></a> يساعد في تشفير
الميزات الفئوية ذات القيمة السلسلة كأعداد صحيحة ترتيبية، و
<a class="reference internal" href="modules/generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneHotEncoder</span></code></a> يمكن استخدامه لـ
تشفير الميزات الفئوية بشكل أحادي الاتجاه.
انظر أيضًا <a class="reference internal" href="modules/preprocessing.html#preprocessing-categorical-features"><span class="std std-ref">تشفير الميزات الفئوية</span></a> وحزمة
<a class="reference external" href="https://github.com/scikit-learn-contrib/category_encoders">categorical-encoding</a>
للحصول على أدوات تتعلق بتشفير الميزات الفئوية.</p>
</dd>
<dt id="term-9">استنساخ<a class="headerlink" href="#term-9" title="Link to this term">#</a></dt><dt id="term-10">مستنسخ<a class="headerlink" href="#term-10" title="Link to this term">#</a></dt><dd><p>لنسخ <a class="reference internal" href="#term-23"><span class="xref std std-term">نموذج مقدر</span></a> وإنشاء نموذج جديد باستخدام
<span class="xref std std-term">معلمات</span> متطابقة، ولكن بدون أي <span class="xref std std-term">سمات</span> مناسبة،
باستخدام <a class="reference internal" href="modules/generated/sklearn.base.clone.html#sklearn.base.clone" title="sklearn.base.clone"><code class="xref py py-func docutils literal notranslate"><span class="pre">clone</span></code></a>.</p>
<p>عندما يتم استدعاء <code class="docutils literal notranslate"><span class="pre">fit</span></code>، عادةً ما يقوم <a class="reference internal" href="#term-86"><span class="xref std std-term">مقدر التعريف التلوي</span></a> باستنساخ
نموذج مقدر مُغلَّف قبل ملاءمة النموذج المستنسخ.
(تشمل الاستثناءات، لأسباب تتعلق بالإصدارات القديمة،
<a class="reference internal" href="modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> و
<a class="reference internal" href="modules/generated/sklearn.pipeline.FeatureUnion.html#sklearn.pipeline.FeatureUnion" title="sklearn.pipeline.FeatureUnion"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeatureUnion</span></code></a>.)</p>
<p>إذا كانت معلمة <code class="docutils literal notranslate"><span class="pre">random_state</span></code> الخاصة بالمقدر عددًا صحيحًا (أو إذا
لم يكن لدى المقدر معلمة <code class="docutils literal notranslate"><span class="pre">random_state</span></code>)، فسيتم إرجاع
<em>استنساخ دقيق</em>: سيعطي الاستنساخ والمقدر الأصلي نفس
النتائج تمامًا. خلاف ذلك، يتم إرجاع <em>استنساخ إحصائي</em>: قد ينتج الاستنساخ
نتائج مختلفة عن المقدر الأصلي. يمكن العثور على مزيد من
التفاصيل في <a class="reference internal" href="common_pitfalls.html#randomness"><span class="std std-ref">التحكم في العشوائية</span></a>.</p>
</dd>
<dt id="term-11">اختبارات شائعة<a class="headerlink" href="#term-11" title="Link to this term">#</a></dt><dd><p>يشير هذا إلى الاختبارات التي يتم إجراؤها على كل فئة مقدر تقريبًا في
Scikit-learn للتحقق من امتثالها لاتفاقيات واجهة برمجة التطبيقات الأساسية. إنها
متاحة للاستخدام الخارجي من خلال
<a class="reference internal" href="modules/generated/sklearn.utils.estimator_checks.check_estimator.html#sklearn.utils.estimator_checks.check_estimator" title="sklearn.utils.estimator_checks.check_estimator"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.estimator_checks.check_estimator</span></code></a>، مع وجود معظم
التنفيذ في <code class="docutils literal notranslate"><span class="pre">sklearn/utils/estimator_checks.py</span></code>.</p>
<p>ملاحظة: بعض الاستثناءات لنظام الاختبار الشائع مُرمَّزة حاليًا
في المكتبة، لكننا نأمل في استبدال هذا عن طريق وضع علامة على
السلوكيات الاستثنائية على المقدر باستخدام <a class="reference internal" href="#term-28"><span class="xref std std-term">علامات المقدر</span></a> الدلالية.</p>
</dd>
<dt id="term-12">التوفيق المتبادل<a class="headerlink" href="#term-12" title="Link to this term">#</a></dt><dd><p>طريقة إعادة أخذ عينات تقسم البيانات بشكل متكرر إلى مجموعات فرعية متنافية بشكل متبادل
لملاءمة مرحلتين. خلال المرحلة الأولى، تُمكِّن المجموعات الفرعية
المتنافية بشكل متبادل من حساب التنبؤات أو التحويلات على البيانات التي لم
يتم رؤيتها أثناء التدريب. ثم يتم استخدام البيانات المحسوبة
في المرحلة الثانية. الهدف هو تجنب وجود أي
تكيف زائد في المرحلة الأولى يُسبب تحيزًا في توزيع بيانات الإدخال
للمرحلة الثانية.
للحصول على أمثلة على استخدامه، انظر: <a class="reference internal" href="modules/generated/sklearn.preprocessing.TargetEncoder.html#sklearn.preprocessing.TargetEncoder" title="sklearn.preprocessing.TargetEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">TargetEncoder</span></code></a>،
<a class="reference internal" href="modules/generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a>،
<a class="reference internal" href="modules/generated/sklearn.ensemble.StackingRegressor.html#sklearn.ensemble.StackingRegressor" title="sklearn.ensemble.StackingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingRegressor</span></code></a> و
<a class="reference internal" href="modules/generated/sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">CalibratedClassifierCV</span></code></a>.</p>
</dd>
<dt id="term-13">التحقق المتبادل<a class="headerlink" href="#term-13" title="Link to this term">#</a></dt><dd><p>طريقة إعادة أخذ عينات تقسم البيانات بشكل متكرر إلى مجموعات فرعية &quot;تدريب&quot; و &quot;اختبار&quot;
متنافية بشكل متبادل بحيث يمكن تقييم أداء النموذج على البيانات غير المرئية. يحافظ هذا على البيانات
ويتجنب الحاجة إلى استبعاد مجموعة بيانات &quot;التحقق من الصحة&quot; ويُراعي التباين حيث يتم
إجراء جولات متعددة من التحقق المتبادل بشكل عام.
انظر <a class="reference internal" href="modules/cross_validation.html#cross-validation"><span class="std std-ref">دليل المستخدم</span></a> لمزيد من التفاصيل.</p>
</dd>
<dt id="term-14">الإهمال<a class="headerlink" href="#term-14" title="Link to this term">#</a></dt><dd><p>نستخدم الإهمال لانتهاك ضمانات <a class="reference internal" href="#term-6"><span class="xref std std-term">التوافق مع الإصدارات السابقة</span></a> الخاصة بنا ببطء،
عادةً لـ:</p>
<ul class="simple">
<li><p>تغيير القيمة الافتراضية لمعلمة؛ أو</p></li>
<li><p>إزالة معلمة أو سمة أو أسلوب أو فئة، إلخ.</p></li>
</ul>
<p>سنُصدر عادةً تحذيرًا عند استخدام عنصر مُهمَل،
على الرغم من أنه قد تكون هناك قيود على هذا. على سبيل المثال، سنطرح
تحذيرًا عندما يُعيِّن شخص ما معلمة تم إهمالها، ولكن
قد لا نفعل ذلك عند الوصول إلى سمة هذه المعلمة في نموذج
المقدر.</p>
<p>انظر <span class="xref std std-ref">دليل المساهمين</span>.</p>
</dd>
<dt id="term-15">الأبعاد<a class="headerlink" href="#term-15" title="Link to this term">#</a></dt><dd><p>قد يُستخدم للإشارة إلى عدد <a class="reference internal" href="#term-30"><span class="xref std std-term">الميزات</span></a> (أي
<a class="reference internal" href="#term-n_features"><span class="xref std std-term">n_features</span></a>)، أو الأعمدة في مصفوفة ميزات ثنائية الأبعاد.
ومع ذلك، تُستخدم الأبعاد أيضًا للإشارة إلى طول شكل مصفوفة NumPy،
مما يميز المصفوفة أحادية الأبعاد عن المصفوفة ثنائية الأبعاد.</p>
</dd>
<dt id="term-16">سلسلة وثائق<a class="headerlink" href="#term-16" title="Link to this term">#</a></dt><dd><p>الوثائق المُضمنة لوحدة نمطية أو فئة أو دالة، إلخ، عادةً
في التعليمات البرمجية كسلسلة في بداية تعريف الكائن، و
يمكن الوصول إليها كسمة <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> للكائن.</p>
<p>نحاول الالتزام بـ <a class="reference external" href="https://www.python.org/dev/peps/pep-0257/">PEP257</a>، ونتبع اتفاقيات <a class="reference external" href="https://numpydoc.readthedocs.io/en/latest/format.html">NumpyDoc</a>.</p>
</dd>
<dt id="term-17">شرطة سفلية مزدوجة<a class="headerlink" href="#term-17" title="Link to this term">#</a></dt><dt id="term-18">ترميز الشرطة السفلية المزدوجة<a class="headerlink" href="#term-18" title="Link to this term">#</a></dt><dd><p>عند تحديد أسماء المعلمات للمقدرات المتداخلة، قد يتم
استخدام <code class="docutils literal notranslate"><span class="pre">__</span></code> للفصل بين الأصل والفرع في بعض السياقات. الاستخدام الأكثر
شيوعًا هو عند تعيين المعلمات من خلال مقدر تعريف تلوي باستخدام
<a class="reference internal" href="#term-set_params"><span class="xref std std-term">set_params</span></a> وبالتالي في تحديد شبكة بحث في
<a class="reference internal" href="modules/grid_search.html#grid-search"><span class="std std-ref">بحث المعلمة</span></a>. انظر <a class="reference external" href="https://docs.python.org/3/glossary.html#term-parameter" title="(in Python v3.13)"><span class="xref std std-term">parameter</span></a>.
يُستخدم أيضًا في <a class="reference internal" href="modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline.fit" title="sklearn.pipeline.Pipeline.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pipeline.Pipeline.fit</span></code></a> لتمرير
<a class="reference internal" href="#term-61"><span class="xref std std-term">خصائص العينة</span></a> إلى أساليب <code class="docutils literal notranslate"><span class="pre">fit</span></code> الخاصة بالمقدرات في
خط الأنابيب.</p>
</dd>
<dt id="term-19">نوع البيانات<a class="headerlink" href="#term-19" title="Link to this term">#</a></dt><dt id="term-20">نوع البيانات<a class="headerlink" href="#term-20" title="Link to this term">#</a></dt><dd><p>تفترض مصفوفات NumPy نوع بيانات متجانس في كل مكان، متاح في
سمة <code class="docutils literal notranslate"><span class="pre">.dtype</span></code> لمصفوفة (أو مصفوفة متفرقة). نفترض عمومًا أنواع بيانات
بسيطة لبيانات scikit-learn: عدد عشري أو عدد صحيح.
قد ندعم أنواع بيانات الكائن أو السلسلة للمصفوفات قبل التشفير
أو التحويل إلى متجه. لا تعمل المقدرات الخاصة بنا مع مصفوفات الهياكل، على
سبيل المثال.</p>
<p>يمكن أن تقدم وثائقنا أحيانًا معلومات حول دقة نوع البيانات،
على سبيل المثال <code class="docutils literal notranslate"><span class="pre">np.int32</span></code>، <code class="docutils literal notranslate"><span class="pre">np.int64</span></code>، إلخ. عندما يتم توفير الدقة،
فإنها تشير إلى نوع بيانات NumPy. إذا تم استخدام دقة عشوائية،
فستشير الوثائق إلى نوع البيانات <code class="docutils literal notranslate"><span class="pre">integer</span></code> أو <code class="docutils literal notranslate"><span class="pre">floating</span></code>.
لاحظ أنه في هذه الحالة، يمكن أن تكون الدقة معتمدة على النظام الأساسي.
يشير نوع البيانات <code class="docutils literal notranslate"><span class="pre">numeric</span></code> إلى قبول كل من <code class="docutils literal notranslate"><span class="pre">integer</span></code> و <code class="docutils literal notranslate"><span class="pre">floating</span></code>.</p>
<p>عندما يتعلق الأمر بالاختيار بين نوع البيانات 64 بت (أي <code class="docutils literal notranslate"><span class="pre">np.float64</span></code> و
<code class="docutils literal notranslate"><span class="pre">np.int64</span></code>) ونوع البيانات 32 بت (أي <code class="docutils literal notranslate"><span class="pre">np.float32</span></code> و <code class="docutils literal notranslate"><span class="pre">np.int32</span></code>)،
فإن الأمر يتعلق بالمفاضلة بين الكفاءة والدقة. تُقدم أنواع 64 بت
نتائج أكثر دقة نظرًا لخطأ النقطة العائمة الأقل، لكنها تتطلب المزيد من موارد
الحوسبة، مما يؤدي إلى عمليات أبطأ وزيادة استخدام الذاكرة. على النقيض من ذلك،
تعد أنواع 32 بت بتحسين سرعة التشغيل وتقليل استهلاك الذاكرة، ولكن
تُسبب خطأ أكبر في النقطة العائمة. يعتمد تحسين الكفاءة على
تحسين المستوى الأدنى مثل التحويل إلى متجه،
إرسال تعليمات متعددة واحدة (SIMD)، أو تحسين ذاكرة التخزين المؤقت ولكن
بشكل حاسم على توافق الخوارزمية المستخدمة.</p>
<p>على وجه التحديد، يجب أن يُراعي اختيار الدقة ما إذا كانت
الخوارزمية المستخدمة يمكنها الاستفادة بفعالية من <code class="docutils literal notranslate"><span class="pre">np.float32</span></code>. بعض
الخوارزميات، وخاصة أساليب التصغير، مُرمَّزة حصريًا
لـ <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>، مما يعني أنه حتى لو تم تمرير <code class="docutils literal notranslate"><span class="pre">np.float32</span></code>،
فإنها تُشغِّل تحويلًا تلقائيًا مرة أخرى إلى <code class="docutils literal notranslate"><span class="pre">np.float64</span></code>. هذا لا
يلغي فقط وفورات الحساب المقصودة ولكنه يُسبب أيضًا
نفقات عامة إضافية، مما يجعل العمليات مع <code class="docutils literal notranslate"><span class="pre">np.float32</span></code> أبطأ بشكل غير متوقع
وأكثر كثافة في استخدام الذاكرة بسبب خطوة التحويل الإضافية هذه.</p>
</dd>
<dt id="term-21">كتابة البطة<a class="headerlink" href="#term-21" title="Link to this term">#</a></dt><dd><p>نحاول تطبيق <a class="reference external" href="https://en.wikipedia.org/wiki/Duck_typing">كتابة البطة</a> لتحديد كيفية
التعامل مع بعض قيم الإدخال (على سبيل المثال، التحقق مما إذا كان مقدر معين
هو مصنف). أي أننا نتجنب استخدام <code class="docutils literal notranslate"><span class="pre">isinstance</span></code> حيثما أمكن ذلك،
ونعتمد على وجود أو غياب السمات لتحديد سلوك
الكائن. هناك حاجة إلى بعض الفروق الدقيقة عند اتباع هذا
النهج:</p>
<ul>
<li><p>بالنسبة لبعض المقدرات، قد لا تتوفر سمة إلا بمجرد
<span class="xref std std-term">ملاءمتها</span>. على سبيل المثال، لا يمكننا تحديد ما إذا كان
<a class="reference internal" href="#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> متاحًا مسبقًا في بحث شبكي حيث تتضمن الشبكة
التناوب بين متنبئ احتمالي وغير احتمالي في الخطوة الأخيرة من خط
الأنابيب. في ما يلي، لا يمكننا تحديد ما إذا كان <code class="docutils literal notranslate"><span class="pre">clf</span></code> احتماليًا إلا بعد
ملاءمته على بعض البيانات:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">SGDClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">SGDClassifier</span><span class="p">(),</span>
<span class="gp">... </span>                   <span class="n">param_grid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;loss&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;log_loss&#39;</span><span class="p">,</span> <span class="s1">&#39;hinge&#39;</span><span class="p">]})</span>
</pre></div>
</div>
<p>هذا يعني أنه لا يمكننا التحقق من السمات المكتوبة بالبط إلا بعد
الملاءمة، وأنه يجب أن نكون حريصين على جعل <a class="reference internal" href="#term-87"><span class="xref std std-term">مقدرات التعريف التلوي</span></a>
تقدم فقط سمات وفقًا لحالة المقدر الأساسي بعد الملاءمة.</p>
</li>
<li><p>التحقق مما إذا كانت سمة موجودة (باستخدام <code class="docutils literal notranslate"><span class="pre">hasattr</span></code>) بشكل عام
مكلف مثل الحصول على السمة (<code class="docutils literal notranslate"><span class="pre">getattr</span></code> أو ترميز
النقطة). في بعض الحالات، قد يكون الحصول على السمة مكلفًا بالفعل (على سبيل المثال،
بالنسبة لبعض تطبيقات
<a class="reference internal" href="#term-feature_importances_"><span class="xref std std-term">feature_importances_</span></a>، مما قد يشير إلى أن هذا عيب في تصميم واجهة برمجة التطبيقات).
لذا، يجب تجنب الشفرة التي تقوم بـ <code class="docutils literal notranslate"><span class="pre">hasattr</span></code> متبوعًا بـ <code class="docutils literal notranslate"><span class="pre">getattr</span></code>؛ يُفضل
<code class="docutils literal notranslate"><span class="pre">getattr</span></code> داخل كتلة try-except.</p></li>
<li><p>لتحديد بعض جوانب توقعات المقدر أو
دعمه لميزة ما، نستخدم <a class="reference internal" href="#term-28"><span class="xref std std-term">علامات المقدر</span></a> بدلاً من
كتابة البطة.</p></li>
</ul>
</dd>
<dt id="term-22">الإيقاف المبكر<a class="headerlink" href="#term-22" title="Link to this term">#</a></dt><dd><p>يتمثل هذا في إيقاف أسلوب التحسين التكراري قبل
تقارب فقدان التدريب، لتجنب التكيف الزائد. يتم ذلك
عمومًا عن طريق مراقبة درجة التعميم على مجموعة التحقق من الصحة. عند
توفرها، يتم تنشيطها من خلال المعلمة
<code class="docutils literal notranslate"><span class="pre">early_stopping</span></code> أو عن طريق تعيين <a class="reference internal" href="#term-n_iter_no_change"><span class="xref std std-term">n_iter_no_change</span></a> موجب.</p>
</dd>
<dt id="term-23">نموذج مقدر<a class="headerlink" href="#term-23" title="Link to this term">#</a></dt><dd><p>نستخدم هذا المصطلح أحيانًا للتمييز بين فئة <a class="reference internal" href="#term-82"><span class="xref std std-term">مقدر</span></a>
ونموذج تم إنشاؤه. على سبيل المثال، في ما يلي،
<code class="docutils literal notranslate"><span class="pre">cls</span></code> هي فئة مقدر، بينما <code class="docutils literal notranslate"><span class="pre">est1</span></code> و <code class="docutils literal notranslate"><span class="pre">est2</span></code> هما
نماذج:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="bp">cls</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span>
<span class="n">est1</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
<span class="n">est2</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt id="term-24">أمثلة<a class="headerlink" href="#term-24" title="Link to this term">#</a></dt><dd><p>نحاول تقديم أمثلة على الاستخدام الأساسي لمعظم الدوال و
الفئات في واجهة برمجة التطبيقات:</p>
<ul class="simple">
<li><p>كاختبارات وثائق في سلاسل الوثائق الخاصة بها (أي داخل شفرة مكتبة <code class="docutils literal notranslate"><span class="pre">sklearn/</span></code>
نفسها).</p></li>
<li><p>كأمثلة في <a class="reference internal" href="auto_examples/index.html#general-examples"><span class="std std-ref">معرض الأمثلة</span></a>
المعروضة (باستخدام <a class="reference external" href="https://sphinx-gallery.readthedocs.io/">sphinx-gallery</a>) من البرامج النصية في
دليل <code class="docutils literal notranslate"><span class="pre">examples/</span></code>، مع توضيح الميزات أو المعلمات الرئيسية
للمقدر/الدالة. يجب أيضًا الرجوع إلى هذه من
دليل المستخدم.</p></li>
<li><p>أحيانًا في <a class="reference internal" href="user_guide.html#user-guide"><span class="std std-ref">دليل المستخدم</span></a> (مبني من <code class="docutils literal notranslate"><span class="pre">doc/</span></code>)
جنبًا إلى جنب مع وصف فني للمقدر.</p></li>
</ul>
</dd>
<dt id="term-25">تجريبي<a class="headerlink" href="#term-25" title="Link to this term">#</a></dt><dd><p>أداة تجريبية قابلة للاستخدام بالفعل، لكن واجهة برمجة التطبيقات العامة الخاصة بها، مثل
قيم المعلمات الافتراضية أو السمات الملائمة، لا تزال عرضة
للتغيير في الإصدارات المستقبلية بدون سياسة تحذير <a class="reference internal" href="#term-14"><span class="xref std std-term">الإهمال</span></a> المعتادة.</p>
</dd>
<dt id="term-26">مقياس التقييم<a class="headerlink" href="#term-26" title="Link to this term">#</a></dt><dt id="term-27">مقاييس التقييم<a class="headerlink" href="#term-27" title="Link to this term">#</a></dt><dd><p>تقدم مقاييس التقييم مقياسًا لمدى جودة أداء النموذج. قد
نستخدم هذا المصطلح على وجه التحديد للإشارة إلى الدوال في <a class="reference internal" href="api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">metrics</span></code></a>
(مع تجاهل <a class="reference internal" href="api/sklearn.metrics.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pairwise</span></code></a>)، على عكس
أسلوب <a class="reference internal" href="#term-score"><span class="xref std std-term">score</span></a> وواجهة برمجة تطبيقات <a class="reference internal" href="#term-scoring"><span class="xref std std-term">scoring</span></a> المستخدمة في التحقق المتبادل.
انظر <a class="reference internal" href="modules/model_evaluation.html#model-evaluation"><span class="std std-ref">المقاييس والتهديف: تحديد جودة التنبؤات</span></a>.</p>
<p>عادةً ما تقبل هذه الدوال حقيقة أساسية (أو البيانات الأولية
حيث يُقيِّم المقياس التجميع بدون حقيقة أساسية) وتنبؤًا، سواء كان
ناتج <a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a> (<code class="docutils literal notranslate"><span class="pre">y_pred</span></code>)،
أو <a class="reference internal" href="#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> (<code class="docutils literal notranslate"><span class="pre">y_proba</span></code>)، أو دالة تسجيل عشوائية
بما في ذلك <a class="reference internal" href="#term-decision_function"><span class="xref std std-term">decision_function</span></a> (<code class="docutils literal notranslate"><span class="pre">y_score</span></code>).
عادةً ما يتم تسمية الدوال بحيث تنتهي بـ <code class="docutils literal notranslate"><span class="pre">_score</span></code> إذا كانت الدرجة الأكبر
تشير إلى نموذج أفضل، و <code class="docutils literal notranslate"><span class="pre">_loss</span></code> إذا كانت الدرجة الأقل
تشير إلى نموذج أفضل. هذا التنوع في الواجهة يُحفز
واجهة برمجة تطبيقات التسجيل.</p>
<p>لاحظ أن بعض المقدرات يمكنها حساب مقاييس غير مدرجة
في <a class="reference internal" href="api/sklearn.metrics.html#module-sklearn.metrics" title="sklearn.metrics"><code class="xref py py-mod docutils literal notranslate"><span class="pre">metrics</span></code></a> وهي خاصة بالمقدر، ولا سيما احتمالات
النموذج.</p>
</dd>
<dt id="term-28">علامات المقدر<a class="headerlink" href="#term-28" title="Link to this term">#</a></dt><dd><p>ميزة مقترحة (على سبيل المثال <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/issues/8022">#8022</a>) يتم من خلالها وصف إمكانيات المقدر
من خلال مجموعة من العلامات الدلالية. سيُمكِّن هذا بعض السلوكيات في وقت التشغيل
بناءً على فحص المقدر، ولكنه
يسمح أيضًا باختبار كل مقدر من أجل الثوابت المناسبة
مع استثنائه من <span class="xref std std-term">الاختبارات الشائعة</span> الأخرى.</p>
<p>يتم تحديد بعض جوانب علامات المقدر حاليًا من خلال
<a class="reference internal" href="#term-21"><span class="xref std std-term">كتابة البطة</span></a> للأساليب مثل <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> ومن خلال
بعض السمات الخاصة على كائنات المقدر:</p>
<dl class="simple glossary">
<dt id="term-_estimator_type"><code class="docutils literal notranslate"><span class="pre">_estimator_type</span></code><a class="headerlink" href="#term-_estimator_type" title="Link to this term">#</a></dt><dd><p>تُحدد هذه السمة ذات القيمة السلسلة المقدر على أنه
مصنف أو مقدر انحدار، إلخ. يتم تعيينها بواسطة mixins مثل
<a class="reference internal" href="modules/generated/sklearn.base.ClassifierMixin.html#sklearn.base.ClassifierMixin" title="sklearn.base.ClassifierMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.ClassifierMixin</span></code></a>، ولكنها تحتاج إلى اعتماد أكثر وضوحًا
على <a class="reference internal" href="#term-86"><span class="xref std std-term">مقدر التعريف التلوي</span></a>. يجب عادةً فحص قيمتها
عن طريق مساعد مثل <a class="reference internal" href="modules/generated/sklearn.base.is_classifier.html#sklearn.base.is_classifier" title="sklearn.base.is_classifier"><code class="xref py py-func docutils literal notranslate"><span class="pre">base.is_classifier</span></code></a>.</p>
</dd>
</dl>
<p>لمزيد من المعلومات التفصيلية، انظر <a class="reference internal" href="developers/develop.html#estimator-tags"><span class="std std-ref">علامات المقدر</span></a>.</p>
</dd>
<dt id="term-29">ميزة<a class="headerlink" href="#term-29" title="Link to this term">#</a></dt><dt id="term-30">الميزات<a class="headerlink" href="#term-30" title="Link to this term">#</a></dt><dt id="term-31">متجه الميزات<a class="headerlink" href="#term-31" title="Link to this term">#</a></dt><dd><p>بشكل تجريدي، الميزة هي دالة (بمعناها الرياضي)
تربط كائنًا تم أخذ عينة منه بكمية رقمية أو فئوية.
يُستخدم &quot;الميزة&quot; أيضًا بشكل شائع للإشارة إلى هذه الكميات، كونها العناصر
الفردية لمتجه يُمثل عينة. في مصفوفة البيانات، يتم تمثيل الميزات
كأعمدة: يحتوي كل عمود على نتيجة تطبيق دالة الميزة على مجموعة من
العينات.</p>
<p>في أماكن أخرى، تُعرف الميزات باسم السمات أو المتنبئات أو المُتغيرات
المستقلة.</p>
<p>تفترض جميع المقدرات تقريبًا في scikit-learn أن الميزات رقمية و
محدودة وغير مفقودة، حتى عندما يكون لها مجالات وتوزيعات دلالية
متميزة (فئوية، ترتيبية، قائمة على العد،
ذات قيمة حقيقية، فاصل). انظر أيضًا <a class="reference internal" href="#term-8"><span class="xref std std-term">ميزة فئوية</span></a> و
<a class="reference internal" href="#term-46"><span class="xref std std-term">قيم مفقودة</span></a>.</p>
<p>يشير <code class="docutils literal notranslate"><span class="pre">n_features</span></code> إلى عدد الميزات في مجموعة البيانات.</p>
</dd>
<dt id="term-32">الملاءمة<a class="headerlink" href="#term-32" title="Link to this term">#</a></dt><dd><p>استدعاء <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> (أو <a class="reference internal" href="#term-fit_transform"><span class="xref std std-term">fit_transform</span></a>، <a class="reference internal" href="#term-fit_predict"><span class="xref std std-term">fit_predict</span></a>،
إلخ) على مقدر.</p>
</dd>
<dt id="term-33">ملائم<a class="headerlink" href="#term-33" title="Link to this term">#</a></dt><dd><p>حالة المقدر بعد <a class="reference internal" href="#term-32"><span class="xref std std-term">الملاءمة</span></a>.</p>
<p>لا يوجد إجراء تقليدي للتحقق مما إذا كان المقدر
ملائمًا. ومع ذلك، فإن المقدر غير الملائم:</p>
<ul class="simple">
<li><p>يجب أن يطرح <a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a> عند استدعاء أسلوب التنبؤ
(<a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a>، <a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a>، إلخ).
(يُستخدم <a class="reference internal" href="modules/generated/sklearn.utils.validation.check_is_fitted.html#sklearn.utils.validation.check_is_fitted" title="sklearn.utils.validation.check_is_fitted"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.validation.check_is_fitted</span></code></a> داخليًا
لهذا الغرض.)</p></li>
<li><p>يجب ألا يحتوي على أي <span class="xref std std-term">سمات</span> تبدأ بحرف أبجدي
وتنتهي بشرطة سفلية. (لاحظ أن واصف
السمة قد لا يزال موجودًا في الفئة، ولكن يجب أن
يُعيد hasattr القيمة False)</p></li>
</ul>
</dd>
<dt id="term-34">دالة<a class="headerlink" href="#term-34" title="Link to this term">#</a></dt><dd><p>نحن نقدم واجهات دوال مخصصة للعديد من الخوارزميات، بينما
تقدم فئات <span class="xref std std-term">المقدر</span> واجهة أكثر اتساقًا.</p>
<p>على وجه الخصوص، قد يقدم Scikit-learn واجهة دالة تُلائم
نموذجًا لبعض البيانات وتُعيد معلمات النموذج التي تم تعلمها، كما هو الحال في
<a class="reference internal" href="modules/generated/sklearn.linear_model.enet_path.html#sklearn.linear_model.enet_path" title="sklearn.linear_model.enet_path"><code class="xref py py-func docutils literal notranslate"><span class="pre">linear_model.enet_path</span></code></a>. بالنسبة للنماذج الاستنتاجية، يُعيد هذا أيضًا
تضمين أو تسميات الكتلة، كما هو الحال في
<a class="reference internal" href="modules/generated/sklearn.manifold.spectral_embedding.html#sklearn.manifold.spectral_embedding" title="sklearn.manifold.spectral_embedding"><code class="xref py py-func docutils literal notranslate"><span class="pre">manifold.spectral_embedding</span></code></a> أو <a class="reference internal" href="modules/generated/dbscan-function.html#sklearn.cluster.dbscan" title="sklearn.cluster.dbscan"><code class="xref py py-func docutils literal notranslate"><span class="pre">cluster.dbscan</span></code></a>. تقدم العديد
من محولات المعالجة المسبقة أيضًا واجهة دالة، تُشبه
استدعاء <a class="reference internal" href="#term-fit_transform"><span class="xref std std-term">fit_transform</span></a>، كما هو الحال في
<a class="reference internal" href="modules/generated/sklearn.preprocessing.maxabs_scale.html#sklearn.preprocessing.maxabs_scale" title="sklearn.preprocessing.maxabs_scale"><code class="xref py py-func docutils literal notranslate"><span class="pre">preprocessing.maxabs_scale</span></code></a>. يجب أن يكون المستخدمون حريصين على تجنب
<a class="reference internal" href="#term-44"><span class="xref std std-term">تسرب البيانات</span></a> عند استخدام هذه
الدوال المكافئة لـ <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code>.</p>
<p>ليس لدينا سياسة صارمة بشأن متى نقدم أو متى لا نقدم
أشكال دوال للمقدرات، ولكن يجب على المسؤولين عن الصيانة مراعاة
الاتساق مع الواجهات الحالية، وما إذا كان توفير دالة
سيؤدي إلى تضليل المستخدمين عن أفضل الممارسات (فيما يتعلق بتسرب البيانات،
إلخ.)</p>
</dd>
<dt id="term-35">معرض<a class="headerlink" href="#term-35" title="Link to this term">#</a></dt><dd><p>انظر <a class="reference internal" href="#term-24"><span class="xref std std-term">أمثلة</span></a>.</p>
</dd>
<dt id="term-36">معلمة فائقة<a class="headerlink" href="#term-36" title="Link to this term">#</a></dt><dd><p>انظر <a class="reference internal" href="#term-52"><span class="xref std std-term">معلمة</span></a>.</p>
</dd>
<dt id="term-37">الإسناد<a class="headerlink" href="#term-37" title="Link to this term">#</a></dt><dd><p>تتطلب معظم خوارزميات التعلم الآلي ألا تحتوي مدخلاتها على
<a class="reference internal" href="#term-46"><span class="xref std std-term">قيم مفقودة</span></a>، ولن تعمل إذا تم انتهاك هذا الشرط.
يُشار إلى الخوارزميات التي تحاول ملء (أو إسناد) القيم المفقودة
باسم خوارزميات الإسناد.</p>
</dd>
<dt id="term-38">قابل للفهرسة<a class="headerlink" href="#term-38" title="Link to this term">#</a></dt><dd><p><a class="reference internal" href="#term-3"><span class="xref std std-term">يشبه المصفوفة</span></a>، <a class="reference internal" href="#term-64"><span class="xref std std-term">مصفوفة متفرقة</span></a>، pandas DataFrame أو
متسلسلة (عادةً ما تكون قائمة).</p>
</dd>
<dt id="term-39">الاستقراء<a class="headerlink" href="#term-39" title="Link to this term">#</a></dt><dt id="term-40">استنتاجي<a class="headerlink" href="#term-40" title="Link to this term">#</a></dt><dd><p>التعلم الآلي الاستنتاجي (على النقيض من <span class="xref std std-term">الاستنتاجي</span>) يبني نموذجًا لبعض البيانات
التي يمكن تطبيقها بعد ذلك على نماذج جديدة.
معظم المقدرات في Scikit-learn استنتاجية، ولديها أساليب <a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a>
و/أو <a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a>.</p>
</dd>
<dt id="term-joblib">joblib<a class="headerlink" href="#term-joblib" title="Link to this term">#</a></dt><dd><p>مكتبة Python (<a class="reference external" href="https://joblib.readthedocs.io">https://joblib.readthedocs.io</a>) تُستخدم في Scikit-learn لـ
تسهيل التوازي البسيط والتخزين المؤقت. يركز Joblib على
العمل بكفاءة مع مصفوفات numpy، مثل من خلال استخدام
<a class="reference internal" href="#term-45"><span class="xref std std-term">تخطيط الذاكرة</span></a>. انظر <a class="reference internal" href="computing/parallelism.html#parallelism"><span class="std std-ref">التوازي</span></a> لمزيد من
المعلومات.</p>
</dd>
<dt id="term-41">مصفوفة مؤشر التسمية<a class="headerlink" href="#term-41" title="Link to this term">#</a></dt><dt id="term-42">مصفوفات مؤشر متعددة التسميات<a class="headerlink" href="#term-42" title="Link to this term">#</a></dt><dd><p>التنسيق المستخدم لتمثيل بيانات متعددة التسميات، حيث يتوافق كل صف من مصفوفة ثنائية الأبعاد
أو مصفوفة متفرقة مع عينة، يتوافق كل عمود
مع فئة، وكل عنصر هو 1 إذا تم تسمية العينة
بالفئة و 0 إن لم يكن.</p>
</dd>
<dt id="term-43">تسرب<a class="headerlink" href="#term-43" title="Link to this term">#</a></dt><dt id="term-44">تسرب البيانات<a class="headerlink" href="#term-44" title="Link to this term">#</a></dt><dd><p>مشكلة في التحقق المتبادل حيث يمكن
المبالغة في تقدير أداء التعميم حيث تم تضمين معرفة بيانات الاختبار عن غير قصد
في تدريب نموذج. هذا خطر، على سبيل المثال، عند
تطبيق <span class="xref std std-term">محول</span> على مجموعة بيانات بأكملها بدلاً من
كل جزء تدريب في تقسيم التحقق المتبادل.</p>
<p>نهدف إلى توفير واجهات (مثل <a class="reference internal" href="api/sklearn.pipeline.html#module-sklearn.pipeline" title="sklearn.pipeline"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pipeline</span></code></a> و
<a class="reference internal" href="api/sklearn.model_selection.html#module-sklearn.model_selection" title="sklearn.model_selection"><code class="xref py py-mod docutils literal notranslate"><span class="pre">model_selection</span></code></a>) تحمي المستخدم من تسرب البيانات.</p>
</dd>
<dt id="term-45">تخطيط الذاكرة<a class="headerlink" href="#term-45" title="Link to this term">#</a></dt><dd><p>استراتيجية كفاءة الذاكرة التي تحتفظ بالبيانات على القرص بدلاً من
نسخها في الذاكرة الرئيسية. يمكن إنشاء خرائط الذاكرة للمصفوفات
التي يمكن قراءتها أو كتابتها أو كليهما، باستخدام <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.memmap.html#numpy.memmap" title="(in NumPy v2.1)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.memmap</span></code></a>. عند
استخدام <a class="reference internal" href="#term-joblib"><span class="xref std std-term">joblib</span></a> لموازاة العمليات في Scikit-learn، قد
يقوم تلقائيًا بتخطيط المصفوفات الكبيرة لتقليل النفقات العامة لازدواجية
الذاكرة في المعالجة المتعددة.</p>
</dd>
<dt id="term-46">قيم مفقودة<a class="headerlink" href="#term-46" title="Link to this term">#</a></dt><dd><p>لا تعمل معظم مقدرات Scikit-learn مع القيم المفقودة. عندما تعمل
(على سبيل المثال، في <a class="reference internal" href="modules/generated/sklearn.impute.SimpleImputer.html#sklearn.impute.SimpleImputer" title="sklearn.impute.SimpleImputer"><code class="xref py py-class docutils literal notranslate"><span class="pre">impute.SimpleImputer</span></code></a>)، فإن NaN هو التمثيل
المفضل للقيم المفقودة في المصفوفات العشرية. إذا كانت المصفوفة
ذات نوع بيانات عدد صحيح، فلا يمكن تمثيل NaN. لهذا السبب، ندعم
تحديد قيمة <code class="docutils literal notranslate"><span class="pre">missing_values</span></code> أخرى عند <a class="reference internal" href="#term-37"><span class="xref std std-term">الإسناد</span></a> أو
يمكن إجراء التعلم في مساحة عدد صحيح.
<span class="xref std std-term">البيانات غير المُعلَّمة</span> هي حالة خاصة للقيم المفقودة
في <a class="reference internal" href="#term-69"><span class="xref std std-term">الهدف</span></a>.</p>
</dd>
<dt id="term-n_features"><code class="docutils literal notranslate"><span class="pre">n_features</span></code><a class="headerlink" href="#term-n_features" title="Link to this term">#</a></dt><dd><p>عدد <a class="reference internal" href="#term-30"><span class="xref std std-term">الميزات</span></a>.</p>
</dd>
<dt id="term-n_outputs"><code class="docutils literal notranslate"><span class="pre">n_outputs</span></code><a class="headerlink" href="#term-n_outputs" title="Link to this term">#</a></dt><dd><p>عدد <a class="reference internal" href="#term-50"><span class="xref std std-term">المخرجات</span></a> في <a class="reference internal" href="#term-69"><span class="xref std std-term">الهدف</span></a>.</p>
</dd>
<dt id="term-n_samples"><code class="docutils literal notranslate"><span class="pre">n_samples</span></code><a class="headerlink" href="#term-n_samples" title="Link to this term">#</a></dt><dd><p>عدد <span class="xref std std-term">العينات</span>.</p>
</dd>
<dt id="term-n_targets"><code class="docutils literal notranslate"><span class="pre">n_targets</span></code><a class="headerlink" href="#term-n_targets" title="Link to this term">#</a></dt><dd><p>مرادف لـ:term:<code class="docutils literal notranslate"><span class="pre">n_outputs</span></code>.</p>
</dd>
<dt id="term-47">وثائق سردية<a class="headerlink" href="#term-47" title="Link to this term">#</a></dt><dd><p>اسم مستعار لـ <a class="reference internal" href="user_guide.html#user-guide"><span class="std std-ref">دليل المستخدم</span></a>، أي الوثائق المكتوبة
في <code class="docutils literal notranslate"><span class="pre">doc/modules/</span></code>. على عكس <a class="reference internal" href="api/index.html#api-ref"><span class="std std-ref">مرجع واجهة برمجة التطبيقات</span></a> المقدم
من خلال سلاسل الوثائق، يهدف دليل المستخدم إلى:</p>
<ul class="simple">
<li><p>تجميع الأدوات التي يوفرها Scikit-learn معًا بشكل موضوعي أو من حيث
الاستخدام؛</p></li>
<li><p>تحفيز سبب استخدام شخص ما لأداة معينة، غالبًا من خلال
المقارنة؛</p></li>
<li><p>تقديم أوصاف بديهية وفنية للأدوات؛</p></li>
<li><p>تقديم أو ربط <a class="reference internal" href="#term-24"><span class="xref std std-term">أمثلة</span></a> لاستخدام الميزات الرئيسية للأداة.</p></li>
</ul>
</dd>
<dt id="term-np">np<a class="headerlink" href="#term-np" title="Link to this term">#</a></dt><dd><p>اختصار لـ Numpy نظرًا لعبارة الاستيراد التقليدية:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</dd>
<dt id="term-48">التعلم عبر الإنترنت<a class="headerlink" href="#term-48" title="Link to this term">#</a></dt><dd><p>حيث يتم تحديث النموذج بشكل متكرر عن طريق تلقي كل دفعة من <a class="reference internal" href="#term-70"><span class="xref std std-term">الأهداف</span></a>
الحقيقية الأساسية بعد وقت قصير من إجراء تنبؤات على الدفعة المقابلة
من البيانات. بطبيعة الحال، يجب أن يكون النموذج قابلاً للاستخدام للتنبؤ
بعد كل دفعة. انظر <a class="reference internal" href="#term-partial_fit"><span class="xref std std-term">partial_fit</span></a>.</p>
</dd>
<dt id="term-49">خارج النواة<a class="headerlink" href="#term-49" title="Link to this term">#</a></dt><dd><p>استراتيجية كفاءة حيث لا يتم تخزين جميع البيانات في الذاكرة الرئيسية
مرة واحدة، عادةً عن طريق إجراء التعلم على دفعات من البيانات. انظر
<a class="reference internal" href="#term-partial_fit"><span class="xref std std-term">partial_fit</span></a>.</p>
</dd>
<dt id="term-50">المخرجات<a class="headerlink" href="#term-50" title="Link to this term">#</a></dt><dd><p>متغيرات قياسية/فئوية فردية لكل عينة في
<a class="reference internal" href="#term-69"><span class="xref std std-term">الهدف</span></a>. على سبيل المثال، في التصنيف متعدد التسميات، يتوافق كل
تسمية ممكنة مع ناتج ثنائي. وتسمى أيضًا <em>الاستجابات</em> أو
<em>المهام</em> أو <em>الأهداف</em>.
انظر <span class="xref std std-term">multiclass multioutput</span> و <span class="xref std std-term">continuous multioutput</span>.</p>
</dd>
<dt id="term-51">زوج<a class="headerlink" href="#term-51" title="Link to this term">#</a></dt><dd><p>tuple بطول اثنين.</p>
</dd>
<dt id="term-52">معلمة<a class="headerlink" href="#term-52" title="Link to this term">#</a></dt><dt id="term-53">المعلمات<a class="headerlink" href="#term-53" title="Link to this term">#</a></dt><dd><p>نستخدم <em>المعلمة</em> في الغالب للإشارة إلى جوانب المقدر التي
يمكن تحديدها في بنائه. على سبيل المثال، <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> و
<code class="docutils literal notranslate"><span class="pre">random_state</span></code> هما معلمات <a class="reference internal" href="modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier" title="sklearn.ensemble.RandomForestClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code></a>.
يتم تخزين المعلمات الخاصة بمُنشئ المقدر دون تعديل كـ
سمات على نموذج المقدر، وتبدأ تقليديًا بحرف
أبجدي وتنتهي بحرف أبجدي رقمي. يتم وصف معلمات مُنشئ
كل مقدر في سلسلة وثائق المقدر.</p>
<p>لا نستخدم المعلمات بالمعنى الإحصائي، حيث تكون المعلمات
هي القيم التي تُحدد نموذجًا ويمكن تقديرها من البيانات. ما
نسميه معلمات قد يكون ما يسميه الإحصائيون المعلمات الفائقة للنموذج:
جوانب لتكوين بنية النموذج التي غالبًا لا يتم
تعلمها مباشرةً من البيانات. ومع ذلك، تُستخدم المعلمات الخاصة بنا أيضًا لـ
وصف عمليات النمذجة التي لا تؤثر على النموذج الذي تم تعلمه، مثل
<a class="reference internal" href="#term-n_jobs"><span class="xref std std-term">n_jobs</span></a> للتحكم في التوازي.</p>
<p>عند الحديث عن معلمات <a class="reference internal" href="#term-86"><span class="xref std std-term">مقدر التعريف التلوي</span></a>، قد
نقوم أيضًا بتضمين معلمات المقدرات التي يغلِّفها
مقدر التعريف التلوي. عادةً، يتم الإشارة إلى هذه المعلمات المتداخلة
باستخدام <a class="reference internal" href="#term-17"><span class="xref std std-term">شرطة سفلية مزدوجة</span></a> (<code class="docutils literal notranslate"><span class="pre">__</span></code>) للفصل بين
المقدر كمعلمة ومعلمته. وبالتالي، <code class="docutils literal notranslate"><span class="pre">clf</span> <span class="pre">=</span>
<span class="pre">BaggingClassifier(estimator=DecisionTreeClassifier(max_depth=3))</span></code>
لديه معلمة عميقة <code class="docutils literal notranslate"><span class="pre">estimator__max_depth</span></code> بقيمة <code class="docutils literal notranslate"><span class="pre">3</span></code>،
والتي يمكن الوصول إليها باستخدام <code class="docutils literal notranslate"><span class="pre">clf.estimator.max_depth</span></code> أو
<code class="docutils literal notranslate"><span class="pre">clf.get_params()['estimator__max_depth']</span></code>.</p>
<p>يمكن استرداد قائمة المعلمات وقيمها الحالية من
<a class="reference internal" href="#term-23"><span class="xref std std-term">نموذج مقدر</span></a> باستخدام أسلوب <a class="reference internal" href="#term-get_params"><span class="xref std std-term">get_params</span></a> الخاص به.</p>
<p>بين الإنشاء والملاءمة، يمكن تعديل المعلمات باستخدام
<a class="reference internal" href="#term-set_params"><span class="xref std std-term">set_params</span></a>. لتمكين هذا، لا يتم عادةً
التحقق من صحة المعلمات أو تغييرها عند إنشاء المقدر، أو عند تعيين كل
معلمة. يتم إجراء التحقق من صحة المعلمة عند استدعاء <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>.</p>
<p>المعلمات الشائعة مُدرجة <a class="reference internal" href="#glossary-parameters"><span class="std std-ref">أدناه</span></a>.</p>
</dd>
<dt id="term-54">مقياس زوجي<a class="headerlink" href="#term-54" title="Link to this term">#</a></dt><dt id="term-55">مقاييس زوجية<a class="headerlink" href="#term-55" title="Link to this term">#</a></dt><dd><p>بمعناه الواسع، يُحدد المقياس الزوجي دالة لقياس
التشابه أو الاختلاف بين عينتين (مع تمثيل كل منهما عادةً
كـ <span class="xref std std-term">متجه ميزة</span>). نحن نقدم بشكل خاص
تطبيقات لمقاييس المسافة (بالإضافة إلى المقاييس غير الصحيحة مثل
مسافة جيب التمام) من خلال <a class="reference internal" href="modules/generated/sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances" title="sklearn.metrics.pairwise_distances"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.pairwise_distances</span></code></a>، و
دوال النواة (فئة مقيدة من دوال التشابه) في
<a class="reference internal" href="modules/generated/sklearn.metrics.pairwise.pairwise_kernels.html#sklearn.metrics.pairwise.pairwise_kernels" title="sklearn.metrics.pairwise.pairwise_kernels"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.pairwise.pairwise_kernels</span></code></a>. يمكن لهذه حساب مصفوفات المسافة الزوجية
المتماثلة وبالتالي تخزين البيانات بشكل زائد عن الحاجة.</p>
<p>انظر أيضًا <a class="reference internal" href="#term-56"><span class="xref std std-term">محسوب مسبقًا</span></a> و <span class="xref std std-term">مقياس</span>.</p>
<p>لاحظ أنه بالنسبة لمعظم مقاييس المسافة، نعتمد على التطبيقات من
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/spatial.distance.html#module-scipy.spatial.distance" title="(in SciPy v1.14.1)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.spatial.distance</span></code></a>، ولكن قد نعيد التنفيذ من أجل الكفاءة في
سياقنا. تُستخدم واجهة <a class="reference internal" href="modules/generated/sklearn.metrics.DistanceMetric.html#sklearn.metrics.DistanceMetric" title="sklearn.metrics.DistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">metrics.DistanceMetric</span></code></a> لتنفيذ
مقاييس المسافة للتكامل مع بحث الجيران الفعال.</p>
</dd>
<dt id="term-pd">pd<a class="headerlink" href="#term-pd" title="Link to this term">#</a></dt><dd><p>اختصار لـ <a class="reference external" href="https://pandas.pydata.org">Pandas</a> نظرًا لعبارة
الاستيراد التقليدية:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</pre></div>
</div>
</dd>
<dt id="term-56">محسوب مسبقًا<a class="headerlink" href="#term-56" title="Link to this term">#</a></dt><dd><p>حيث تعتمد الخوارزميات على <span class="xref std std-term">المقاييس الزوجية</span>، ويمكن حسابها
من المقاييس الزوجية وحدها، غالبًا ما نسمح للمستخدم بتحديد
أن <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a> المقدم موجود بالفعل في مساحة (عدم) التشابه الزوجية،
بدلاً من مساحة الميزات. أي أنه عند تمريره إلى
<a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>، فهو مصفوفة مربعة متماثلة، مع كل متجه
يشير إلى (عدم) التشابه مع كل عينة، وعندما يتم تمريره إلى
أساليب التنبؤ/التحويل، يتوافق كل صف مع عينة اختبار
وكل عمود مع عينة تدريب.</p>
<p>عادةً ما تتم الإشارة إلى استخدام X المحسوب مسبقًا عن طريق تعيين معلمة <code class="docutils literal notranslate"><span class="pre">metric</span></code>
أو <code class="docutils literal notranslate"><span class="pre">affinity</span></code> أو <code class="docutils literal notranslate"><span class="pre">kernel</span></code> إلى السلسلة &quot;precomputed&quot;. إذا
كان هذا هو الحال، فيجب على المقدر تعيين علامة المقدر <code class="docutils literal notranslate"><span class="pre">pairwise</span></code>
على أنها True.</p>
</dd>
<dt id="term-57">مستطيلي<a class="headerlink" href="#term-57" title="Link to this term">#</a></dt><dd><p>تسمى البيانات التي يمكن تمثيلها كمصفوفة بـ <a class="reference internal" href="#term-59"><span class="xref std std-term">عينات</span></a> على
المحور الأول ومجموعة ثابتة ومحدودة من <a class="reference internal" href="#term-30"><span class="xref std std-term">الميزات</span></a> على المحور الثاني
بالمستطيلة.</p>
<p>يستبعد هذا المصطلح العينات ذات الهياكل غير المتجهة، مثل النص،
وصورة ذات حجم عشوائي، وسلسلة زمنية ذات طول عشوائي، ومجموعة من
المتجهات، إلخ. الغرض من <a class="reference internal" href="#term-96"><span class="xref std std-term">المحول المتجه</span></a> هو إنتاج
أشكال مستطيلة لمثل هذه البيانات.</p>
</dd>
<dt id="term-58">عينة<a class="headerlink" href="#term-58" title="Link to this term">#</a></dt><dt id="term-59">عينات<a class="headerlink" href="#term-59" title="Link to this term">#</a></dt><dd><p>عادةً ما نستخدم هذا المصطلح كاسم للإشارة إلى متجه ميزة واحد.
في مكان آخر، تسمى العينة نموذجًا أو نقطة بيانات أو ملاحظة.
يشير <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> إلى عدد العينات في مجموعة البيانات، وهو عدد
الصفوف في مصفوفة البيانات <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a>.</p>
</dd>
<dt id="term-60">خاصية العينة<a class="headerlink" href="#term-60" title="Link to this term">#</a></dt><dt id="term-61">خصائص العينة<a class="headerlink" href="#term-61" title="Link to this term">#</a></dt><dd><p>خاصية العينة هي بيانات لكل عينة (على سبيل المثال، مصفوفة بطول
n_samples) يتم تمريرها إلى أسلوب مقدر أو دالة مماثلة،
جنبًا إلى جنب مع <a class="reference internal" href="#term-30"><span class="xref std std-term">الميزات</span></a> (<code class="docutils literal notranslate"><span class="pre">X</span></code>) و
<a class="reference internal" href="#term-69"><span class="xref std std-term">الهدف</span></a> (<code class="docutils literal notranslate"><span class="pre">y</span></code>) ولكنها مميزة عنها. المثال الأبرز هو
<a class="reference internal" href="#term-sample_weight"><span class="xref std std-term">sample_weight</span></a>؛ انظر أمثلة أخرى في <a class="reference internal" href="#glossary-sample-props"><span class="std std-ref">خصائص البيانات والعينة</span></a>.</p>
<p>اعتبارًا من الإصدار 0.19، ليس لدينا نهج متسق للتعامل مع
خصائص العينة وتوجيهها في <a class="reference internal" href="#term-87"><span class="xref std std-term">مقدرات التعريف التلوي</span></a>، على الرغم من
أنه غالبًا ما يتم استخدام معلمة <code class="docutils literal notranslate"><span class="pre">fit_params</span></code>.</p>
</dd>
<dt id="term-scikit-learn-contrib">scikit-learn-contrib<a class="headerlink" href="#term-scikit-learn-contrib" title="Link to this term">#</a></dt><dd><p>مكان لنشر مكتبات متوافقة مع Scikit-learn تم
ترخيصها على نطاق واسع من قبل المطورين الأساسيين ومجتمع contrib،
ولكن لا تتم صيانتها من قبل فريق المطورين الأساسي.
انظر <a class="reference external" href="https://scikit-learn-contrib.github.io">https://scikit-learn-contrib.github.io</a>.</p>
</dd>
<dt id="term-scikit-learn">مقترحات تحسين scikit-learn<a class="headerlink" href="#term-scikit-learn" title="Link to this term">#</a></dt><dd><p>تحدث التغييرات على مبادئ واجهة برمجة التطبيقات والتغييرات على التبعيات أو الإصدارات
المدعومة عبر <a class="reference internal" href="governance.html#slep"><span class="std std-ref">SLEP</span></a> وتتبع عملية
صنع القرار الموضحة في <a class="reference internal" href="governance.html#governance"><span class="std std-ref">حوكمة Scikit-learn وصنع القرار</span></a>.
بالنسبة لجميع عمليات التصويت، يجب أن يكون الاقتراح قد تم نشره ومناقشته قبل
التصويت. يجب أن يكون هذا الاقتراح وثيقة موحدة، في شكل
&quot;اقتراح تحسين Scikit-Learn&quot; (SLEP)، بدلاً من مناقشة طويلة حول
مشكلة. يجب إرسال SLEP كطلب سحب إلى
<a class="reference external" href="https://scikit-learn-enhancement-proposals.readthedocs.io">مقترحات التحسين</a> باستخدام
<a class="reference external" href="https://scikit-learn-enhancement-proposals.readthedocs.io/en/latest/slep_template.html">قالب SLEP</a>.</p>
</dd>
<dt id="term-62">شبه خاضع للإشراف<a class="headerlink" href="#term-62" title="Link to this term">#</a></dt><dt id="term-63">التعلم شبه الخاضع للإشراف<a class="headerlink" href="#term-63" title="Link to this term">#</a></dt><dd><p>التعلم حيث يكون التنبؤ المتوقع (التسمية أو الحقيقة الأساسية) متاحًا فقط
لبعض العينات المقدمة كبيانات تدريب عند <span class="xref std std-term">ملاءمة</span>
النموذج. نطبق عادةً التسمية <code class="docutils literal notranslate"><span class="pre">-1</span></code>
على العينات <span class="xref std std-term">غير المُعلَّمة</span> في التصنيف شبه الخاضع للإشراف.</p>
</dd>
<dt id="term-64">مصفوفة متفرقة<a class="headerlink" href="#term-64" title="Link to this term">#</a></dt><dt id="term-65">رسم بياني متفرق<a class="headerlink" href="#term-65" title="Link to this term">#</a></dt><dd><p>تمثيل للبيانات الرقمية ثنائية الأبعاد أكثر كفاءة في استخدام الذاكرة
من مصفوفة numpy الكثيفة المقابلة حيث تكون جميع العناصر تقريبًا
صفراً. نستخدم إطار عمل <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse" title="(in SciPy v1.14.1)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse</span></code></a>، الذي يوفر
العديد من تمثيلات البيانات المتفرقة الأساسية، أو <em>التنسيقات</em>.
تكون بعض التنسيقات أكثر كفاءة من غيرها لمهام معينة، و
عندما يوفر تنسيق معين فائدة خاصة، نحاول توثيق
هذه الحقيقة في أوصاف معلمات Scikit-learn.</p>
<p>تميز بعض تنسيقات المصفوفة المتفرقة (خاصة CSR و CSC و COO و LIL)
بين الأصفار <em>الضمنية</em> و <em>الصريحة</em>. يتم تخزين الأصفار الصريحة
(أي أنها تستهلك الذاكرة في مصفوفة <code class="docutils literal notranslate"><span class="pre">data</span></code>) في بنية البيانات،
بينما تتوافق الأصفار الضمنية مع كل عنصر غير مُعرَّف بطريقة أخرى
في التخزين الصريح.</p>
<p>يتم استخدام اثنين من دلالات المصفوفات المتفرقة في Scikit-learn:</p>
<dl class="simple">
<dt>دلالات المصفوفة</dt><dd><p>يتم تفسير المصفوفة المتفرقة على أنها مصفوفة مع تفسير الأصفار الضمنية
والصريحة على أنها الرقم 0. هذا هو
التفسير الأكثر استخدامًا، على سبيل المثال عندما يتم استخدام المصفوفات المتفرقة
لمصفوفات الميزات أو <a class="reference internal" href="#term-42"><span class="xref std std-term">مصفوفات مؤشر متعددة التسميات</span></a>.</p>
</dd>
<dt>دلالات الرسم البياني</dt><dd><p>كما هو الحال مع <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.csgraph.html#module-scipy.sparse.csgraph" title="(in SciPy v1.14.1)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.csgraph</span></code></a>، يتم
تفسير الأصفار الصريحة على أنها الرقم 0، لكن الأصفار الضمنية تشير إلى قيمة مُقنعة
أو غائبة، مثل عدم وجود حافة بين رأسين
لرسم بياني، حيث تشير القيمة الصريحة إلى وزن الحافة. يتم اعتماد هذا التفسير لتمثيل
الاتصال في التجميع، وفي تمثيلات أقرب الجيران
(على سبيل المثال <a class="reference internal" href="modules/generated/sklearn.neighbors.kneighbors_graph.html#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">neighbors.kneighbors_graph</span></code></a>)، ولتمثيل
المسافة المحسوبة مسبقًا حيث تكون المسافات في جوار
كل نقطة مطلوبة فقط.</p>
</dd>
</dl>
<p>عند العمل مع المصفوفات المتفرقة، نفترض أنها متفرقة لسبب
وجيه، ونتجنب كتابة كود يُكثِّف مصفوفة متفرقة يوفرها المستخدم،
بدلاً من الحفاظ على التناثر أو طرح خطأ إذا لم يكن
ذلك ممكنًا (أي إذا كان المقدر لا يدعم/لا يمكنه دعم المصفوفات
المتفرقة).</p>
</dd>
<dt id="term-66">عديم الحالة<a class="headerlink" href="#term-66" title="Link to this term">#</a></dt><dd><p>يكون المقدر عديم الحالة إذا لم يُخزِّن أي معلومات يتم
الحصول عليها أثناء <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>. يمكن أن تكون هذه المعلومات إما معلمات
تم تعلمها أثناء <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> أو إحصائيات محسوبة من
بيانات التدريب. يكون المقدر عديم الحالة إذا لم يكن لديه <span class="xref std std-term">سمات</span>
بصرف النظر عن تلك التي تم تعيينها في <code class="docutils literal notranslate"><span class="pre">__init__</span></code>. سيؤدي استدعاء <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> لهذه
المقدرات إلى التحقق من صحة <a class="reference internal" href="#term-5"><span class="xref std std-term">السمات</span></a> العامة التي تم تمريرها
في <code class="docutils literal notranslate"><span class="pre">__init__</span></code> فقط.</p>
</dd>
<dt id="term-67">خاضع للإشراف<a class="headerlink" href="#term-67" title="Link to this term">#</a></dt><dt id="term-68">التعلم الخاضع للإشراف<a class="headerlink" href="#term-68" title="Link to this term">#</a></dt><dd><p>التعلم حيث يكون التنبؤ المتوقع (التسمية أو الحقيقة الأساسية) متاحًا
لكل عينة عند <span class="xref std std-term">ملاءمة</span> النموذج، يتم توفيره كـ
<a class="reference internal" href="#term-y"><span class="xref std std-term">y</span></a>. هذا هو النهج المتبع في <span class="xref std std-term">المصنف</span> أو
<a class="reference internal" href="#term-92"><span class="xref std std-term">مقدر الانحدار</span></a> من بين المقدرات الأخرى.</p>
</dd>
<dt id="term-69">الهدف<a class="headerlink" href="#term-69" title="Link to this term">#</a></dt><dt id="term-70">الأهداف<a class="headerlink" href="#term-70" title="Link to this term">#</a></dt><dd><p><em>المتغير التابع</em> في التعلم <span class="xref std std-term">الخاضع للإشراف</span> (و
<span class="xref std std-term">شبه الخاضع للإشراف</span>)، يتم تمريره كـ <a class="reference internal" href="#term-y"><span class="xref std std-term">y</span></a> إلى أسلوب
<a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> الخاص بالمقدر. يُعرف أيضًا باسم <em>المتغير التابع</em> أو <em>متغير
النتيجة</em> أو <em>متغير الاستجابة</em> أو <em>الحقيقة الأساسية</em> أو <em>التسمية</em>. يعمل Scikit-learn
مع الأهداف ذات البنية الدنيا: فئة من مجموعة محدودة،
رقم ذو قيمة حقيقية محدودة، فئات متعددة، أو أرقام
متعددة. انظر <a class="reference internal" href="#glossary-target-types"><span class="std std-ref">أنواع الأهداف</span></a>.</p>
</dd>
<dt id="term-71">الاستنتاج<a class="headerlink" href="#term-71" title="Link to this term">#</a></dt><dt id="term-72">استنتاجي<a class="headerlink" href="#term-72" title="Link to this term">#</a></dt><dd><p>أسلوب التعلم الآلي الاستنتاجي (على النقيض من <span class="xref std std-term">الاستقرائي</span>) مُصمم
لنمذجة مجموعة بيانات محددة، ولكن ليس لتطبيق هذا
النموذج على البيانات غير المرئية. تشمل الأمثلة <a class="reference internal" href="modules/generated/sklearn.manifold.TSNE.html#sklearn.manifold.TSNE" title="sklearn.manifold.TSNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">manifold.TSNE</span></code></a>،
<a class="reference internal" href="modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering" title="sklearn.cluster.AgglomerativeClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">cluster.AgglomerativeClustering</span></code></a> و
<a class="reference internal" href="modules/generated/sklearn.neighbors.LocalOutlierFactor.html#sklearn.neighbors.LocalOutlierFactor" title="sklearn.neighbors.LocalOutlierFactor"><code class="xref py py-class docutils literal notranslate"><span class="pre">neighbors.LocalOutlierFactor</span></code></a>.</p>
</dd>
<dt id="term-73">غير مُعلَّم<a class="headerlink" href="#term-73" title="Link to this term">#</a></dt><dt id="term-74">بيانات غير مُعلَّمة<a class="headerlink" href="#term-74" title="Link to this term">#</a></dt><dd><p>عينات ذات حقيقة أساسية غير معروفة عند الملاءمة؛ على نحو مكافئ،
<a class="reference internal" href="#term-46"><span class="xref std std-term">قيم مفقودة</span></a> في <a class="reference internal" href="#term-69"><span class="xref std std-term">الهدف</span></a>. انظر أيضًا
التعلم <span class="xref std std-term">شبه الخاضع للإشراف</span> و <span class="xref std std-term">غير الخاضع للإشراف</span>.</p>
</dd>
<dt id="term-75">غير خاضع للإشراف<a class="headerlink" href="#term-75" title="Link to this term">#</a></dt><dt id="term-76">التعلم غير الخاضع للإشراف<a class="headerlink" href="#term-76" title="Link to this term">#</a></dt><dd><p>التعلم حيث لا يتوفر التنبؤ المتوقع (التسمية أو الحقيقة الأساسية)
لكل عينة عند <span class="xref std std-term">ملاءمة</span> النموذج، كما هو الحال في
<span class="xref std std-term">مُجمِّعات</span> و <a class="reference internal" href="#term-89"><span class="xref std std-term">كاشفات القيم المتطرفة</span></a>. تتجاهل المقدرات
غير الخاضعة للإشراف أي <a class="reference internal" href="#term-y"><span class="xref std std-term">y</span></a> تم تمريره إلى <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>.</p>
</dd>
</dl>
</section>
<section id="glossary-estimator-types">
<span id="id5"></span><h2>واجهات برمجة تطبيقات الفئات وأنواع المقدرات<a class="headerlink" href="#glossary-estimator-types" title="Link to this heading">#</a></h2>
<dl class="glossary">
<dt id="term-77">مصنف<a class="headerlink" href="#term-77" title="Link to this term">#</a></dt><dt id="term-78">المصنفات<a class="headerlink" href="#term-78" title="Link to this term">#</a></dt><dd><p><span class="xref std std-term">متنبئ</span> <a class="reference internal" href="#term-67"><span class="xref std std-term">خاضع للإشراف</span></a> (أو <a class="reference internal" href="#term-62"><span class="xref std std-term">شبه خاضع للإشراف</span></a>)
مع مجموعة محدودة من قيم الإخراج المنفصلة الممكنة.</p>
<p>يدعم المصنف نمذجة بعض <span class="xref std std-term">الثنائية</span> أو
<span class="xref std std-term">متعددة الفئات</span> أو <span class="xref std std-term">متعددة التسميات</span> أو <span class="xref std std-term">متعددة الفئات
متعددة المخرجات</span> الأهداف. ضمن scikit-learn، تدعم جميع المصنفات
التصنيف متعدد الفئات، وتستخدم افتراضيًا استراتيجية واحد مقابل البقية
على مشكلة التصنيف الثنائي.</p>
<p>يجب على المصنفات تخزين سمة <a class="reference internal" href="#term-classes_"><span class="xref std std-term">classes_</span></a> بعد الملاءمة،
وعادةً ما ترث من <a class="reference internal" href="modules/generated/sklearn.base.ClassifierMixin.html#sklearn.base.ClassifierMixin" title="sklearn.base.ClassifierMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.ClassifierMixin</span></code></a>، التي تُعيِّن
سمة <a class="reference internal" href="#term-_estimator_type"><span class="xref std std-term">_estimator_type</span></a> الخاصة بها.</p>
<p>يمكن تمييز المصنف عن المقدرات الأخرى باستخدام
<a class="reference internal" href="modules/generated/sklearn.base.is_classifier.html#sklearn.base.is_classifier" title="sklearn.base.is_classifier"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_classifier</span></code></a>.</p>
<p>يجب على المصنف تنفيذ:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a></p></li>
<li><p><a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a></p></li>
<li><p><a class="reference internal" href="#term-score"><span class="xref std std-term">score</span></a></p></li>
</ul>
<p>قد يكون من المناسب أيضًا تنفيذ <a class="reference internal" href="#term-decision_function"><span class="xref std std-term">decision_function</span></a>،
<a class="reference internal" href="#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> و <a class="reference internal" href="#term-predict_log_proba"><span class="xref std std-term">predict_log_proba</span></a>.</p>
</dd>
<dt id="term-79">مُجمِّع<a class="headerlink" href="#term-79" title="Link to this term">#</a></dt><dt id="term-80">المُجمِّعات<a class="headerlink" href="#term-80" title="Link to this term">#</a></dt><dd><p><span class="xref std std-term">متنبئ</span> <a class="reference internal" href="#term-75"><span class="xref std std-term">غير خاضع للإشراف</span></a> مع مجموعة محدودة من قيم
الإخراج المنفصلة.</p>
<p>عادةً ما يُخزِّن المُجمِّع <a class="reference internal" href="#term-labels_"><span class="xref std std-term">labels_</span></a> بعد الملاءمة، ويجب أن يفعل ذلك
إذا كان <span class="xref std std-term">استنتاجيًا</span>.</p>
<p>يجب على المُجمِّع تنفيذ:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a></p></li>
<li><p><a class="reference internal" href="#term-fit_predict"><span class="xref std std-term">fit_predict</span></a> إذا كان <span class="xref std std-term">استنتاجيًا</span></p></li>
<li><p><a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a> إذا كان <span class="xref std std-term">استقرائيًا</span></p></li>
</ul>
</dd>
<dt id="term-81">مقدر الكثافة<a class="headerlink" href="#term-81" title="Link to this term">#</a></dt><dd><p>تقدير <a class="reference internal" href="#term-75"><span class="xref std std-term">غير خاضع للإشراف</span></a> لدالة كثافة احتمالية الإدخال.
التقنيات شائعة الاستخدام هي:</p>
<ul class="simple">
<li><p><a class="reference internal" href="modules/density.html#kernel-density"><span class="std std-ref">تقدير كثافة النواة</span></a> - يستخدم دالة نواة، يتم التحكم فيها بواسطة
معلمة عرض النطاق الترددي لتمثيل الكثافة؛</p></li>
<li><p><a class="reference internal" href="modules/mixture.html#mixture"><span class="std std-ref">خليط غاوسي</span></a> - يستخدم خليطًا من نماذج غاوسية
لتمثيل الكثافة.</p></li>
</ul>
</dd>
<dt id="term-82">مقدر<a class="headerlink" href="#term-82" title="Link to this term">#</a></dt><dt id="term-83">المقدرات<a class="headerlink" href="#term-83" title="Link to this term">#</a></dt><dd><p>كائن يُدير تقدير وفك تشفير نموذج. يتم تقدير النموذج كدالة حتمية لـ:</p>
<ul class="simple">
<li><p><span class="xref std std-term">معلمات</span> مقدمة في إنشاء الكائن أو مع
<a class="reference internal" href="#term-set_params"><span class="xref std std-term">set_params</span></a>؛</p></li>
<li><p>حالة عشوائية <a class="reference external" href="https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random" title="(in NumPy v2.1)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy.random</span></code></a> العالمية إذا تم تعيين
معلمة <a class="reference internal" href="#term-random_state"><span class="xref std std-term">random_state</span></a> الخاصة بالمقدر على لا شيء؛ و</p></li>
<li><p>أي بيانات أو <span class="xref std std-term">خصائص عينة</span> تم تمريرها إلى أحدث
استدعاء لـ <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>، <a class="reference internal" href="#term-fit_transform"><span class="xref std std-term">fit_transform</span></a> أو <a class="reference internal" href="#term-fit_predict"><span class="xref std std-term">fit_predict</span></a>،
أو بيانات تم تمريرها بشكل مشابه في سلسلة من الاستدعاءات لـ
<a class="reference internal" href="#term-partial_fit"><span class="xref std std-term">partial_fit</span></a>.</p></li>
</ul>
<p>يتم تخزين النموذج المُقدَّر في <span class="xref std std-term">سمات</span> عامة وخاصة
على نموذج المقدر، مما يُسهِّل فك التشفير من خلال أساليب التنبؤ
والتحويل.</p>
<p>يجب أن توفر المقدرات أسلوب <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>، ويجب أن توفر
<a class="reference internal" href="#term-set_params"><span class="xref std std-term">set_params</span></a> و <a class="reference internal" href="#term-get_params"><span class="xref std std-term">get_params</span></a>، على الرغم من أنها عادةً ما يتم
توفيرها عن طريق الوراثة من <a class="reference internal" href="modules/generated/sklearn.base.BaseEstimator.html#sklearn.base.BaseEstimator" title="sklearn.base.BaseEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.BaseEstimator</span></code></a>.</p>
<p>قد تتوفر الوظيفة الأساسية لبعض المقدرات أيضًا كـ
<a class="reference internal" href="#term-34"><span class="xref std std-term">دالة</span></a>.</p>
</dd>
<dt id="term-84">مستخرج الميزات<a class="headerlink" href="#term-84" title="Link to this term">#</a></dt><dt id="term-85">مستخرجات الميزات<a class="headerlink" href="#term-85" title="Link to this term">#</a></dt><dd><p><span class="xref std std-term">محول</span> يأخذ مدخلات حيث لا يتم تمثيل كل عينة
ككائن <a class="reference internal" href="#term-3"><span class="xref std std-term">يشبه المصفوفة</span></a> بطول ثابت، و
ينتج كائنًا <a class="reference internal" href="#term-3"><span class="xref std std-term">يشبه المصفوفة</span></a> من <a class="reference internal" href="#term-30"><span class="xref std std-term">الميزات</span></a> لكل
عينة (وبالتالي مصفوفة ثنائية الأبعاد تشبه مجموعة من العينات).  بمعنى آخر،
إنه يقوم بتعيين تمثيل بيانات غير مستطيل (مع فقد)
إلى بيانات <span class="xref std std-term">مستطيلة</span>.</p>
<p>يجب أن تُنفذ مستخرجات الميزات على الأقل:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a></p></li>
<li><p><a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a></p></li>
<li><p><a class="reference internal" href="#term-get_feature_names_out"><span class="xref std std-term">get_feature_names_out</span></a></p></li>
</ul>
</dd>
<dt id="term-86">مقدر التعريف التلوي<a class="headerlink" href="#term-86" title="Link to this term">#</a></dt><dt id="term-87">مقدرات التعريف التلوي<a class="headerlink" href="#term-87" title="Link to this term">#</a></dt><dd><p><a class="reference internal" href="#term-82"><span class="xref std std-term">مقدر</span></a> يأخذ مقدرًا آخر كمعلمة.
تشمل الأمثلة <a class="reference internal" href="modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">pipeline.Pipeline</span></code></a>،
<a class="reference internal" href="modules/generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">model_selection.GridSearchCV</span></code></a>،
<a class="reference internal" href="modules/generated/sklearn.feature_selection.SelectFromModel.html#sklearn.feature_selection.SelectFromModel" title="sklearn.feature_selection.SelectFromModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">feature_selection.SelectFromModel</span></code></a> و
<a class="reference internal" href="modules/generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier" title="sklearn.ensemble.BaggingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ensemble.BaggingClassifier</span></code></a>.</p>
<p>في أسلوب <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> الخاص بمقدر التعريف التلوي، يجب
<a class="reference internal" href="#term-9"><span class="xref std std-term">استنساخ</span></a> أي مقدرات مُضمنة قبل ملاءمتها (على الرغم من FIXME:
لا يقوم Pipeline و FeatureUnion بذلك حاليًا). استثناء من ذلك هو
أن المقدر قد يوثق صراحةً أنه يقبل مقدرًا تم توفيقه مسبقًا (على سبيل المثال،
باستخدام <code class="docutils literal notranslate"><span class="pre">prefit</span> <span class="pre">=</span> <span class="pre">True</span></code> في
<a class="reference internal" href="modules/generated/sklearn.feature_selection.SelectFromModel.html#sklearn.feature_selection.SelectFromModel" title="sklearn.feature_selection.SelectFromModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">feature_selection.SelectFromModel</span></code></a>). إحدى المشكلات المعروفة المتعلقة بهذا
هي أن المقدر الملائم مسبقًا سيفقد نموذجه إذا تم
استنساخ مقدر التعريف التلوي. يجب استدعاء <code class="docutils literal notranslate"><span class="pre">fit</span></code> لمقدر التعريف التلوي
قبل التنبؤ، حتى لو كانت جميع المقدرات المُضمنة ملائمة مسبقًا.</p>
<p>في الحالات التي تكون فيها السلوكيات الأساسية لمقدر التعريف التلوي (على سبيل المثال،
تنفيذ <a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a> أو <a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a>) دوالًا لـ
أساليب التنبؤ/التحويل الخاصة بـ <em>المقدر الأساسي</em> المقدم (أو
مقدرات أساسية متعددة)، يجب أن يقدم مقدر التعريف التلوي على الأقل
الأساليب القياسية التي يوفرها المقدر الأساسي. قد لا يكون
من الممكن تحديد الأساليب التي يوفرها المقدر الأساسي حتى
يتم <span class="xref std std-term">ملاءمة</span> مقدر التعريف التلوي (انظر أيضًا
<a class="reference internal" href="#term-21"><span class="xref std std-term">كتابة البطة</span></a>)، والتي قد يساعد <a class="reference internal" href="modules/generated/sklearn.utils.metaestimators.available_if.html#sklearn.utils.metaestimators.available_if" title="sklearn.utils.metaestimators.available_if"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.metaestimators.available_if</span></code></a> فيها.
يجب أيضًا أن يقدم (أو يُعدِّل) <a class="reference internal" href="#term-28"><span class="xref std std-term">علامات المقدر</span></a> و
سمة <a class="reference internal" href="#term-classes_"><span class="xref std std-term">classes_</span></a> التي يوفرها المقدر الأساسي.</p>
<p>يجب أن تكون مقدرات التعريف التلوي حريصة على التحقق من صحة البيانات بأقل قدر ممكن
قبل تمريرها إلى مقدر أساسي. يوفر هذا
وقت الحساب، وقد يسمح، على سبيل المثال، للمقدر
الأساسي بالعمل بسهولة مع البيانات غير <span class="xref std std-term">المستطيلة</span>.</p>
</dd>
<dt id="term-88">كاشف القيم المتطرفة<a class="headerlink" href="#term-88" title="Link to this term">#</a></dt><dt id="term-89">كاشفات القيم المتطرفة<a class="headerlink" href="#term-89" title="Link to this term">#</a></dt><dd><p><span class="xref std std-term">متنبئ</span> ثنائي <a class="reference internal" href="#term-75"><span class="xref std std-term">غير خاضع للإشراف</span></a> يُنمذج
التمييز بين العينات الأساسية والمتطرفة.</p>
<p>يجب أن تُنفذ كاشفات القيم المتطرفة:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a></p></li>
<li><p><a class="reference internal" href="#term-fit_predict"><span class="xref std std-term">fit_predict</span></a> إذا كان <span class="xref std std-term">استنتاجيًا</span></p></li>
<li><p><a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a> إذا كان <span class="xref std std-term">استقرائيًا</span></p></li>
</ul>
<p>قد تُنفذ كاشفات القيم المتطرفة الاستقرائية أيضًا
<a class="reference internal" href="#term-decision_function"><span class="xref std std-term">decision_function</span></a> لإعطاء درجة غير طبيعية طبيعية حيث
تكون القيم المتطرفة ذات درجة أقل من 0. قد يوفر <a class="reference internal" href="#term-score_samples"><span class="xref std std-term">score_samples</span></a>
درجة غير طبيعية لكل عينة.</p>
</dd>
<dt id="term-90">المتنبئ<a class="headerlink" href="#term-90" title="Link to this term">#</a></dt><dt id="term-91">المتنبئات<a class="headerlink" href="#term-91" title="Link to this term">#</a></dt><dd><p><a class="reference internal" href="#term-82"><span class="xref std std-term">مقدر</span></a> يدعم <a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a> و/أو
<a class="reference internal" href="#term-fit_predict"><span class="xref std std-term">fit_predict</span></a>. يشمل هذا <span class="xref std std-term">المصنف</span>،
<a class="reference internal" href="#term-92"><span class="xref std std-term">مقدر الانحدار</span></a>، <a class="reference internal" href="#term-88"><span class="xref std std-term">كاشف القيم المتطرفة</span></a> و <span class="xref std std-term">المُجمِّع</span>.</p>
<p>في الإحصاء، تشير &quot;المتنبئات&quot; إلى <a class="reference internal" href="#term-30"><span class="xref std std-term">الميزات</span></a>.</p>
</dd>
<dt id="term-92">مقدر الانحدار<a class="headerlink" href="#term-92" title="Link to this term">#</a></dt><dt id="term-93">مقدرات الانحدار<a class="headerlink" href="#term-93" title="Link to this term">#</a></dt><dd><p><span class="xref std std-term">متنبئ</span> <a class="reference internal" href="#term-67"><span class="xref std std-term">خاضع للإشراف</span></a> (أو <a class="reference internal" href="#term-62"><span class="xref std std-term">شبه خاضع للإشراف</span></a>)
بقيم ناتج <span class="xref std std-term">مستمرة</span>.</p>
<p>عادةً ما ترث مقدرات الانحدار من <a class="reference internal" href="modules/generated/sklearn.base.RegressorMixin.html#sklearn.base.RegressorMixin" title="sklearn.base.RegressorMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.RegressorMixin</span></code></a>، والتي
تُعيِّن سمة <a class="reference internal" href="#term-_estimator_type"><span class="xref std std-term">_estimator_type</span></a> الخاصة بها.</p>
<p>يمكن تمييز مقدر الانحدار عن المقدرات الأخرى باستخدام
<a class="reference internal" href="modules/generated/sklearn.base.is_regressor.html#sklearn.base.is_regressor" title="sklearn.base.is_regressor"><code class="xref py py-func docutils literal notranslate"><span class="pre">is_regressor</span></code></a>.</p>
<p>يجب أن يُنفذ مقدر الانحدار:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a></p></li>
<li><p><a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a></p></li>
<li><p><a class="reference internal" href="#term-score"><span class="xref std std-term">score</span></a></p></li>
</ul>
</dd>
<dt id="term-94">المحول<a class="headerlink" href="#term-94" title="Link to this term">#</a></dt><dt id="term-95">المحولات<a class="headerlink" href="#term-95" title="Link to this term">#</a></dt><dd><p>مقدر يدعم <a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a> و/أو <a class="reference internal" href="#term-fit_transform"><span class="xref std std-term">fit_transform</span></a>.
<span class="xref std std-term">محول استنتاجي</span> بحت، مثل
<a class="reference internal" href="modules/generated/sklearn.manifold.TSNE.html#sklearn.manifold.TSNE" title="sklearn.manifold.TSNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">manifold.TSNE</span></code></a>، قد لا يُنفذ <code class="docutils literal notranslate"><span class="pre">transform</span></code>.</p>
</dd>
<dt id="term-96">المحول المتجه<a class="headerlink" href="#term-96" title="Link to this term">#</a></dt><dd><p>انظر <a class="reference internal" href="#term-84"><span class="xref std std-term">مستخرج الميزات</span></a>.</p>
</dd>
</dl>
<p>هناك المزيد من واجهات برمجة التطبيقات المتعلقة على وجه التحديد بعائلة صغيرة من المقدرات،
مثل:</p>
<dl class="simple glossary">
<dt id="term-97">مُقسِّم التحقق المتبادل<a class="headerlink" href="#term-97" title="Link to this term">#</a></dt><dt id="term-98">مُولِّد التحقق المتبادل<a class="headerlink" href="#term-98" title="Link to this term">#</a></dt><dd><p>عائلة غير مقدرة من الفئات تُستخدم لتقسيم مجموعة بيانات إلى
سلسلة من أجزاء التدريب والاختبار (انظر <a class="reference internal" href="modules/cross_validation.html#cross-validation"><span class="std std-ref">التحقق المتبادل: تقييم أداء المقدر</span></a>)،
عن طريق توفير أساليب <a class="reference internal" href="#term-split"><span class="xref std std-term">split</span></a> و <a class="reference internal" href="#term-get_n_splits"><span class="xref std std-term">get_n_splits</span></a>.
لاحظ أنه على عكس المقدرات، لا تحتوي هذه على أساليب <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>
ولا توفر <a class="reference internal" href="#term-set_params"><span class="xref std std-term">set_params</span></a> أو <a class="reference internal" href="#term-get_params"><span class="xref std std-term">get_params</span></a>.
قد يتم إجراء التحقق من صحة المعلمات في <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p>
</dd>
<dt id="term-99">مقدر التحقق المتبادل<a class="headerlink" href="#term-99" title="Link to this term">#</a></dt><dd><p>مقدر لديه إمكانيات تحقق متبادل مدمجة لـ
تحديد أفضل المعلمات الفائقة تلقائيًا (انظر <a class="reference internal" href="modules/grid_search.html#grid-search"><span class="std std-ref">دليل
المستخدم</span></a>). بعض الأمثلة على مقدرات التحقق المتبادل
هي <a class="reference internal" href="modules/generated/sklearn.linear_model.ElasticNetCV.html#sklearn.linear_model.ElasticNetCV" title="sklearn.linear_model.ElasticNetCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElasticNetCV</span></code></a> و
<a class="reference internal" href="modules/generated/sklearn.linear_model.LogisticRegressionCV.html#sklearn.linear_model.LogisticRegressionCV" title="sklearn.linear_model.LogisticRegressionCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">LogisticRegressionCV</span></code></a>.
يتم تسمية مقدرات التحقق المتبادل باسم <code class="docutils literal notranslate"><span class="pre">EstimatorCV</span></code> وتميل إلى
أن تكون مكافئة تقريبًا لـ <code class="docutils literal notranslate"><span class="pre">GridSearchCV(Estimator()،</span> <span class="pre">...)</span></code>.
ميزة استخدام مقدر التحقق المتبادل على
فئة <span class="xref std std-term">المقدر</span> الأساسية جنبًا إلى جنب مع <a class="reference internal" href="modules/grid_search.html#grid-search"><span class="std std-ref">البحث الشبكي</span></a> هي
أنه يمكنهم الاستفادة من البدء الدافئ عن طريق إعادة استخدام النتائج المحسوبة
مسبقًا في الخطوات السابقة من عملية التحقق المتبادل. يؤدي هذا
عمومًا إلى تحسينات في السرعة. الاستثناء هو
فئة <a class="reference internal" href="modules/generated/sklearn.linear_model.RidgeCV.html#sklearn.linear_model.RidgeCV" title="sklearn.linear_model.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a>، والتي يمكنها بدلاً من ذلك
إجراء التحقق المتبادل Leave-One-Out (LOO) بكفاءة. افتراضيًا، سيتم إعادة
ملاءمة جميع هذه المقدرات، باستثناء <a class="reference internal" href="modules/generated/sklearn.linear_model.RidgeCV.html#sklearn.linear_model.RidgeCV" title="sklearn.linear_model.RidgeCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">RidgeCV</span></code></a>
مع LOO-CV، على مجموعة بيانات التدريب الكاملة بعد العثور على
أفضل مجموعة من المعلمات الفائقة.</p>
</dd>
<dt id="term-100">مسجِّل<a class="headerlink" href="#term-100" title="Link to this term">#</a></dt><dd><p>كائن قابل للاستدعاء غير مقدر يُقيِّم مقدرًا على بيانات اختبار معينة،
ويُعيد رقمًا. على عكس <a class="reference internal" href="#term-27"><span class="xref std std-term">مقاييس التقييم</span></a>،
يجب أن يتوافق الرقم المُعاد الأكبر مع درجة <em>أفضل</em>.
انظر <a class="reference internal" href="modules/model_evaluation.html#scoring-parameter"><span class="std std-ref">معلمة scoring: تعريف قواعد تقييم النموذج</span></a>.</p>
</dd>
</dl>
<p>أمثلة إضافية:</p>
<ul class="simple">
<li><p><a class="reference internal" href="modules/generated/sklearn.metrics.DistanceMetric.html#sklearn.metrics.DistanceMetric" title="sklearn.metrics.DistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">metrics.DistanceMetric</span></code></a></p></li>
<li><p><a class="reference internal" href="modules/generated/sklearn.gaussian_process.kernels.Kernel.html#sklearn.gaussian_process.kernels.Kernel" title="sklearn.gaussian_process.kernels.Kernel"><code class="xref py py-class docutils literal notranslate"><span class="pre">gaussian_process.kernels.Kernel</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tree.Criterion</span></code></p></li>
</ul>
</section>
<section id="glossary-metadata-routing">
<span id="id6"></span><h2>توجيه البيانات الوصفية<a class="headerlink" href="#glossary-metadata-routing" title="Link to this heading">#</a></h2>
<dl class="simple glossary">
<dt id="term-101">مستهلك<a class="headerlink" href="#term-101" title="Link to this term">#</a></dt><dd><p>كائن يستهلك <a class="reference internal" href="#term-102"><span class="xref std std-term">بيانات وصفية</span></a>. عادةً ما يكون هذا الكائن
<span class="xref std std-term">مقدرًا</span> أو <span class="xref std std-term">مسجِّلاً</span> أو <span class="xref std std-term">مُقسِّم CV</span>. استهلاك
البيانات الوصفية يعني استخدامها في العمليات الحسابية، على سبيل المثال استخدام
<a class="reference internal" href="#term-sample_weight"><span class="xref std std-term">sample_weight</span></a> لحساب نوع معين من الدرجات. كونك
مستهلكًا لا يعني أن الكائن يتلقى دائمًا بيانات وصفية معينة،
بل يعني أنه يمكنه استخدامها إذا تم توفيرها.</p>
</dd>
<dt id="term-102">بيانات وصفية<a class="headerlink" href="#term-102" title="Link to this term">#</a></dt><dd><p>البيانات المتعلقة ببيانات <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a> و <a class="reference internal" href="#term-y"><span class="xref std std-term">y</span></a> المعينة، ولكن
ليست جزءًا مباشرًا من البيانات، على سبيل المثال <a class="reference internal" href="#term-sample_weight"><span class="xref std std-term">sample_weight</span></a> أو
<a class="reference internal" href="#term-groups"><span class="xref std std-term">groups</span></a>، ويتم تمريرها إلى كائنات وأساليب مختلفة،
على سبيل المثال إلى <a class="reference internal" href="#term-100"><span class="xref std std-term">مسجِّل</span></a> أو <span class="xref std std-term">مُقسِّم CV</span>.</p>
</dd>
<dt id="term-103">موجه<a class="headerlink" href="#term-103" title="Link to this term">#</a></dt><dd><p>كائن يُوجِّه البيانات الوصفية إلى <span class="xref std std-term">المستهلكين</span>. عادةً ما يكون هذا
الكائن <span class="xref std std-term">مقدر تعريف تلوي</span>، على سبيل المثال
<a class="reference internal" href="modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code></a> أو <a class="reference internal" href="modules/generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridSearchCV</span></code></a>.
يمكن أن يكون بعض الموجهات أيضًا مستهلكًا. يحدث هذا على سبيل المثال عندما يستخدم
مقدر التعريف التلوي <a class="reference internal" href="#term-groups"><span class="xref std std-term">groups</span></a> المعينة، ويقوم أيضًا بتمريرها
إلى بعض الكائنات الفرعية الخاصة به، مثل <span class="xref std std-term">مُقسِّم CV</span>.</p>
</dd>
</dl>
<p>يرجى الرجوع إلى <a class="reference internal" href="metadata_routing.html#metadata-routing"><span class="std std-ref">دليل مستخدم توجيه البيانات الوصفية</span></a> لمزيد من
المعلومات.</p>
</section>
<section id="glossary-target-types">
<span id="id7"></span><h2>أنواع الأهداف<a class="headerlink" href="#glossary-target-types" title="Link to this heading">#</a></h2>
<dl class="glossary">
<dt id="term-104">ثنائي<a class="headerlink" href="#term-104" title="Link to this term">#</a></dt><dd><p>مشكلة تصنيف تتكون من فئتين. قد يتم تمثيل الهدف الثنائي
لمشكلة <span class="xref std std-term">متعددة الفئات</span> ولكن بتسميتين فقط. يتم تمثيل دالة القرار
الثنائية كمصفوفة أحادية الأبعاد.</p>
<p>دلاليًا، غالبًا ما تُعتبر إحدى الفئات الفئة &quot;الإيجابية&quot;.
ما لم يُحدد خلاف ذلك (على سبيل المثال، باستخدام <a class="reference internal" href="#term-pos_label"><span class="xref std std-term">pos_label</span></a> في
<a class="reference internal" href="#term-27"><span class="xref std std-term">مقاييس التقييم</span></a>)، فإننا نعتبر تسمية الفئة ذات القيمة
الأكبر (عدديًا أو معجميًا) على أنها الفئة الإيجابية:
من التسميات [0، 1]، 1 هي الفئة الإيجابية؛ من [1، 2]، 2 هي الفئة
الإيجابية؛ من [&quot;لا&quot;، &quot;نعم&quot;]، &quot;نعم&quot; هي الفئة الإيجابية؛ من [&quot;لا&quot;، &quot;نعم&quot;]،
&quot;لا&quot; هي الفئة الإيجابية. يؤثر هذا على ناتج
<a class="reference internal" href="#term-decision_function"><span class="xref std std-term">decision_function</span></a>، على سبيل المثال.</p>
<p>لاحظ أن مجموعة البيانات التي تم أخذ عينات منها من <code class="docutils literal notranslate"><span class="pre">y</span></code> متعدد الفئات أو
<code class="docutils literal notranslate"><span class="pre">y</span></code> مستمر قد تبدو ثنائية.</p>
<p>سيُعيد <a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_of_target</span></code></a> القيمة &quot;binary&quot; لـ
الإدخال الثنائي، أو مصفوفة مماثلة بفئة واحدة فقط موجودة.</p>
</dd>
<dt id="term-105">مستمر<a class="headerlink" href="#term-105" title="Link to this term">#</a></dt><dd><p>مشكلة انحدار حيث يكون هدف كل عينة هو رقم فاصلة عائمة محدود
مُمثل كمصفوفة أحادية الأبعاد من العناصر العائمة (أو
أحيانًا أعداد صحيحة).</p>
<p>سيُعيد <a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_of_target</span></code></a> القيمة &quot;continuous&quot; لـ
الإدخال المستمر، ولكن إذا كانت جميع البيانات أعدادًا صحيحة، فسيتم
تحديدها على أنها &quot;multiclass&quot;.</p>
</dd>
<dt id="term-106">متعدد المخرجات مستمر<a class="headerlink" href="#term-106" title="Link to this term">#</a></dt><dt id="term-107">مستمر متعدد المخرجات<a class="headerlink" href="#term-107" title="Link to this term">#</a></dt><dd><p>مشكلة انحدار حيث يتكون هدف كل عينة من <code class="docutils literal notranslate"><span class="pre">n_outputs</span></code>
<span class="xref std std-term">مخرجات</span>، كل منها رقم فاصلة عائمة محدود، لـ
عدد صحيح ثابت <code class="docutils literal notranslate"><span class="pre">n_outputs</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> في مجموعة بيانات معينة.</p>
<p>يتم تمثيل الأهداف المستمرة متعددة المخرجات كأهداف
<span class="xref std std-term">مستمرة</span> متعددة، مكدسة أفقيًا في مصفوفة
ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples،</span> <span class="pre">n_outputs)</span></code>.</p>
<p>سيُعيد <a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_of_target</span></code></a>
القيمة &quot;continuous-multioutput&quot; للإدخال المستمر متعدد المخرجات، ولكن إذا
كانت جميع البيانات أعدادًا صحيحة، فسيتم تحديدها على أنها
&quot;multiclass-multioutput&quot;.</p>
</dd>
<dt id="term-108">متعدد الفئات<a class="headerlink" href="#term-108" title="Link to this term">#</a></dt><dd><p>مشكلة تصنيف تتكون من أكثر من فئتين.
يمكن تمثيل الهدف متعدد الفئات كمصفوفة أحادية الأبعاد من
السلاسل أو الأعداد الصحيحة. متجه عمود ثنائي الأبعاد من الأعداد الصحيحة (أي
ناتج واحد من حيث <span class="xref std std-term">multioutput</span>) مقبول أيضًا.</p>
<p>لا ندعم رسميًا كائنات أخرى قابلة للترتيب وقابلة للتجزئة كتسميات فئات،
حتى لو كانت المقدرات قد تعمل عند إعطاء أهداف تصنيف
من هذا النوع.</p>
<p>بالنسبة للتصنيف شبه الخاضع للإشراف، يجب أن تحتوي العينات <span class="xref std std-term">غير المُعلَّمة</span>
على التسمية الخاصة -1 في <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<p>ضمن scikit-learn، تدعم جميع المقدرات التي تدعم التصنيف الثنائي
أيضًا التصنيف متعدد الفئات، باستخدام واحد مقابل البقية افتراضيًا.</p>
<p>يساعد <a class="reference internal" href="modules/generated/sklearn.preprocessing.LabelEncoder.html#sklearn.preprocessing.LabelEncoder" title="sklearn.preprocessing.LabelEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">preprocessing.LabelEncoder</span></code></a> على تحويل أهداف
متعددة الفئات إلى أعداد صحيحة.</p>
<p>سيُعيد <a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_of_target</span></code></a> القيمة &quot;multiclass&quot; لـ
الإدخال متعدد الفئات. قد يرغب المستخدم أيضًا في التعامل مع الإدخال &quot;الثنائي&quot;
بشكل مماثل لـ &quot;multiclass&quot;.</p>
</dd>
<dt id="term-109">متعدد الفئات ومتعدد المخرجات<a class="headerlink" href="#term-109" title="Link to this term">#</a></dt><dd><p>مشكلة تصنيف حيث يتكون هدف كل عينة من
<code class="docutils literal notranslate"><span class="pre">n_outputs</span></code> <span class="xref std std-term">مخرجات</span>، كل منها تسمية فئة، لعدد صحيح ثابت
<code class="docutils literal notranslate"><span class="pre">n_outputs</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> في مجموعة بيانات معينة.  لكل ناتج مجموعة ثابتة
من الفئات المتاحة، وكل عينة مُعلَّمة بفئة
لكل ناتج. قد يكون الناتج ثنائيًا أو متعدد الفئات، وفي
الحالة التي تكون فيها جميع المخرجات ثنائية، يكون الهدف
<a class="reference internal" href="#term-110"><span class="xref std std-term">متعدد التسميات</span></a>.</p>
<p>يتم تمثيل الأهداف متعددة الفئات ومتعددة المخرجات كأهداف
<span class="xref std std-term">متعددة الفئات</span> متعددة، مكدسة أفقيًا في مصفوفة
ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_outputs)</span></code>.</p>
<p>XXX: من أجل البساطة، قد لا ندعم دائمًا تسميات فئات السلاسل
للمخرجات متعددة الفئات ومتعددة المخرجات، ويجب استخدام تسميات فئات الأعداد الصحيحة.</p>
<p>يوفر <a class="reference internal" href="api/sklearn.multioutput.html#module-sklearn.multioutput" title="sklearn.multioutput"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multioutput</span></code></a> مقدرات تُقدِّر المشكلات متعددة المخرجات
باستخدام مقدرات متعددة أحادية الناتج. قد لا يُراعي هذا
تمامًا التبعيات بين المخرجات المختلفة، والتي قد تعمل الأساليب
التي تتعامل أصلاً مع الحالة متعددة المخرجات (على سبيل المثال، أشجار القرار،
أقرب الجيران، الشبكات العصبية) بشكل أفضل.</p>
<p>سيُعيد <a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_of_target</span></code></a>
القيمة &quot;multiclass-multioutput&quot; للإدخال متعدد الفئات ومتعدد المخرجات.</p>
</dd>
<dt id="term-110">متعدد التسميات<a class="headerlink" href="#term-110" title="Link to this term">#</a></dt><dd><p>هدف <a class="reference internal" href="#term-109"><span class="xref std std-term">متعدد الفئات ومتعدد المخرجات</span></a> حيث يكون كل ناتج
<span class="xref std std-term">ثنائيًا</span>. قد يتم تمثيل هذا كمصفوفة ثنائية الأبعاد (كثيفة) أو
مصفوفة متفرقة من الأعداد الصحيحة، بحيث يكون كل عمود هدفًا ثنائيًا منفصلاً،
حيث تتم الإشارة إلى التسميات الإيجابية بالرقم 1 وعادةً ما تكون التسميات السلبية
-1 أو 0. لا يتم دعم الأهداف المتفرقة متعددة التسميات
في كل مكان يتم فيه دعم الأهداف الكثيفة متعددة التسميات.</p>
<p>دلاليًا، يمكن اعتبار الهدف متعدد التسميات كمجموعة من التسميات
لكل عينة. على الرغم من عدم استخدامه داخليًا،
يتم توفير <a class="reference internal" href="modules/generated/sklearn.preprocessing.MultiLabelBinarizer.html#sklearn.preprocessing.MultiLabelBinarizer" title="sklearn.preprocessing.MultiLabelBinarizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">preprocessing.MultiLabelBinarizer</span></code></a> كأداة مساعدة لـ
التحويل من قائمة التمثيلات المحددة إلى مصفوفة ثنائية الأبعاد أو مصفوفة
متفرقة. يؤدي تشفير الهدف متعدد الفئات بشكل أحادي الاتجاه باستخدام
<a class="reference internal" href="modules/generated/sklearn.preprocessing.LabelBinarizer.html#sklearn.preprocessing.LabelBinarizer" title="sklearn.preprocessing.LabelBinarizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">preprocessing.LabelBinarizer</span></code></a> إلى تحويله إلى مشكلة متعددة
التسميات.</p>
<p>سيُعيد <a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">type_of_target</span></code></a>
القيمة &quot;multilabel-indicator&quot; للإدخال متعدد التسميات، سواء كان متفرقًا أو كثيفًا.</p>
</dd>
<dt id="term-111">متعدد المخرجات<a class="headerlink" href="#term-111" title="Link to this term">#</a></dt><dd><p>هدف حيث تحتوي كل عينة على تسميات تصنيف/انحدار
متعددة. انظر <span class="xref std std-term">multiclass multioutput</span> و <span class="xref std std-term">continuous
multioutput</span>. لا ندعم حاليًا نمذجة أهداف التصنيف والانحدار
المختلطة.</p>
</dd>
</dl>
</section>
<section id="glossary-methods">
<span id="id8"></span><h2>الأساليب<a class="headerlink" href="#glossary-methods" title="Link to this heading">#</a></h2>
<dl class="glossary">
<dt id="term-decision_function"><code class="docutils literal notranslate"><span class="pre">decision_function</span></code><a class="headerlink" href="#term-decision_function" title="Link to this term">#</a></dt><dd><p>في <a class="reference internal" href="#term-77"><span class="xref std std-term">مصنف</span></a> أو <span class="xref std std-term">كاشف قيم متطرفة</span> ملائم، يتنبأ
بدرجة &quot;ناعمة&quot; لكل عينة فيما يتعلق بكل فئة، بدلاً من
التنبؤ الفئوي &quot;الصعب&quot; الذي ينتجه <a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a>.  يكون إدخاله
عادةً مجرد بعض البيانات المرصودة، <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a>.</p>
<p>إذا لم يكن المقدر <span class="xref std std-term">ملائمًا</span> بالفعل، فيجب أن يطرح استدعاء هذا الأسلوب
<a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a>.</p>
<p>اتفاقيات الإخراج:</p>
<dl class="simple">
<dt>التصنيف الثنائي</dt><dd><p>مصفوفة أحادية الأبعاد، حيث تشير القيم الأكبر من الصفر
بشكل صارم إلى الفئة الإيجابية (أي الفئة الأخيرة في
<a class="reference internal" href="#term-classes_"><span class="xref std std-term">classes_</span></a>).</p>
</dd>
<dt>التصنيف متعدد الفئات</dt><dd><p>مصفوفة ثنائية الأبعاد، حيث يكون الحد الأقصى للوسيطة حسب الصف هو
الفئة المتوقعة. يتم ترتيب الأعمدة وفقًا لـ
<a class="reference internal" href="#term-classes_"><span class="xref std std-term">classes_</span></a>.</p>
</dd>
<dt>التصنيف متعدد التسميات</dt><dd><p>Scikit-learn غير متسق في تمثيل دوال القرار <span class="xref std std-term">متعددة التسميات</span>.
قد يتم تمثيلها بإحدى طريقتين:</p>
<ul class="simple">
<li><p>قائمة من المصفوفات ثنائية الأبعاد، كل مصفوفة ذات شكل: (<code class="docutils literal notranslate"><span class="pre">n_samples</span></code>، 2)، كما هو الحال في
الإخراج متعدد الفئات ومتعدد المخرجات. القائمة بطول <code class="docutils literal notranslate"><span class="pre">n_labels</span></code>.</p></li>
<li><p>مصفوفة ثنائية الأبعاد مفردة ذات شكل (<code class="docutils literal notranslate"><span class="pre">n_samples</span></code>، <code class="docutils literal notranslate"><span class="pre">n_labels</span></code>)، مع كل
&quot;عمود&quot; في المصفوفة يتوافق مع قرارات التصنيف الثنائي
الفردية. هذا مطابق لتنسيق
التصنيف متعدد الفئات، على الرغم من اختلاف دلالاته: يجب تفسيره، كما هو الحال في
الحالة الثنائية، عن طريق تحديد العتبة عند
0.</p></li>
</ul>
</dd>
<dt>تصنيف متعدد المخرجات</dt><dd><p>قائمة من المصفوفات ثنائية الأبعاد، تقابل كل دالة قرار متعددة
الفئات.</p>
</dd>
<dt>كشف القيم المتطرفة</dt><dd><p>مصفوفة أحادية الأبعاد، حيث تشير القيمة الأكبر من أو تساوي الصفر
إلى قيمة داخلية.</p>
</dd>
</dl>
</dd>
<dt id="term-fit"><code class="docutils literal notranslate"><span class="pre">fit</span></code><a class="headerlink" href="#term-fit" title="Link to this term">#</a></dt><dd><p>يتم توفير أسلوب <code class="docutils literal notranslate"><span class="pre">fit</span></code> في كل مقدر. عادةً ما يأخذ بعض
<span class="xref std std-term">العينات</span> <code class="docutils literal notranslate"><span class="pre">X</span></code>، <a class="reference internal" href="#term-70"><span class="xref std std-term">الأهداف</span></a> <code class="docutils literal notranslate"><span class="pre">y</span></code> إذا كان النموذج خاضعًا للإشراف،
وربما <span class="xref std std-term">خصائص عينة</span> أخرى مثل
<a class="reference internal" href="#term-sample_weight"><span class="xref std std-term">sample_weight</span></a>.  يجب أن يقوم بما يلي:</p>
<ul class="simple">
<li><p>مسح أي <span class="xref std std-term">سمات</span> سابقة مخزنة على المقدر، ما لم
يتم استخدام <a class="reference internal" href="#term-warm_start"><span class="xref std std-term">warm_start</span></a>؛</p></li>
<li><p>التحقق من صحة أي <span class="xref std std-term">معلمات</span> وتفسيرها، ويفضل طرح
خطأ إذا كانت غير صالحة؛</p></li>
<li><p>التحقق من صحة بيانات الإدخال؛</p></li>
<li><p>تقدير وتخزين سمات النموذج من المعلمات المقدرة و
البيانات المقدمة؛ و</p></li>
<li><p>إرجاع المقدر <span class="xref std std-term">الملائم</span> الآن لتسهيل تسلسل الأساليب.</p></li>
</ul>
<p>يصف <a class="reference internal" href="#glossary-target-types"><span class="std std-ref">أنواع الأهداف</span></a> التنسيقات الممكنة لـ <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
<dt id="term-fit_predict"><code class="docutils literal notranslate"><span class="pre">fit_predict</span></code><a class="headerlink" href="#term-fit_predict" title="Link to this term">#</a></dt><dd><p>يُستخدم خاصةً للمقدرات <span class="xref std std-term">غير الخاضعة للإشراف</span> و <span class="xref std std-term">الاستنتاجية</span>،
يُلائم هذا النموذج ويُعيد التنبؤات (على غرار
<a class="reference internal" href="#term-predict"><span class="xref std std-term">predict</span></a>) على بيانات التدريب. في المُجمِّعات، يتم أيضًا تخزين هذه التنبؤات
في سمة <a class="reference internal" href="#term-labels_"><span class="xref std std-term">labels_</span></a>، وعادةً ما يكون ناتج
<code class="docutils literal notranslate"><span class="pre">.fit_predict(X)</span></code> مكافئًا لـ <code class="docutils literal notranslate"><span class="pre">.fit(X).predict(X)</span></code>.
معلمات <code class="docutils literal notranslate"><span class="pre">fit_predict</span></code> هي نفس معلمات <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt id="term-fit_transform"><code class="docutils literal notranslate"><span class="pre">fit_transform</span></code><a class="headerlink" href="#term-fit_transform" title="Link to this term">#</a></dt><dd><p>أسلوب على <a class="reference internal" href="#term-95"><span class="xref std std-term">المحولات</span></a> الذي يُلائم المقدر ويُعيد
بيانات التدريب المُحوَّلة. يأخذ معلمات كما في <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>
ويجب أن يكون ناتجه بنفس شكل استدعاء <code class="docutils literal notranslate"><span class="pre">.fit(X،</span>
<span class="pre">...).transform(X)</span></code>. ومع ذلك، هناك حالات نادرة لا
يُعيد فيها <code class="docutils literal notranslate"><span class="pre">.fit_transform(X،</span> <span class="pre">...)</span></code> و <code class="docutils literal notranslate"><span class="pre">.fit(X،</span> <span class="pre">...).transform(X)</span></code> نفس القيمة،
حيث تحتاج بيانات التدريب إلى معالجة
بشكل مختلف (بسبب مزج النماذج في المجموعات المكدسة، على سبيل المثال؛
يجب توثيق هذه الحالات بوضوح).
قد يوفر المحولات <span class="xref std std-term">الاستنتاجية</span> أيضًا
<code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> ولكن ليس <a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a>.</p>
<p>أحد أسباب تنفيذ <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> هو أن إجراء <code class="docutils literal notranslate"><span class="pre">fit</span></code>
و <code class="docutils literal notranslate"><span class="pre">transform</span></code> بشكل منفصل سيكون أقل كفاءة من إجرائهما معًا.
يوفر <a class="reference internal" href="modules/generated/sklearn.base.TransformerMixin.html#sklearn.base.TransformerMixin" title="sklearn.base.TransformerMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.TransformerMixin</span></code></a> تنفيذًا افتراضيًا،
مما يوفر واجهة متسقة عبر المحولات حيث
<code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> متخصص أو غير متخصص.</p>
<p>في التعلم <span class="xref std std-term">الاستقرائي</span> - حيث يكون الهدف هو تعلم
نموذج معمم يمكن تطبيقه على بيانات جديدة - يجب على المستخدمين
الحرص على عدم تطبيق <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> على مجموعة بيانات بأكملها
(أي بيانات التدريب والاختبار معًا) قبل إجراء مزيد من النمذجة، حيث
يؤدي هذا إلى <a class="reference internal" href="#term-44"><span class="xref std std-term">تسرب البيانات</span></a>.</p>
</dd>
<dt id="term-get_feature_names_out"><code class="docutils literal notranslate"><span class="pre">get_feature_names_out</span></code><a class="headerlink" href="#term-get_feature_names_out" title="Link to this term">#</a></dt><dd><p>بشكل أساسي لـ <a class="reference internal" href="#term-85"><span class="xref std std-term">مستخرجات الميزات</span></a>، ولكن أيضًا يُستخدم لمحولات
أخرى لتوفير أسماء سلاسل لكل عمود في ناتج
أسلوب <a class="reference internal" href="#term-transform"><span class="xref std std-term">transform</span></a> الخاص بالمقدر.  يُخرج مصفوفة من
السلاسل وقد يأخذ مصفوفة تشبه السلاسل كمدخلات، تقابل
أسماء أعمدة الإدخال التي يمكن من خلالها
إنشاء أسماء أعمدة الإخراج. إذا لم يتم تمرير <code class="docutils literal notranslate"><span class="pre">input_features</span></code>، فسيتم
استخدام سمة <code class="docutils literal notranslate"><span class="pre">feature_names_in_</span></code>. إذا لم يتم تعريف
سمة <code class="docutils literal notranslate"><span class="pre">feature_names_in_</span></code>، فسيتم تسمية
أسماء الإدخال <code class="docutils literal notranslate"><span class="pre">[x0,</span> <span class="pre">x1,</span> <span class="pre">...,</span> <span class="pre">x(n_features_in_</span> <span class="pre">-</span> <span class="pre">1)]</span></code>.</p>
</dd>
<dt id="term-get_n_splits"><code class="docutils literal notranslate"><span class="pre">get_n_splits</span></code><a class="headerlink" href="#term-get_n_splits" title="Link to this term">#</a></dt><dd><p>على <span class="xref std std-term">مُقسِّم CV</span> (ليس مقدرًا)، يُعيد عدد
العناصر التي سيحصل عليها المرء إذا كرر من خلال القيمة المعادة
لـ <a class="reference internal" href="#term-split"><span class="xref std std-term">split</span></a> بالنظر إلى نفس المعلمات. يأخذ نفس معلمات
split.</p>
</dd>
<dt id="term-get_params"><code class="docutils literal notranslate"><span class="pre">get_params</span></code><a class="headerlink" href="#term-get_params" title="Link to this term">#</a></dt><dd><p>يحصل على جميع <a class="reference internal" href="#term-53"><span class="xref std std-term">المعلمات</span></a> وقيمها، والتي يمكن تعيينها باستخدام
<a class="reference internal" href="#term-set_params"><span class="xref std std-term">set_params</span></a>. يمكن استخدام معلمة <code class="docutils literal notranslate"><span class="pre">deep</span></code>، عند تعيينها على
False لإرجاع تلك المعلمات التي لا تتضمن <code class="docutils literal notranslate"><span class="pre">__</span></code> فقط، أي
ليس بسبب التوجيه غير المباشر عبر المقدرات المُضمنة.</p>
<p>تعتمد معظم المقدرات التعريف من <a class="reference internal" href="modules/generated/sklearn.base.BaseEstimator.html#sklearn.base.BaseEstimator" title="sklearn.base.BaseEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.BaseEstimator</span></code></a>،
الذي يعتمد ببساطة المعلمات المُحددة لـ <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.
<a class="reference internal" href="modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">pipeline.Pipeline</span></code></a>، من بين أمور أخرى، يُعيد تنفيذ <code class="docutils literal notranslate"><span class="pre">get_params</span></code>
للإعلان عن المقدرات المسماة في معلمات <code class="docutils literal notranslate"><span class="pre">steps</span></code> الخاصة به على
أنها معلمات في حد ذاتها.</p>
</dd>
<dt id="term-partial_fit"><code class="docutils literal notranslate"><span class="pre">partial_fit</span></code><a class="headerlink" href="#term-partial_fit" title="Link to this term">#</a></dt><dd><p>يُسهِّل ملاءمة المقدر بطريقة عبر الإنترنت. على عكس <code class="docutils literal notranslate"><span class="pre">fit</span></code>،
لا يؤدي استدعاء <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> بشكل متكرر إلى مسح النموذج، ولكن
يُحدِّثه بالبيانات المقدمة. قد يُطلق على جزء البيانات
المقدم إلى <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> اسم دفعة صغيرة.
يجب أن يكون كل دفعة صغيرة ذات شكل متسق، إلخ. في المقدرات
التكرارية، غالبًا ما يُجري <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> تكرارًا واحدًا فقط.</p>
<p>يمكن أيضًا استخدام <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> للتعلم <a class="reference internal" href="#term-49"><span class="xref std std-term">خارج النواة</span></a>،
على الرغم من أنه يقتصر عادةً على الحالة التي يمكن فيها إجراء التعلم
عبر الإنترنت، أي أن النموذج قابل للاستخدام بعد كل <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> ولا
توجد معالجة منفصلة مطلوبة لإنهاء النموذج.
يُقدِّم <a class="reference internal" href="modules/generated/sklearn.cluster.Birch.html#sklearn.cluster.Birch" title="sklearn.cluster.Birch"><code class="xref py py-class docutils literal notranslate"><span class="pre">cluster.Birch</span></code></a> الاصطلاح القائل بأن استدعاء
<code class="docutils literal notranslate"><span class="pre">partial_fit(X)</span></code> سينتج نموذجًا غير مُنتهٍ، ولكن
يمكن إنهاء النموذج عن طريق استدعاء <code class="docutils literal notranslate"><span class="pre">partial_fit()</span></code> أي بدون
تمرير دفعة صغيرة أخرى.</p>
<p>بشكل عام، لا ينبغي تعديل معلمات المقدر بين استدعاءات
<code class="docutils literal notranslate"><span class="pre">partial_fit</span></code>، على الرغم من أن <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> يجب أن يتحقق من صحتها
بالإضافة إلى الدفعة الصغيرة الجديدة من البيانات. على النقيض من ذلك،
يُستخدم <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> لملاءمة نفس المقدر بشكل متكرر بنفس البيانات
ولكن مع معلمات مختلفة.</p>
<p>مثل <code class="docutils literal notranslate"><span class="pre">fit</span></code>، يجب أن يُعيد <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> كائن المقدر.</p>
<p>لمسح النموذج، يجب إنشاء مقدر جديد، على سبيل المثال
باستخدام <a class="reference internal" href="modules/generated/sklearn.base.clone.html#sklearn.base.clone" title="sklearn.base.clone"><code class="xref py py-func docutils literal notranslate"><span class="pre">base.clone</span></code></a>.</p>
<p>ملاحظة: يؤدي استخدام <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code> بعد <code class="docutils literal notranslate"><span class="pre">fit</span></code> إلى سلوك غير مُحدد.</p>
</dd>
<dt id="term-predict"><code class="docutils literal notranslate"><span class="pre">predict</span></code><a class="headerlink" href="#term-predict" title="Link to this term">#</a></dt><dd><p>يُجري تنبؤًا لكل عينة، وعادةً ما يأخذ <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a> فقط كمدخلات
(ولكن انظر أسفل اتفاقيات ناتج مقدر الانحدار أدناه). في
<span class="xref std std-term">المصنف</span> أو <a class="reference internal" href="#term-92"><span class="xref std std-term">مقدر الانحدار</span></a>، يكون هذا التنبؤ في نفس
مساحة الهدف المستخدمة في الملاءمة (على سبيل المثال، أحد {&quot;أحمر&quot;، &quot;كهرماني&quot;، &quot;أخضر&quot;}
إذا كان <code class="docutils literal notranslate"><span class="pre">y</span></code> في الملاءمة يتكون من هذه السلاسل). على الرغم من ذلك، حتى
عندما يكون <code class="docutils literal notranslate"><span class="pre">y</span></code> الذي تم تمريره إلى <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a> عبارة عن قائمة أو مصفوفة أخرى تشبه المصفوفة،
يجب أن يكون ناتج <code class="docutils literal notranslate"><span class="pre">predict</span></code> دائمًا مصفوفة أو مصفوفة متفرقة. في
<a class="reference internal" href="#term-79"><span class="xref std std-term">مُجمِّع</span></a> أو <span class="xref std std-term">كاشف قيم متطرفة</span>، يكون التنبؤ
عددًا صحيحًا.</p>
<p>إذا لم يكن المقدر <span class="xref std std-term">ملائمًا</span> بالفعل، فيجب أن يطرح استدعاء هذا الأسلوب
<a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a>.</p>
<p>اتفاقيات الإخراج:</p>
<dl class="simple">
<dt>مصنف</dt><dd><p>مصفوفة ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples,)</span></code> <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_outputs)</span></code>.
قد يتم تمثيل بيانات <span class="xref std std-term">متعددة التسميات</span> كمصفوفة متفرقة
إذا تم استخدام مصفوفة متفرقة في الملاءمة. يجب أن يكون كل عنصر
أحد القيم في سمة <a class="reference internal" href="#term-classes_"><span class="xref std std-term">classes_</span></a> الخاصة بالمصنف.</p>
</dd>
<dt>مُجمِّع</dt><dd><p>مصفوفة ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples,)</span></code> حيث تكون كل قيمة من 0 إلى
<code class="docutils literal notranslate"><span class="pre">n_clusters</span> <span class="pre">-</span> <span class="pre">1</span></code> إذا تم تجميع العينة المقابلة،
و -1 إذا لم يتم تجميع العينة، كما هو الحال في
<a class="reference internal" href="modules/generated/dbscan-function.html#sklearn.cluster.dbscan" title="sklearn.cluster.dbscan"><code class="xref py py-func docutils literal notranslate"><span class="pre">cluster.dbscan</span></code></a>.</p>
</dd>
<dt>كاشف القيم المتطرفة</dt><dd><p>مصفوفة ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples,)</span></code> حيث تكون كل قيمة -1 للقيمة
المتطرفة و 1 خلاف ذلك.</p>
</dd>
<dt>مقدر الانحدار</dt><dd><p>مصفوفة رقمية ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples,)</span></code>، عادةً float64.
تحتوي بعض مقدرات الانحدار على خيارات إضافية في أسلوب <code class="docutils literal notranslate"><span class="pre">predict</span></code> الخاص بها،
مما يسمح لها بإرجاع الانحراف المعياري (<code class="docutils literal notranslate"><span class="pre">return_std</span> <span class="pre">=</span> <span class="pre">True</span></code>)
أو التباين المشترك (<code class="docutils literal notranslate"><span class="pre">return_cov</span> <span class="pre">=</span> <span class="pre">True</span></code>) بالنسبة إلى القيمة
المتوقعة. في هذه الحالة، تكون القيمة المعادة عبارة عن tuple من المصفوفات
المقابلة لـ (متوسط ​​التنبؤ، الانحراف المعياري، التباين المشترك) حسب الحاجة.</p>
</dd>
</dl>
</dd>
<dt id="term-predict_log_proba"><code class="docutils literal notranslate"><span class="pre">predict_log_proba</span></code><a class="headerlink" href="#term-predict_log_proba" title="Link to this term">#</a></dt><dd><p>اللوغاريتم الطبيعي لناتج <a class="reference internal" href="#term-predict_proba"><span class="xref std std-term">predict_proba</span></a>، المقدم
لتسهيل الاستقرار العددي.</p>
</dd>
<dt id="term-predict_proba"><code class="docutils literal notranslate"><span class="pre">predict_proba</span></code><a class="headerlink" href="#term-predict_proba" title="Link to this term">#</a></dt><dd><p>أسلوب في <a class="reference internal" href="#term-78"><span class="xref std std-term">المصنفات</span></a> و <a class="reference internal" href="#term-80"><span class="xref std std-term">المُجمِّعات</span></a> يمكنه
إرجاع تقديرات الاحتمالية لكل فئة/كتلة.  يكون إدخاله
عادةً مجرد بعض البيانات المرصودة، <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a>.</p>
<p>إذا لم يكن المقدر <span class="xref std std-term">ملائمًا</span> بالفعل، فيجب أن يطرح استدعاء هذا الأسلوب
<a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a>.</p>
<p>تشبه اتفاقيات الإخراج تلك الخاصة بـ <a class="reference internal" href="#term-decision_function"><span class="xref std std-term">decision_function</span></a> باستثناء
حالة التصنيف <span class="xref std std-term">الثنائي</span>، حيث يتم إخراج عمود واحد
لكل فئة (بينما يُخرج <code class="docutils literal notranslate"><span class="pre">decision_function</span></code> مصفوفة أحادية الأبعاد). بالنسبة
للتنبؤات الثنائية ومتعددة الفئات، يجب أن يضيف كل صف إلى 1.</p>
<p>مثل الأساليب الأخرى، يجب ألا يكون <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> موجودًا إلا عندما
يمكن للمقدر إجراء تنبؤات احتمالية (انظر <a class="reference internal" href="#term-21"><span class="xref std std-term">كتابة البطة</span></a>).
هذا يعني أن وجود الأسلوب قد يعتمد على معلمات
المقدر (على سبيل المثال، في <a class="reference internal" href="modules/generated/sklearn.linear_model.SGDClassifier.html#sklearn.linear_model.SGDClassifier" title="sklearn.linear_model.SGDClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">linear_model.SGDClassifier</span></code></a>) أو بيانات
التدريب (على سبيل المثال، في <a class="reference internal" href="modules/generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">model_selection.GridSearchCV</span></code></a>) وقد لا
يظهر إلا بعد الملاءمة.</p>
</dd>
<dt id="term-score"><code class="docutils literal notranslate"><span class="pre">score</span></code><a class="headerlink" href="#term-score" title="Link to this term">#</a></dt><dd><p>أسلوب على مقدر، عادةً <span class="xref std std-term">متنبئ</span>، يُقيِّم
تنبؤاته على مجموعة بيانات معينة، ويُعيد درجة
عددية واحدة. يجب أن تشير قيمة الإرجاع الأكبر إلى تنبؤات أفضل؛
يتم استخدام الدقة للمصنفات و R^2 لمقدرات الانحدار افتراضيًا.</p>
<p>إذا لم يكن المقدر <span class="xref std std-term">ملائمًا</span> بالفعل، فيجب أن يطرح استدعاء هذا الأسلوب
<a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a>.</p>
<p>تُنفذ بعض المقدرات دالة تسجيل مخصصة خاصة بالمقدر،
غالبًا احتمالية البيانات في ظل النموذج.</p>
</dd>
<dt id="term-score_samples"><code class="docutils literal notranslate"><span class="pre">score_samples</span></code><a class="headerlink" href="#term-score_samples" title="Link to this term">#</a></dt><dd><p>أسلوب يُعيد درجة لكل عينة معينة. التعريف الدقيق
لـ <em>الدرجة</em> يختلف من فئة إلى أخرى. في حالة
تقدير الكثافة، يمكن أن يكون نموذج كثافة السجل على البيانات، وفي
حالة اكتشاف القيم المتطرفة، يمكن أن يكون عكس عامل
القيم المتطرفة للبيانات.</p>
<p>إذا لم يكن المقدر <span class="xref std std-term">ملائمًا</span> بالفعل، فيجب أن يطرح استدعاء هذا الأسلوب
<a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a>.</p>
</dd>
<dt id="term-set_params"><code class="docutils literal notranslate"><span class="pre">set_params</span></code><a class="headerlink" href="#term-set_params" title="Link to this term">#</a></dt><dd><p>متاح في أي مقدر، يأخذ وسيطات ذات كلمات رئيسية تقابل
المفاتيح في <a class="reference internal" href="#term-get_params"><span class="xref std std-term">get_params</span></a>. يتم توفير قيمة جديدة لكل منها
لتعيينها بحيث يعكس استدعاء <code class="docutils literal notranslate"><span class="pre">get_params</span></code> بعد <code class="docutils literal notranslate"><span class="pre">set_params</span></code>
<a class="reference internal" href="#term-53"><span class="xref std std-term">المعلمات</span></a> التي تم تغييرها. تستخدم معظم المقدرات التنفيذ في
<a class="reference internal" href="modules/generated/sklearn.base.BaseEstimator.html#sklearn.base.BaseEstimator" title="sklearn.base.BaseEstimator"><code class="xref py py-class docutils literal notranslate"><span class="pre">base.BaseEstimator</span></code></a>، الذي يتعامل مع المعلمات المتداخلة و
يُعيِّن المعلمة كسمة على المقدر.
يتم تجاوز الأسلوب في <a class="reference internal" href="modules/generated/sklearn.pipeline.Pipeline.html#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code class="xref py py-class docutils literal notranslate"><span class="pre">pipeline.Pipeline</span></code></a> والمقدرات ذات الصلة.</p>
</dd>
<dt id="term-split"><code class="docutils literal notranslate"><span class="pre">split</span></code><a class="headerlink" href="#term-split" title="Link to this term">#</a></dt><dd><p>على <span class="xref std std-term">مُقسِّم CV</span> (ليس مقدرًا)، يقبل هذا الأسلوب
معلمات (<a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a>، <a class="reference internal" href="#term-y"><span class="xref std std-term">y</span></a>، <a class="reference internal" href="#term-groups"><span class="xref std std-term">groups</span></a>)، حيث قد تكون جميعها
اختيارية، ويُعيد مُكرِّرًا على أزواج <code class="docutils literal notranslate"><span class="pre">(train_idx,</span> <span class="pre">test_idx)</span></code>.
كل من {train,test}_idx عبارة عن مصفوفة أعداد صحيحة أحادية الأبعاد، بقيم
من 0 من <code class="docutils literal notranslate"><span class="pre">X.shape[0]</span> <span class="pre">-</span> <span class="pre">1</span></code> بأي طول، بحيث لا تظهر أي قيم
في كل من <code class="docutils literal notranslate"><span class="pre">train_idx</span></code> و <code class="docutils literal notranslate"><span class="pre">test_idx</span></code> المقابل لها.</p>
</dd>
<dt id="term-transform"><code class="docutils literal notranslate"><span class="pre">transform</span></code><a class="headerlink" href="#term-transform" title="Link to this term">#</a></dt><dd><p>في <span class="xref std std-term">محول</span>، يُحوِّل الإدخال، عادةً <a class="reference internal" href="#term-X"><span class="xref std std-term">X</span></a> فقط،
إلى مساحة مُحوَّلة (يتم تدوينها تقليديًا على أنها <a class="reference internal" href="#term-Xt"><span class="xref std std-term">Xt</span></a>).
يكون الناتج عبارة عن مصفوفة أو مصفوفة متفرقة بطول <a class="reference internal" href="#term-n_samples"><span class="xref std std-term">n_samples</span></a> و
مع عدد ثابت من الأعمدة بعد <a class="reference internal" href="#term-32"><span class="xref std std-term">الملاءمة</span></a>.</p>
<p>إذا لم يكن المقدر <span class="xref std std-term">ملائمًا</span> بالفعل، فيجب أن يطرح استدعاء هذا الأسلوب
<a class="reference internal" href="modules/generated/sklearn.exceptions.NotFittedError.html#sklearn.exceptions.NotFittedError" title="sklearn.exceptions.NotFittedError"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.NotFittedError</span></code></a>.</p>
</dd>
</dl>
</section>
<section id="glossary-parameters">
<span id="id9"></span><h2>المعلمات<a class="headerlink" href="#glossary-parameters" title="Link to this heading">#</a></h2>
<p>تظهر أسماء المعلمات الشائعة هذه، المستخدمة على وجه التحديد في إنشاء المقدر
(انظر المفهوم <a class="reference external" href="https://docs.python.org/3/glossary.html#term-parameter" title="(in Python v3.13)"><span class="xref std std-term">parameter</span></a>)، أحيانًا كمعلمات
للدوال أو منشئي غير مقدر.</p>
<dl class="glossary">
<dt id="term-class_weight"><code class="docutils literal notranslate"><span class="pre">class_weight</span></code><a class="headerlink" href="#term-class_weight" title="Link to this term">#</a></dt><dd><p>يُستخدم لتحديد أوزان العينة عند ملاءمة المصنفات كدالة
لفئة <a class="reference internal" href="#term-69"><span class="xref std std-term">الهدف</span></a>. حيث يتم أيضًا
دعم <a class="reference internal" href="#term-sample_weight"><span class="xref std std-term">sample_weight</span></a> وتقديمه، يتم ضربه في مساهمة <code class="docutils literal notranslate"><span class="pre">class_weight</span></code>.
وبالمثل، حيث يتم استخدام <code class="docutils literal notranslate"><span class="pre">class_weight</span></code> في مهام
<span class="xref std std-term">متعددة المخرجات</span> (بما في ذلك <span class="xref std std-term">متعددة التسميات</span>)، يتم ضرب الأوزان
عبر المخرجات (أي أعمدة <code class="docutils literal notranslate"><span class="pre">y</span></code>).</p>
<p>افتراضيًا، يكون لجميع العينات وزن متساوٍ بحيث يتم
ترجيح الفئات بشكل فعال من خلال انتشارها في بيانات التدريب.
يمكن تحقيق ذلك صراحةً باستخدام <code class="docutils literal notranslate"><span class="pre">class_weight={label1:</span> <span class="pre">1,</span>
<span class="pre">label2:</span> <span class="pre">1,</span> <span class="pre">...}</span></code> لجميع تسميات الفئات.</p>
<p>بشكل أكثر عمومية، يتم تحديد <code class="docutils literal notranslate"><span class="pre">class_weight</span></code> كقاموس يقوم بتعيين تسميات الفئات
إلى الأوزان (<code class="docutils literal notranslate"><span class="pre">{class_label:</span> <span class="pre">weight}</span></code>)، بحيث يتم إعطاء كل عينة
من الفئة المسماة هذا الوزن.</p>
<p>يمكن استخدام <code class="docutils literal notranslate"><span class="pre">class_weight=&quot;balanced&quot;</span></code> لإعطاء جميع الفئات
وزنًا متساويًا عن طريق إعطاء كل عينة وزنًا يتناسب عكسيًا
مع انتشار فئتها في بيانات التدريب:
<code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">/</span> <span class="pre">(n_classes</span> <span class="pre">*</span> <span class="pre">np.bincount(y))</span></code>. سيتم استخدام أوزان الفئات
بشكل مختلف اعتمادًا على الخوارزمية: بالنسبة للنماذج الخطية (مثل
SVM الخطي أو الانحدار اللوجستي)، ستُغير أوزان الفئات دالة
الفقدان عن طريق ترجيح فقدان كل عينة بوزن فئتها.
بالنسبة للخوارزميات المستندة إلى الشجرة، سيتم استخدام أوزان الفئات من أجل
إعادة ترجيح معيار التقسيم.
<strong>لاحظ</strong> مع ذلك أن إعادة التوازن هذه لا تأخذ وزن
العينات في كل فئة في الاعتبار.</p>
<p>بالنسبة للتصنيف متعدد المخرجات، يتم استخدام قائمة من القواميس لتحديد
الأوزان لكل ناتج. على سبيل المثال، بالنسبة لأوزان التصنيف متعدد التسميات
ذات الأربع فئات، يجب أن تكون <code class="docutils literal notranslate"><span class="pre">[{0:</span> <span class="pre">1,</span> <span class="pre">1:</span> <span class="pre">1},</span> <span class="pre">{0:</span> <span class="pre">1,</span> <span class="pre">1:</span> <span class="pre">5},</span> <span class="pre">{0:</span> <span class="pre">1,</span>
<span class="pre">1:</span> <span class="pre">1},</span> <span class="pre">{0:</span> <span class="pre">1,</span> <span class="pre">1:</span> <span class="pre">1}]</span></code> بدلاً من <code class="docutils literal notranslate"><span class="pre">[{1:1},</span> <span class="pre">{2:5},</span> <span class="pre">{3:1},</span> <span class="pre">{4:1}]</span></code>.</p>
<p>يتم التحقق من صحة معلمة <code class="docutils literal notranslate"><span class="pre">class_weight</span></code> وتفسيرها باستخدام
<a class="reference internal" href="modules/generated/sklearn.utils.class_weight.compute_class_weight.html#sklearn.utils.class_weight.compute_class_weight" title="sklearn.utils.class_weight.compute_class_weight"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.class_weight.compute_class_weight</span></code></a>.</p>
</dd>
<dt id="term-cv"><code class="docutils literal notranslate"><span class="pre">cv</span></code><a class="headerlink" href="#term-cv" title="Link to this term">#</a></dt><dd><p>يُحدد استراتيجية تقسيم التحقق المتبادل، كما هو مستخدم في
الإجراءات القائمة على التحقق المتبادل. <code class="docutils literal notranslate"><span class="pre">cv</span></code> متاح أيضًا في المقدرات
مثل <a class="reference internal" href="modules/generated/sklearn.multioutput.ClassifierChain.html#sklearn.multioutput.ClassifierChain" title="sklearn.multioutput.ClassifierChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">multioutput.ClassifierChain</span></code></a> أو
<a class="reference internal" href="modules/generated/sklearn.calibration.CalibratedClassifierCV.html#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">calibration.CalibratedClassifierCV</span></code></a> التي تستخدم تنبؤات
مقدر واحد كبيانات تدريب لمقدر آخر، لعدم الإفراط في ملاءمة
إشراف التدريب.</p>
<p>عادةً ما تكون المدخلات الممكنة لـ <code class="docutils literal notranslate"><span class="pre">cv</span></code> هي:</p>
<ul class="simple">
<li><p>عدد صحيح، يُحدد عدد الطيات في التحقق المتبادل K-fold.
سيتم تصنيف K-fold على الفئات إذا كان المقدر
مصنفًا (مُحدد بواسطة <a class="reference internal" href="modules/generated/sklearn.base.is_classifier.html#sklearn.base.is_classifier" title="sklearn.base.is_classifier"><code class="xref py py-func docutils literal notranslate"><span class="pre">base.is_classifier</span></code></a>) وقد تُمثل
<a class="reference internal" href="#term-70"><span class="xref std std-term">الأهداف</span></a> مشكلة تصنيف ثنائية أو متعددة الفئات (ولكن ليس
متعددة المخرجات) (مُحددة بواسطة
<a class="reference internal" href="modules/generated/sklearn.utils.multiclass.type_of_target.html#sklearn.utils.multiclass.type_of_target" title="sklearn.utils.multiclass.type_of_target"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.multiclass.type_of_target</span></code></a>).</p></li>
<li><p>نموذج <span class="xref std std-term">مقسِّم التحقق المتبادل</span>. ارجع إلى
<a class="reference internal" href="modules/cross_validation.html#cross-validation"><span class="std std-ref">دليل المستخدم</span></a> للبحث عن المقسمات المتاحة
ضمن Scikit-learn.</p></li>
<li><p>مُكرِّر ينتج عنه تقسيمات تدريب/اختبار.</p></li>
</ul>
<p>مع بعض الاستثناءات (خاصةً عندما لا يكون عدم استخدام التحقق المتبادل على
الإطلاق خيارًا)، يكون الإعداد الافتراضي هو 5 أضعاف.</p>
<p>يتم التحقق من صحة قيم <code class="docutils literal notranslate"><span class="pre">cv</span></code> وتفسيرها باستخدام
<a class="reference internal" href="modules/generated/sklearn.model_selection.check_cv.html#sklearn.model_selection.check_cv" title="sklearn.model_selection.check_cv"><code class="xref py py-func docutils literal notranslate"><span class="pre">model_selection.check_cv</span></code></a>.</p>
</dd>
<dt id="term-kernel"><code class="docutils literal notranslate"><span class="pre">kernel</span></code><a class="headerlink" href="#term-kernel" title="Link to this term">#</a></dt><dd><p>يُحدد دالة النواة التي سيتم استخدامها بواسطة خوارزميات أسلوب النواة.
على سبيل المثال، المقدرات <a class="reference internal" href="modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC" title="sklearn.svm.SVC"><code class="xref py py-class docutils literal notranslate"><span class="pre">svm.SVC</span></code></a> و
<a class="reference internal" href="modules/generated/sklearn.gaussian_process.GaussianProcessClassifier.html#sklearn.gaussian_process.GaussianProcessClassifier" title="sklearn.gaussian_process.GaussianProcessClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">gaussian_process.GaussianProcessClassifier</span></code></a> كلاهما يحتوي على
معلمة <code class="docutils literal notranslate"><span class="pre">kernel</span></code> تأخذ اسم النواة المراد استخدامها كسلسلة
أو دالة نواة قابلة للاستدعاء تُستخدم لحساب مصفوفة النواة. لمزيد من
المرجع، انظر <a class="reference internal" href="modules/kernel_approximation.html#kernel-approximation"><span class="std std-ref">Kernel Approximation</span></a> و
<a class="reference internal" href="modules/gaussian_process.html#gaussian-process"><span class="std std-ref">العمليات الغاوسية</span></a> أدلة المستخدم.</p>
</dd>
<dt id="term-max_iter"><code class="docutils literal notranslate"><span class="pre">max_iter</span></code><a class="headerlink" href="#term-max_iter" title="Link to this term">#</a></dt><dd><p>بالنسبة للمقدرات التي تتضمن تحسينًا تكراريًا، يُحدد هذا الحد الأقصى لعدد
التكرارات التي سيتم إجراؤها في <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>.  إذا
تم تشغيل تكرارات <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> دون تقارب،
فيجب طرح <a class="reference internal" href="modules/generated/sklearn.exceptions.ConvergenceWarning.html#sklearn.exceptions.ConvergenceWarning" title="sklearn.exceptions.ConvergenceWarning"><code class="xref py py-class docutils literal notranslate"><span class="pre">exceptions.ConvergenceWarning</span></code></a>. لاحظ أن
تفسير &quot;تكرار واحد&quot; غير متسق عبر
المقدرات: يستخدمه البعض، ولكن ليس الكل، للإشارة إلى حقبة واحدة (أي
تمريرة على كل عينة في البيانات).</p>
<p>FIXME ربما يجب أن يكون لدينا بعض الاختبارات الشائعة حول العلاقة
بين ConvergenceWarning و max_iter.</p>
</dd>
<dt id="term-memory"><code class="docutils literal notranslate"><span class="pre">memory</span></code><a class="headerlink" href="#term-memory" title="Link to this term">#</a></dt><dd><p>تستخدم بعض المقدرات <a class="reference external" href="https://joblib.readthedocs.io/en/latest/generated/joblib.Memory.html#joblib.Memory" title="(in joblib v1.5.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">joblib.Memory</span></code></a> لـ
تخزين الحلول الجزئية أثناء الملاءمة. وبالتالي، عند استدعاء <code class="docutils literal notranslate"><span class="pre">fit</span></code>
مرة أخرى، يتم حفظ هذه الحلول الجزئية في الذاكرة ويمكن إعادة استخدامها.</p>
<p>يمكن تحديد معلمة <code class="docutils literal notranslate"><span class="pre">memory</span></code> كسلسلة مع مسار إلى
دليل، أو يمكن استخدام نموذج <a class="reference external" href="https://joblib.readthedocs.io/en/latest/generated/joblib.Memory.html#joblib.Memory" title="(in joblib v1.5.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">joblib.Memory</span></code></a> (أو كائن بواجهة
مماثلة، أي أسلوب <code class="docutils literal notranslate"><span class="pre">cache</span></code>).</p>
<p>يتم التحقق من صحة قيم <code class="docutils literal notranslate"><span class="pre">memory</span></code> وتفسيرها باستخدام
<a class="reference internal" href="modules/generated/sklearn.utils.validation.check_memory.html#sklearn.utils.validation.check_memory" title="sklearn.utils.validation.check_memory"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.validation.check_memory</span></code></a>.</p>
</dd>
<dt id="term-metric"><code class="docutils literal notranslate"><span class="pre">metric</span></code><a class="headerlink" href="#term-metric" title="Link to this term">#</a></dt><dd><p>كمعلمة، هذا هو المخطط لتحديد المسافة بين
نقطتي بيانات.  انظر <a class="reference internal" href="modules/generated/sklearn.metrics.pairwise_distances.html#sklearn.metrics.pairwise_distances" title="sklearn.metrics.pairwise_distances"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.pairwise_distances</span></code></a>.  من الناحية العملية،
بالنسبة لبعض الخوارزميات، قد يتم استخدام مقياس مسافة غير صحيح (مقياس لا
يطيع متباينة المثلث، مثل مسافة جيب التمام).</p>
<p>XXX: يستخدم التجميع الهرمي <code class="docutils literal notranslate"><span class="pre">affinity</span></code> بهذا المعنى.</p>
<p>نستخدم أيضًا <em>metric</em> للإشارة إلى <a class="reference internal" href="#term-27"><span class="xref std std-term">مقاييس التقييم</span></a>، لكننا نتجنب
استخدام هذا المعنى كاسم معلمة.</p>
</dd>
<dt id="term-n_components"><code class="docutils literal notranslate"><span class="pre">n_components</span></code><a class="headerlink" href="#term-n_components" title="Link to this term">#</a></dt><dd><p>عدد الميزات التي يجب أن يُحوِّل <a class="reference internal" href="#term-94"><span class="xref std std-term">المحول</span></a>
الإدخال إليها. انظر <a class="reference internal" href="#term-components_"><span class="xref std std-term">components_</span></a> للحالة الخاصة للإسقاط
التآلفي.</p>
</dd>
<dt id="term-n_iter_no_change"><code class="docutils literal notranslate"><span class="pre">n_iter_no_change</span></code><a class="headerlink" href="#term-n_iter_no_change" title="Link to this term">#</a></dt><dd><p>عدد التكرارات التي لا يوجد فيها تحسين للانتظار قبل إيقاف الإجراء
التكراري. يُعرف هذا أيضًا باسم معلمة <em>الصبر</em>.
عادةً ما يتم استخدامه مع <a class="reference internal" href="#term-22"><span class="xref std std-term">الإيقاف المبكر</span></a> لتجنب الإيقاف مبكرًا جدًا.</p>
</dd>
<dt id="term-n_jobs"><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code><a class="headerlink" href="#term-n_jobs" title="Link to this term">#</a></dt><dd><p>تُستخدم هذه المعلمة لتحديد عدد العمليات أو
المواضيع المتزامنة التي يجب استخدامها للإجراءات المتوازية مع
<a class="reference internal" href="#term-joblib"><span class="xref std std-term">joblib</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> هو عدد صحيح، يُحدد الحد الأقصى لعدد العمال
قيد التشغيل بشكل متزامن. إذا تم إعطاء 1، فلن يتم استخدام توازي joblib على الإطلاق،
وهو أمر مفيد لتصحيح الأخطاء. إذا تم تعيينها على -1، فسيتم استخدام جميع وحدات المعالجة المركزية.
بالنسبة لـ <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> أقل من -1، يتم استخدام (n_cpus + 1 + n_jobs). على سبيل المثال،
مع <code class="docutils literal notranslate"><span class="pre">n_jobs</span> <span class="pre">=</span> <span class="pre">-2</span></code>، يتم استخدام جميع وحدات المعالجة المركزية باستثناء واحدة.</p>
<p><code class="docutils literal notranslate"><span class="pre">n_jobs</span></code> هي <code class="docutils literal notranslate"><span class="pre">None</span></code> افتراضيًا، مما يعني <em>غير معينة</em>؛ سيتم
تفسيرها عمومًا على أنها <code class="docutils literal notranslate"><span class="pre">n_jobs=1</span></code>، ما لم يُحدد خلاف ذلك في سياق
الخلفية الحالي <a class="reference external" href="https://joblib.readthedocs.io/en/latest/generated/joblib.Parallel.html#joblib.Parallel" title="(in joblib v1.5.dev0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">joblib.Parallel</span></code></a>.</p>
<p>لاحظ أنه حتى لو كانت <code class="docutils literal notranslate"><span class="pre">n_jobs</span> <span class="pre">=</span> <span class="pre">1</span></code>، فقد يتم استخدام التوازي منخفض المستوى (عبر Numpy و OpenMP)
في بعض التكوينات.</p>
<p>لمزيد من التفاصيل حول استخدام <code class="docutils literal notranslate"><span class="pre">joblib</span></code> وتفاعلاتها مع
scikit-learn، يرجى الرجوع إلى <a class="reference internal" href="computing/parallelism.html#parallelism"><span class="std std-ref">ملاحظات التوازي
الخاصة بنا</span></a>.</p>
</dd>
<dt id="term-pos_label"><code class="docutils literal notranslate"><span class="pre">pos_label</span></code><a class="headerlink" href="#term-pos_label" title="Link to this term">#</a></dt><dd><p>القيمة التي يجب أن تُرمَّز بها التسميات الإيجابية في مشكلات
التصنيف الثنائي التي لا يُفترض فيها الفئة الإيجابية.
تكون هذه القيمة مطلوبة عادةً لحساب مقاييس التقييم غير المتماثلة مثل
الدقة والاستدعاء.</p>
</dd>
<dt id="term-random_state"><code class="docutils literal notranslate"><span class="pre">random_state</span></code><a class="headerlink" href="#term-random_state" title="Link to this term">#</a></dt><dd><p>كلما كانت العشوائية جزءًا من خوارزمية Scikit-learn،
يمكن توفير معلمة <code class="docutils literal notranslate"><span class="pre">random_state</span></code> للتحكم في مُولِّد الأرقام العشوائية
المستخدم. لاحظ أن مجرد وجود <code class="docutils literal notranslate"><span class="pre">random_state</span></code> لا
يعني أن العشوائية تُستخدم دائمًا، حيث قد تعتمد على
معلمة أخرى، على سبيل المثال <code class="docutils literal notranslate"><span class="pre">shuffle</span></code>، يتم تعيينها.</p>
<p>ستؤثر القيمة التي تم تمريرها على إمكانية تكرار
النتائج التي تُعيدها الدالة (<a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>، <a class="reference internal" href="#term-split"><span class="xref std std-term">split</span></a>، أو أي
دالة أخرى مثل <a class="reference internal" href="modules/generated/sklearn.cluster.k_means.html#sklearn.cluster.k_means" title="sklearn.cluster.k_means"><code class="xref py py-func docutils literal notranslate"><span class="pre">k_means</span></code></a>). قد تكون قيمة <code class="docutils literal notranslate"><span class="pre">random_state</span></code>:</p>
<dl class="simple">
<dt>لا شيء (افتراضي)</dt><dd><p>استخدم نموذج الحالة العشوائية العالمية من <a class="reference external" href="https://numpy.org/doc/stable/reference/random/index.html#module-numpy.random" title="(in NumPy v2.1)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy.random</span></code></a>.
سيؤدي استدعاء الدالة عدة مرات إلى إعادة استخدام
نفس النموذج، وسينتج عنه نتائج مختلفة.</p>
</dd>
<dt>عدد صحيح</dt><dd><p>استخدم مُولِّد أرقام عشوائية جديد تم إنشاؤه بواسطة العدد الصحيح المحدد.
سيؤدي استخدام عدد صحيح إلى إنتاج نفس النتائج عبر استدعاءات مختلفة. ومع ذلك، قد يكون
من المفيد التحقق من استقرار نتائجك عبر
عدد من بذور عشوائية مميزة مختلفة. بذور عشوائية أعداد صحيحة
شائعة هي 0 و <a class="reference external" href="https://en.wikipedia.org/wiki/Answer_to_the_Ultimate_Question_of_Life%2C_the_Universe%2C_and_Everything">42</a>.
يجب أن تكون القيم الصحيحة في النطاق <code class="docutils literal notranslate"><span class="pre">[0،</span> <span class="pre">2**32</span> <span class="pre">-</span> <span class="pre">1]</span></code>.</p>
</dd>
<dt>نموذج <a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.random.RandomState</span></code></a></dt><dd><p>استخدم الحالة العشوائية المقدمة، مما يؤثر فقط على المستخدمين الآخرين
لنفس نموذج الحالة العشوائية. سيؤدي استدعاء الدالة
عدة مرات إلى إعادة استخدام نفس النموذج، و
سينتج عنه نتائج مختلفة.</p>
</dd>
</dl>
<p>يتم استخدام <a class="reference internal" href="modules/generated/sklearn.utils.check_random_state.html#sklearn.utils.check_random_state" title="sklearn.utils.check_random_state"><code class="xref py py-func docutils literal notranslate"><span class="pre">utils.check_random_state</span></code></a> داخليًا للتحقق من صحة
<code class="docutils literal notranslate"><span class="pre">random_state</span></code> المدخلة وإرجاع نموذج <a class="reference external" href="https://numpy.org/doc/stable/reference/random/legacy.html#numpy.random.RandomState" title="(in NumPy v2.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomState</span></code></a>.</p>
<p>لمزيد من التفاصيل حول كيفية التحكم في عشوائية كائنات scikit-learn
وتجنب الأخطاء الشائعة، يمكنك الرجوع إلى <a class="reference internal" href="common_pitfalls.html#randomness"><span class="std std-ref">التحكم في العشوائية</span></a>.</p>
</dd>
<dt id="term-scoring"><code class="docutils literal notranslate"><span class="pre">scoring</span></code><a class="headerlink" href="#term-scoring" title="Link to this term">#</a></dt><dd><p>يُحدد دالة الدرجة التي سيتم تكبيرها (عادةً عن طريق <a class="reference internal" href="modules/cross_validation.html#cross-validation"><span class="std std-ref">التحقق
المتبادل</span></a>)، أو - في بعض الحالات - دوال تسجيل متعددة
ليتم الإبلاغ عنها. يمكن أن تكون دالة الدرجة سلسلة يقبلها
<a class="reference internal" href="modules/generated/sklearn.metrics.get_scorer.html#sklearn.metrics.get_scorer" title="sklearn.metrics.get_scorer"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.get_scorer</span></code></a> أو <a class="reference internal" href="#term-100"><span class="xref std std-term">مسجِّل</span></a> قابل للاستدعاء، لا ينبغي
الخلط بينه وبين <a class="reference internal" href="#term-26"><span class="xref std std-term">مقياس التقييم</span></a>، لأن الأخير لديه واجهة برمجة تطبيقات أكثر
تنوعًا. قد يتم أيضًا تعيين <code class="docutils literal notranslate"><span class="pre">scoring</span></code> على لا شيء، وفي هذه الحالة
يتم استخدام أسلوب <a class="reference internal" href="#term-score"><span class="xref std std-term">score</span></a> الخاص بالمقدر.  انظر <a class="reference internal" href="modules/model_evaluation.html#scoring-parameter"><span class="std std-ref">معلمة scoring: تعريف قواعد تقييم النموذج</span></a>
في دليل المستخدم.</p>
<p>حيث يمكن تقييم مقاييس متعددة، قد يتم إعطاء <code class="docutils literal notranslate"><span class="pre">scoring</span></code>
إما كقائمة من السلاسل الفريدة، أو قاموس بأسماء كمفاتيح وقيم
قابلة للاستدعاء أو قيمة قابلة للاستدعاء تُعيد قاموسًا. لاحظ أن
هذا <em>لا</em> يُحدد دالة الدرجة التي سيتم تكبيرها، و
قد يتم استخدام معلمة أخرى مثل <code class="docutils literal notranslate"><span class="pre">refit</span></code> لهذا الغرض.</p>
<p>يتم التحقق من صحة معلمة <code class="docutils literal notranslate"><span class="pre">scoring</span></code> وتفسيرها باستخدام
<a class="reference internal" href="modules/generated/sklearn.metrics.check_scoring.html#sklearn.metrics.check_scoring" title="sklearn.metrics.check_scoring"><code class="xref py py-func docutils literal notranslate"><span class="pre">metrics.check_scoring</span></code></a>.</p>
</dd>
<dt id="term-verbose"><code class="docutils literal notranslate"><span class="pre">verbose</span></code><a class="headerlink" href="#term-verbose" title="Link to this term">#</a></dt><dd><p>لا تتم معالجة التسجيل بشكل متسق للغاية في Scikit-learn في الوقت الحالي،
ولكن عندما يتم توفيره كخيار، عادةً ما تتوفر معلمة <code class="docutils literal notranslate"><span class="pre">verbose</span></code> لاختيار عدم
التسجيل (تعيين على False). يجب أن تُمكِّن أي قيمة True
بعض التسجيل، ولكن قد تكون هناك حاجة إلى أعداد صحيحة أكبر (على سبيل المثال، أعلى من 10)
للحصول على إطناب كامل. عادةً ما تتم طباعة سجلات مطولة إلى
الإخراج القياسي.
يجب ألا تُنتج المقدرات أي ناتج على الإخراج القياسي مع
إعداد <code class="docutils literal notranslate"><span class="pre">verbose</span></code> الافتراضي.</p>
</dd>
<dt id="term-warm_start"><code class="docutils literal notranslate"><span class="pre">warm_start</span></code><a class="headerlink" href="#term-warm_start" title="Link to this term">#</a></dt><dd><p>عند ملاءمة مقدر بشكل متكرر على نفس مجموعة البيانات، ولكن
لقيم معلمات متعددة (مثل العثور على القيمة التي تزيد الأداء
كما في <a class="reference internal" href="modules/grid_search.html#grid-search"><span class="std std-ref">البحث الشبكي</span></a>)، قد يكون من الممكن
إعادة استخدام جوانب النموذج التي تم تعلمها من قيمة المعلمة السابقة،
مما يوفر الوقت. عندما تكون <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> صحيحة، يتم استخدام <a class="reference internal" href="#term-5"><span class="xref std std-term">السمات</span></a>
<span class="xref std std-term">الملائمة</span> الحالية لتهيئة النموذج الجديد
في استدعاء لاحق لـ <a class="reference internal" href="#term-fit"><span class="xref std std-term">fit</span></a>.</p>
<p>لاحظ أن هذا ينطبق فقط على بعض النماذج وبعض
المعلمات، وحتى بعض أوامر قيم المعلمات. بشكل عام، هناك
تفاعل بين <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> والمعلمة التي تتحكم في
عدد تكرارات المقدر.</p>
<p>بالنسبة للمقدرات المستوردة من <a class="reference internal" href="api/sklearn.ensemble.html#module-sklearn.ensemble" title="sklearn.ensemble"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ensemble</span></code></a>،
ستتفاعل <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> مع <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> أو <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>.
بالنسبة لهذه النماذج، يتوافق عدد التكرارات، المبلغ عنه عبر
<code class="docutils literal notranslate"><span class="pre">len(estimators_)</span></code> أو <code class="docutils literal notranslate"><span class="pre">n_iter_</span></code>، مع إجمالي عدد
المقدرات/التكرارات التي تم تعلمها منذ تهيئة النموذج.
وبالتالي، إذا كان النموذج قد تم تهيئته بالفعل بـ <code class="docutils literal notranslate"><span class="pre">N</span></code> من المقدرات، ويتم استدعاء <code class="docutils literal notranslate"><span class="pre">fit</span></code>
مع تعيين <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> أو <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> على <code class="docutils literal notranslate"><span class="pre">M</span></code>، فسيدرِّب النموذج
<code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">-</span> <span class="pre">N</span></code> من المقدرات الجديدة.</p>
<p>النماذج الأخرى، التي تستخدم عادةً أدوات حل تعتمد على التدرج، لها سلوك
مختلف. تعرض جميعها معلمة <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>.
يتوافق <code class="docutils literal notranslate"><span class="pre">n_iter_</span></code> المبلغ عنه مع عدد التكرارات التي تم إجراؤها أثناء آخر
استدعاء لـ <code class="docutils literal notranslate"><span class="pre">fit</span></code> وسيكون على الأكثر <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>. وبالتالي، فإننا لا
نأخذ في الاعتبار حالة المقدر منذ التهيئة.</p>
<p>يحتفظ <a class="reference internal" href="#term-partial_fit"><span class="xref std std-term">partial_fit</span></a> أيضًا بالنموذج بين الاستدعاءات، ولكنه يختلف:
مع <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> تتغير المعلمات وتكون البيانات
(أكثر أو أقل) ثابتة عبر استدعاءات <code class="docutils literal notranslate"><span class="pre">fit</span></code>؛ مع <code class="docutils literal notranslate"><span class="pre">partial_fit</span></code>،
تتغير الدفعة الصغيرة من البيانات وتبقى معلمات النموذج ثابتة.</p>
<p>هناك حالات تريد فيها استخدام <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> للملاءمة على
بيانات مختلفة، لكنها وثيقة الصلة. على سبيل المثال، قد يتم الملاءمة
في البداية لمجموعة فرعية من البيانات، ثم ضبط بحث المعلمة على
مجموعة البيانات الكاملة. بالنسبة للتصنيف، يجب أن تتضمن جميع البيانات في سلسلة
من استدعاءات <code class="docutils literal notranslate"><span class="pre">warm_start</span></code> لـ <code class="docutils literal notranslate"><span class="pre">fit</span></code> عينات من كل فئة.</p>
</dd>
</dl>
</section>
<section id="glossary-attributes">
<span id="id11"></span><h2>السمات<a class="headerlink" href="#glossary-attributes" title="Link to this heading">#</a></h2>
<p>انظر المفهوم <span class="xref std std-term">السمة</span>.</p>
<dl class="glossary">
<dt id="term-classes_"><code class="docutils literal notranslate"><span class="pre">classes_</span></code><a class="headerlink" href="#term-classes_" title="Link to this term">#</a></dt><dd><p>قائمة بتسميات الفئات المعروفة لـ <span class="xref std std-term">المصنف</span>، تعيِّن كل
تسمية إلى فهرس رقمي مستخدم في تمثيل النموذج أو ناتجنا.
على سبيل المثال، تحتوي المصفوفة الناتجة من <a class="reference internal" href="#term-predict_proba"><span class="xref std std-term">predict_proba</span></a> على أعمدة
محاذية لـ <code class="docutils literal notranslate"><span class="pre">classes_</span></code>. بالنسبة للمصنفات <span class="xref std std-term">متعددة المخرجات</span>،
يجب أن تكون <code class="docutils literal notranslate"><span class="pre">classes_</span></code> قائمة من القوائم، مع قائمة فئة واحدة
لكل ناتج.  لكل ناتج، يجب فرز الفئات
(عدديًا أو معجميًا للسلاسل).</p>
<p>غالبًا ما تتم إدارة <code class="docutils literal notranslate"><span class="pre">classes_</span></code> والتعيين إلى الفهارس باستخدام
<a class="reference internal" href="modules/generated/sklearn.preprocessing.LabelEncoder.html#sklearn.preprocessing.LabelEncoder" title="sklearn.preprocessing.LabelEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">preprocessing.LabelEncoder</span></code></a>.</p>
</dd>
<dt id="term-components_"><code class="docutils literal notranslate"><span class="pre">components_</span></code><a class="headerlink" href="#term-components_" title="Link to this term">#</a></dt><dd><p>مصفوفة تحويل تآلفي ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_components,</span> <span class="pre">n_features)</span></code>
تُستخدم في العديد من <a class="reference internal" href="#term-95"><span class="xref std std-term">المحولات</span></a> الخطية حيث <a class="reference internal" href="#term-n_components"><span class="xref std std-term">n_components</span></a> هو
عدد ميزات الإخراج و <a class="reference internal" href="#term-n_features"><span class="xref std std-term">n_features</span></a> هو عدد ميزات
الإدخال.</p>
<p>انظر أيضًا <a class="reference internal" href="#term-components_"><span class="xref std std-term">components_</span></a> وهي سمة مماثلة للمتنبئات
الخطية.</p>
</dd>
<dt id="term-coef_"><code class="docutils literal notranslate"><span class="pre">coef_</span></code><a class="headerlink" href="#term-coef_" title="Link to this term">#</a></dt><dd><p>مصفوفة الوزن/المعامل لنموذج خطي معمم
<span class="xref std std-term">متنبئ</span>، ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_features,)</span></code> للتصنيف الثنائي
والانحدار أحادي الناتج، <code class="docutils literal notranslate"><span class="pre">(n_classes,</span> <span class="pre">n_features)</span></code> لـ
التصنيف متعدد الفئات و <code class="docutils literal notranslate"><span class="pre">(n_targets,</span> <span class="pre">n_features)</span></code> لـ
الانحدار متعدد المخرجات. لاحظ أن هذا لا يتضمن مصطلح التقاطع
(أو التحيز)، والذي يتم تخزينه في <code class="docutils literal notranslate"><span class="pre">intercept_</span></code>.</p>
<p>عندما تكون متاحة، لا يتم توفير <code class="docutils literal notranslate"><span class="pre">feature_importances_</span></code> عادةً أيضًا،
ولكن يمكن حسابها كمعيار إدخال كل ميزة في
<code class="docutils literal notranslate"><span class="pre">coef_</span></code>.</p>
<p>انظر أيضًا <a class="reference internal" href="#term-components_"><span class="xref std std-term">components_</span></a> وهي سمة مماثلة للمحولات
الخطية.</p>
</dd>
<dt id="term-embedding_"><code class="docutils literal notranslate"><span class="pre">embedding_</span></code><a class="headerlink" href="#term-embedding_" title="Link to this term">#</a></dt><dd><p>تضمين لبيانات التدريب في مقدرات <span class="xref std std-ref">تعلم متعدد الشعب</span>، ذات شكل <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_components)</span></code>،
مطابق لناتج <a class="reference internal" href="#term-fit_transform"><span class="xref std std-term">fit_transform</span></a>.  انظر أيضًا
<a class="reference internal" href="#term-labels_"><span class="xref std std-term">labels_</span></a>.</p>
</dd>
<dt id="term-n_iter_"><code class="docutils literal notranslate"><span class="pre">n_iter_</span></code><a class="headerlink" href="#term-n_iter_" title="Link to this term">#</a></dt><dd><p>عدد التكرارات التي تم إجراؤها فعليًا عند ملاءمة مقدر تكراري
قد يتوقف عند التقارب. انظر أيضًا <a class="reference internal" href="#term-max_iter"><span class="xref std std-term">max_iter</span></a>.</p>
</dd>
<dt id="term-feature_importances_"><code class="docutils literal notranslate"><span class="pre">feature_importances_</span></code><a class="headerlink" href="#term-feature_importances_" title="Link to this term">#</a></dt><dd><p>متجه ذو شكل <code class="docutils literal notranslate"><span class="pre">(n_features,)</span></code> متاح في بعض
<a class="reference internal" href="#term-91"><span class="xref std std-term">المتنبئات</span></a> لتوفير مقياس نسبي لأهمية
كل ميزة في تنبؤات النموذج.</p>
</dd>
<dt id="term-labels_"><code class="docutils literal notranslate"><span class="pre">labels_</span></code><a class="headerlink" href="#term-labels_" title="Link to this term">#</a></dt><dd><p>متجه يحتوي على تسمية كتلة لكل عينة من بيانات التدريب
في <a class="reference internal" href="#term-80"><span class="xref std std-term">المُجمِّعات</span></a>، مطابق لناتج
<a class="reference internal" href="#term-fit_predict"><span class="xref std std-term">fit_predict</span></a>.  انظر أيضًا <a class="reference internal" href="#term-embedding_"><span class="xref std std-term">embedding_</span></a>.</p>
</dd>
</dl>
</section>
<section id="glossary-sample-props">
<span id="id12"></span><h2>خصائص البيانات والعينة<a class="headerlink" href="#glossary-sample-props" title="Link to this heading">#</a></h2>
<p>انظر المفهوم <a class="reference internal" href="#term-60"><span class="xref std std-term">خاصية العينة</span></a>.</p>
<dl class="glossary">
<dt id="term-groups"><code class="docutils literal notranslate"><span class="pre">groups</span></code><a class="headerlink" href="#term-groups" title="Link to this term">#</a></dt><dd><p>يُستخدم في إجراءات التحقق المتبادل لتحديد العينات المترابطة.
كل قيمة هي مُعرِّف بحيث، في <span class="xref std std-term">مُقسِّم CV</span> داعم،
قد لا تظهر العينات من قيمة <code class="docutils literal notranslate"><span class="pre">groups</span></code> في كل من مجموعة التدريب
ومجموعة الاختبار المقابلة لها.
انظر <a class="reference internal" href="modules/cross_validation.html#group-cv"><span class="std std-ref">مكررات التحقق المتبادل للبيانات المجمعة</span></a>.</p>
</dd>
<dt id="term-sample_weight"><code class="docutils literal notranslate"><span class="pre">sample_weight</span></code><a class="headerlink" href="#term-sample_weight" title="Link to this term">#</a></dt><dd><p>وزن نسبي لكل عينة.  بشكل حدسي، إذا كانت جميع الأوزان
أعدادًا صحيحة، فيجب أن يكون النموذج أو الدرجة الموزونة مكافئة لتلك
المحسوبة عند تكرار العينة بعدد المرات المحددة في
الوزن. قد يتم تحديد الأوزان كعناصر عشرية، بحيث تكون أوزان العينة
عادةً مكافئة لعامل قياس ثابت موجب.</p>
<p>FIXME هل هذا التفسير هو الحال دائمًا في الممارسة؟ ليس لدينا
اختبارات شائعة.</p>
<p>تدعم بعض المقدرات، مثل أشجار القرار، الأوزان السلبية.
FIXME: قد لا يتم اختبار هذه الميزة أو غيابها أو توثيقها في
العديد من المقدرات.</p>
<p>هذا ليس هو الحال تمامًا عندما تأخذ معلمات أخرى للنموذج
في الاعتبار عدد العينات في منطقة ما، كما هو الحال مع <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> في
<a class="reference internal" href="modules/generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code class="xref py py-class docutils literal notranslate"><span class="pre">cluster.DBSCAN</span></code></a>. في هذه الحالة، يصبح عدد العينات
مجموع أوزانها.</p>
<p>في التصنيف، يمكن أيضًا تحديد أوزان العينة كدالة
للفئة مع <a class="reference internal" href="#term-52"><span class="xref std std-term">معلمة</span></a> المقدر <a class="reference internal" href="#term-class_weight"><span class="xref std std-term">class_weight</span></a>.</p>
</dd>
<dt id="term-X"><code class="docutils literal notranslate"><span class="pre">X</span></code><a class="headerlink" href="#term-X" title="Link to this term">#</a></dt><dd><p>يشير إلى البيانات التي يتم ملاحظتها في وقت التدريب والتنبؤ، وتُستخدم كـ
متغيرات مستقلة في التعلم. يكون الترميز بأحرف كبيرة للإشارة
إلى أنه عادةً ما يكون مصفوفة (انظر <a class="reference internal" href="#term-57"><span class="xref std std-term">مستطيلي</span></a>).
عندما تكون مصفوفة، يمكن تمثيل كل عينة بواسطة متجه <a class="reference internal" href="#term-29"><span class="xref std std-term">ميزة</span></a>،
أو متجه <a class="reference internal" href="#term-56"><span class="xref std std-term">محسوب مسبقًا</span></a> (عدم) تشابه مع كل
عينة تدريب. قد لا يكون <code class="docutils literal notranslate"><span class="pre">X</span></code> مصفوفة أيضًا، وقد يتطلب
<span class="xref std std-term">مستخرج ميزات</span> أو <a class="reference internal" href="#term-54"><span class="xref std std-term">مقياس زوجي</span></a> لتحويله إلى
واحد قبل تعلم نموذج.</p>
</dd>
<dt id="term-Xt"><code class="docutils literal notranslate"><span class="pre">Xt</span></code><a class="headerlink" href="#term-Xt" title="Link to this term">#</a></dt><dd><p>اختصار لـ &quot;X <span class="xref std std-term">مُحوَّل</span>&quot;.</p>
</dd>
<dt id="term-y"><code class="docutils literal notranslate"><span class="pre">y</span></code><a class="headerlink" href="#term-y" title="Link to this term">#</a></dt><dt id="term-Y"><code class="docutils literal notranslate"><span class="pre">Y</span></code><a class="headerlink" href="#term-Y" title="Link to this term">#</a></dt><dd><p>يشير إلى البيانات التي قد يتم ملاحظتها في وقت التدريب كمتغير
تابع في التعلم، ولكنها غير متوفرة في وقت التنبؤ، و
عادةً ما تكون <span class="xref std std-term">هدف</span> التنبؤ. قد يكون الترميز
بأحرف كبيرة للإشارة إلى أنه مصفوفة، يمثل
<span class="xref std std-term">مخرجات متعددة</span>، على سبيل المثال؛ ولكن عادةً ما نستخدم <code class="docutils literal notranslate"><span class="pre">y</span></code> و
أحيانًا نفعل ذلك حتى عند افتراض مخرجات متعددة.</p>
</dd>
</dl>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  <div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item">
<div class="prev-next-area">
    <a class="left-prev"
       href="whats_new/older_versions.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">السابق</p>
        <p class="prev-next-title">الإصدرات القديمة</p>
      </div>
    </a>
    <a class="right-next"
       href="developers/index.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">التالي</p>
        <p class="prev-next-title">دليل المطورين</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>
                </footer>
              
              
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id2">مفاهيم عامة</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-estimator-types">واجهات برمجة تطبيقات الفئات وأنواع المقدرات</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-metadata-routing">توجيه البيانات الوصفية</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-target-types">أنواع الأهداف</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-methods">الأساليب</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-parameters">المعلمات</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-attributes">السمات</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glossary-sample-props">خصائص البيانات والعينة</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="_sources/glossary.rst.txt">
      <i class="fa-solid fa-file-lines"></i> إظهار المصدر
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2007 - 2024, scikit-learn developers (BSD License) ### Translate into Arabic Eng. Ahmed Almaghz - 2024.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
</div>

  </footer>
  </body>
</html>