.. _ensemble:

===========================================================================
المجموعات: تعزيز التدرج، الغابات العشوائية، التجميع، التصويت، التكديس
===========================================================================

.. currentmodule:: sklearn.ensembleش

**أساليب المجموعات** تجمع تنبؤات العديد من
المُقدِّرات الأساسية المبنية بخوارزمية تعلم مُعطاة من أجل تحسين
قابلية التعميم / المتانة على مُقدِّر واحد.

مثالان مشهوران جدًا لأساليب المجموعات هما :ref:`أشجار مُعززة بالتدرج
<gradient_boosting>` و :ref:`الغابات العشوائية <forest>`.

بشكل عام، يمكن تطبيق نماذج المجموعات على أي مُتعلم أساسي يتجاوز
الأشجار، في أساليب المتوسط مثل :ref:`أساليب التجميع <bagging>`،
:ref:`تكديس النماذج <stacking>`، أو :ref:`التصويت <voting_classifier>`، أو في
التعزيز، مثل :ref:`AdaBoost <adaboost>`.

.. _gradient_boosting:

أشجار مُعززة بالتدرج
======================

`تعزيز شجرة التدرج <https://en.wikipedia.org/wiki/Gradient_boosting>`_
أو أشجار القرار المُعززة بالتدرج (GBDT) هي تعميم
للتعزيز لدوال الخسارة القابلة للاشتقاق التعسفية، انظر العمل الأساسي لـ
[Friedman2001]_. GBDT هو نموذج ممتاز لكل من الانحدار و
التصنيف، خاصةً لبيانات الجدول.

.. topic:: :class:`GradientBoostingClassifier` مقابل :class:`HistGradientBoostingClassifier`

  يُوفر Scikit-learn تطبيقين لأشجار مُعززة بالتدرج:
  :class:`HistGradientBoostingClassifier` مقابل
  :class:`GradientBoostingClassifier` للتصنيف، والفئات
  المُقابلة للانحدار. يمكن أن يكون الأول **أسرع بأعداد مُضاعفة**
  من الأخير عندما يكون عدد العينات
  أكبر من عشرات الآلاف من العينات.

  يتم دعم القيم المفقودة والبيانات الفئوية أصلاً بواسطة
  إصدار Hist...، مما يُلغي الحاجة إلى مُعالجة مُسبقة إضافية مثل
  التعويض.

  قد يُفضل :class:`GradientBoostingClassifier` و
  :class:`GradientBoostingRegressor` لأحجام العينات الصغيرة لأن
  التجميع قد يؤدي إلى نقاط تقسيم تقريبية جدًا
  في هذا الإعداد.

.. _histogram_based_gradient_boosting:

تعزيز التدرج القائم على الرسم البياني
----------------------------------

قدّم Scikit-learn 0.21 تطبيقين جديدين لـ
أشجار مُعززة بالتدرج، وهما :class:`HistGradientBoostingClassifier`
و :class:`HistGradientBoostingRegressor`، مُستوحى من
`LightGBM <https://github.com/Microsoft/LightGBM>`__ (انظر [LightGBM]_).

يمكن أن يكون هذان المُقدِّران القائمان على الرسم البياني **أسرع بأعداد مُضاعفة**
من :class:`GradientBoostingClassifier` و
:class:`GradientBoostingRegressor` عندما يكون عدد العينات أكبر
من عشرات الآلاف من العينات.

لديهم أيضًا دعم مُدمج للقيم المفقودة، مما يُتجنب الحاجة
إلى مُعوض.

يقوم هذان المُقدِّران السريعان أولاً بتجميع عينات الإدخال ``X`` في
صناديق ذات قيم صحيحة (عادةً 256 صندوقًا) مما يُقلل بشكل كبير من
عدد نقاط التقسيم التي يجب أخذها في الاعتبار، ويسمح للخوارزمية بـ
الاستفادة من هياكل البيانات القائمة على الأعداد الصحيحة (الرسوم البيانية) بدلاً من الاعتماد على
قيم مُستمرة مُرتبة عند بناء الأشجار. واجهة برمجة التطبيقات لهؤلاء
المُقدِّرين مُختلفة قليلاً، وبعض ميزات
:class:`GradientBoostingClassifier` و :class:`GradientBoostingRegressor`
غير مدعومة حتى الآن، على سبيل المثال بعض دوال الخسارة.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_inspection_plot_partial_dependence.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_forest_hist_grad_boosting_comparison.py`

الاستخدام
^^^^^

معظم المعلمات لم تتغير من
:class:`GradientBoostingClassifier` و :class:`GradientBoostingRegressor`.
استثناء واحد هو المعلمة ``max_iter`` التي تحل محل ``n_estimators``، و
تتحكم في عدد تكرارات عملية التعزيز::

  >>> from sklearn.ensemble import HistGradientBoostingClassifier
  >>> from sklearn.datasets import make_hastie_10_2

  >>> X, y = make_hastie_10_2(random_state=0)
  >>> X_train, X_test = X[:2000], X[2000:]
  >>> y_train, y_test = y[:2000], y[2000:]

  >>> clf = HistGradientBoostingClassifier(max_iter=100).fit(X_train, y_train)
  >>> clf.score(X_test, y_test)
  0.8965

الخسائر المتاحة لـ **الانحدار** هي:

- 'squared_error'، وهي خسارة افتراضية؛
- 'absolute_error'، وهي أقل حساسية للقيم المتطرفة من الخطأ التربيعي؛
- 'gamma'، وهي مُناسبة جدًا لنمذجة النتائج الإيجابية تمامًا؛
- 'poisson'، وهي مُناسبة جدًا لنمذجة الأعداد والترددات؛
- 'quantile'، الذي يسمح بتقدير مُكمِّم شرطي يمكن استخدامه لاحقًا
  للحصول على فترات تنبؤ.

بالنسبة لـ **التصنيف**، فإن 'log_loss' هو الخيار الوحيد. بالنسبة للتصنيف الثنائي،
فإنه يستخدم خسارة السجل الثنائي، والمعروفة أيضًا باسم انحراف ذات الحدين أو
الانتروبيا المتقاطعة الثنائية. بالنسبة لـ `n_classes >= 3`، فإنه يستخدم دالة خسارة السجل
متعددة الفئات، مع الانحراف متعدد الحدود والانتروبيا المتقاطعة الفئوية
كأسماء بديلة.
يتم تحديد إصدار الخسارة المناسب بناءً على :term:`y` الذي تم تمريره إلى
:term:`fit`.

يمكن التحكم في حجم الأشجار من خلال معلمات ``max_leaf_nodes`` و
``max_depth`` و ``min_samples_leaf``.

يتم التحكم في عدد الصناديق المُستخدمة لتجميع البيانات باستخدام معلمة ``max_bins``.
يُعد استخدام صناديق أقل شكلًا من أشكال التنظيم. يُوصى عمومًا باستخدام أكبر عدد ممكن
من الصناديق (255)، وهو الإعداد الافتراضي.

تعمل المعلمة ``l2_regularization`` كمنظم لدالة الخسارة، و
تقابل :math:`\lambda` في التعبير التالي (انظر المعادلة (2)
في [XGBoost]_):

.. math::

    \mathcal{L}(\phi) =  \sum_i l(\hat{y}_i, y_i) + \frac12 \sum_k \lambda ||w_k||^2

.. dropdown:: تفاصيل حول تنظيم l2

  من المهم ملاحظة أن مُصطلح الخسارة :math:`l(\hat{y}_i, y_i)` يصف
  فقط نصف دالة الخسارة الفعلية باستثناء خسارة الكرة والدبوس والخطأ
  المُطلق.

  يشير الفهرس :math:`k` إلى الشجرة k في مجموعة الأشجار. في حالة
  الانحدار والتصنيف الثنائي، تُنمي نماذج تعزيز التدرج شجرة واحدة لكل
  تكرار، ثم يمتد :math:`k` حتى `max_iter`. في حالة
  مشاكل التصنيف متعددة الفئات، تكون القيمة القصوى للفهرس :math:`k` هي
  `n_classes` :math:`\times` `max_iter`.

  إذا كان :math:`T_k` يُشير إلى عدد الأوراق في الشجرة k، فإن :math:`w_k`
  هو متجه بطول :math:`T_k`، والذي يحتوي على قيم الأوراق بالشكل `w
  = -sum_gradient / (sum_hessian + l2_regularization)` (انظر المعادلة (5) في
  [XGBoost]_).

  يتم اشتقاق قيم الأوراق :math:`w_k` عن طريق قسمة مجموع تدرجات
  دالة الخسارة على المجموع المُجتمع للهيسيات. إضافة التنظيم إلى
  المقام يُعاقب الأوراق ذات الهيسيات الصغيرة (المناطق المسطحة)،
  مما يؤدي إلى تحديثات أصغر. تُساهم قيم :math:`w_k` هذه بعد ذلك في
  تنبؤ النموذج لإدخال مُعين ينتهي به المطاف في الورقة المُقابلة.
  التنبؤ النهائي هو مجموع التنبؤ الأساسي ومساهمات من
  كل شجرة. ثم يتم تحويل نتيجة هذا المجموع بواسطة دالة الربط
  العكسي اعتمادًا على اختيار دالة الخسارة (انظر
  :ref:`gradient_boosting_formulation`).

  لاحظ أن الورقة الأصلية [XGBoost]_ تُقدم مُصطلحًا :math:`\gamma\sum_k
  T_k` يعاقب عدد الأوراق (مما يجعلها نسخة سلسة من
  `max_leaf_nodes`) غير مُقدمة هنا لأنه غير مُطبق في scikit-learn؛
  بينما :math:`\lambda` يعاقب حجم تنبؤات الشجرة الفردية قبل
  إعادة تغيير مقياسها بواسطة مُعدل التعلم، انظر
  :ref:`gradient_boosting_shrinkage`.


لاحظ أنه **يتم تمكين الإيقاف المُبكر افتراضيًا إذا كان عدد العينات
أكبر من 10000**. يتم التحكم في سلوك الإيقاف المُبكر عبر
معلمات ``early_stopping`` و ``scoring`` و ``validation_fraction`` و
``n_iter_no_change`` و ``tol``. من الممكن الإيقاف المُبكر
باستخدام :term:`مُسجل` عشوائي، أو مجرد خسارة التدريب أو التحقق من الصحة.
لاحظ أنه لأسباب فنية، فإن استخدام دالة قابلة للاستدعاء كمُسجل أبطأ بكثير
من استخدام الخسارة. افتراضيًا، يتم إجراء الإيقاف المُبكر إذا كان هناك على الأقل
10000 عينة في مجموعة التدريب، باستخدام خسارة التحقق من الصحة.

.. _nan_support_hgbt:

دعم القيم المفقودة
^^^^^^^^^^^^^^^^^^^^^^

:class:`HistGradientBoostingClassifier` و
:class:`HistGradientBoostingRegressor` لديهما دعم مُدمج للقيم
المفقودة (NaNs).

أثناء التدريب، يتعلم مُنمي الشجرة عند كل نقطة تقسيم ما إذا كانت العينات
ذات القيم المفقودة يجب أن تذهب إلى الطفل الأيسر أو الأيمن، بناءً على
المكسب المُحتمل. عند التنبؤ، يتم تعيين العينات ذات القيم المفقودة إلى
الطفل الأيسر أو الأيمن تبعًا لذلك::

  >>> from sklearn.ensemble import HistGradientBoostingClassifier
  >>> import numpy as np

  >>> X = np.array([0, 1, 2, np.nan]).reshape(-1, 1)
  >>> y = [0, 0, 1, 1]

  >>> gbdt = HistGradientBoostingClassifier(min_samples_leaf=1).fit(X, y)
  >>> gbdt.predict(X)
  array([0, 0, 1, 1])

عندما يكون نمط الفقد تنبؤيًا، يمكن إجراء التقسيمات على
ما إذا كانت قيمة الميزة مفقودة أم لا::

  >>> X = np.array([0, np.nan, 1, 2, np.nan]).reshape(-1, 1)
  >>> y = [0, 1, 0, 0, 1]
  >>> gbdt = HistGradientBoostingClassifier(min_samples_leaf=1,
  ...                                       max_depth=2,
  ...                                       learning_rate=1,
  ...                                       max_iter=1).fit(X, y)
  >>> gbdt.predict(X)
  array([0, 1, 0, 0, 1])

إذا لم تتم مصادفة أي قيم مفقودة لميزة مُعينة أثناء التدريب،
فسيتم تعيين العينات ذات القيم المفقودة إلى أي طفل لديه معظم
العينات.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_hgbt_regression.py`

.. _sw_hgbdt:

دعم وزن العينة
^^^^^^^^^^^^^^^^^^^^^

:class:`HistGradientBoostingClassifier` و
:class:`HistGradientBoostingRegressor` يدعمان أوزان العينات أثناء
:term:`fit`.

يوضح المثال التوضيحي التالي أن العينات ذات وزن عينة صفري يتم تجاهلها:

    >>> X = [[1, 0],
    ...      [1, 0],
    ...      [1, 0],
    ...      [0, 1]]
    >>> y = [0, 0, 1, 0]
    >>> # تجاهل عينتي التدريب الأوليين عن طريق تعيين وزنهما إلى 0
    >>> sample_weight = [0, 0, 1, 1]
    >>> gb = HistGradientBoostingClassifier(min_samples_leaf=1)
    >>> gb.fit(X, y, sample_weight=sample_weight)
    HistGradientBoostingClassifier(...)
    >>> gb.predict([[1, 0]])
    array([1])
    >>> gb.predict_proba([[1, 0]])[0, 1]
    0.99...

كما ترى، يتم تصنيف `[1, 0]` بشكل مريح على أنه `1` نظرًا لتجاهل
العينتين الأوليين بسبب أوزان العينات الخاصة بهما.

تفاصيل التطبيق: يُعادل أخذ أوزان العينات في الاعتبار
ضرب التدرجات (والهيسيات) بأوزان العينات. لاحظ أن
مرحلة التجميع (على وجه التحديد حساب المُكمِّمات) لا تأخذ الأوزان
في الاعتبار.

.. _categorical_support_gbdt:

دعم الميزات الفئوية
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

:class:`HistGradientBoostingClassifier` و
:class:`HistGradientBoostingRegressor` لديهما دعم أصلي لـ
الميزات الفئوية: يمكنهما اعتبار التقسيمات على البيانات الفئوية غير المُرتبة.

بالنسبة لمجموعات البيانات ذات الميزات الفئوية، غالبًا ما يكون استخدام الدعم الفئوي
الأصلي أفضل من الاعتماد على الترميز الأحادي الساخن
(:class:`~sklearn.preprocessing.OneHotEncoder`)، لأن الترميز الأحادي الساخن
يتطلب عمق شجرة أكبر لتحقيق تقسيمات مُكافئة. من الأفضل أيضًا عادةً
الاعتماد على الدعم الفئوي الأصلي بدلاً من مُعالجة
الميزات الفئوية على أنها مُستمرة (ترتيبية)، وهو ما يحدث للبيانات الفئوية المُرمَّزة
ترتيبيًا، نظرًا لأن الفئات هي كميات اسمية حيث لا يهم الترتيب.

لتمكين الدعم الفئوي، يمكن تمرير قناع منطقي إلى
معلمة `categorical_features`، مُشيرًا إلى الميزة الفئوية. في
ما يلي، سيتم مُعالجة الميزة الأولى على أنها فئوية والميزة
الثانية على أنها عددية::

  >>> gbdt = HistGradientBoostingClassifier(categorical_features=[True, False])

بالتساوي، يمكن للمرء تمرير قائمة من الأعداد الصحيحة التي تُشير إلى مؤشرات
الميزات الفئوية::

  >>> gbdt = HistGradientBoostingClassifier(categorical_features=[0])

عندما يكون الإدخال DataFrame، من الممكن أيضًا تمرير قائمة بأسماء الأعمدة::

  >>> gbdt = HistGradientBoostingClassifier(categorical_features=["site", "manufacturer"])

أخيرًا، عندما يكون الإدخال DataFrame، يمكننا استخدام
`categorical_features="from_dtype"` وفي هذه الحالة سيتم مُعالجة جميع الأعمدة ذات
`dtype` الفئوي كميزات فئوية.

يجب أن تكون عدد العناصر في كل ميزة فئوية أقل من معلمة `max_bins`.
لمثال على استخدام تعزيز التدرج القائم على الرسم البياني على الميزات
الفئوية، انظر
:ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_categorical.py`.

إذا كانت هناك قيم مفقودة أثناء التدريب، فسيتم
مُعالجة القيم المفقودة على أنها فئة مناسبة. إذا لم تكن هناك قيم مفقودة أثناء التدريب،
فعند التنبؤ، يتم تعيين القيم المفقودة إلى العقدة التابعة التي تحتوي على
معظم العينات (تمامًا مثل الميزات المُستمرة). عند التنبؤ،
سيتم مُعالجة الفئات التي لم تتم رؤيتها أثناء وقت الملاءمة كقيم
مفقودة.

.. dropdown:: إيجاد التقسيم مع الميزات الفئوية

  الطريقة الأساسية للنظر في التقسيمات الفئوية في شجرة هي النظر في
  جميع أقسام :math:`2^{K - 1} - 1`، حيث :math:`K` هو عدد
  الفئات. يمكن أن يصبح هذا باهظ الثمن بسرعة عندما يكون :math:`K` كبيرًا.
  لحسن الحظ، نظرًا لأن أشجار تعزيز التدرج هي دائمًا أشجار انحدار (حتى
  لمشاكل التصنيف)، يوجد إستراتيجية أسرع يمكن أن تُعطي
  تقسيمات مُكافئة. أولاً، يتم فرز فئات الميزة وفقًا لـ
  تباين الهدف، لكل فئة `k`. بمجرد فرز الفئات،
  يمكن للمرء النظر في *أقسام مُستمرة*، أي مُعالجة الفئات
  كما لو كانت قيمًا مُستمرة مُرتبة (انظر Fisher [Fisher1958]_ لإثبات
  رسمي). نتيجة لذلك، لا يلزم النظر إلا في :math:`K - 1` تقسيمًا
  بدلاً من :math:`2^{K - 1} - 1`. الفرز الأولي هو
  عملية :math:`\mathcal{O}(K \log(K))`، مما يؤدي إلى تعقيد إجمالي قدره
  :math:`\mathcal{O}(K \log(K) + K)`، بدلاً من :math:`\mathcal{O}(2^K)`.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_categorical.py`

.. _monotonic_cst_gbdt:

قيود رتيبة
^^^^^^^^^^^^^^^^^^^^^

اعتمادًا على المشكلة المطروحة، قد يكون لديك معرفة مُسبقة تُشير
إلى أن ميزة مُعينة يجب أن يكون لها بشكل عام تأثير إيجابي (أو سلبي)
على القيمة المستهدفة. على سبيل المثال، مع تساوي كل شيء آخر، يجب أن تؤدي درجة الائتمان الأعلى إلى زيادة احتمالية الموافقة على قرض.
تسمح لك القيود الرتيبة بدمج هذه المعرفة المُسبقة في
النموذج.

بالنسبة للمتنبئ :math:`F` بميزتين:

- **قيد الزيادة الرتيبة** هو قيد بالشكل:

  .. math::
      x_1 \leq x_1' \implies F(x_1, x_2) \leq F(x_1', x_2)

- **قيد النقصان الرتيب** هو قيد بالشكل:

  .. math::
      x_1 \leq x_1' \implies F(x_1, x_2) \geq F(x_1', x_2)

يمكنك تحديد قيد رتيب على كل ميزة باستخدام
معلمة `monotonic_cst`. لكل ميزة، تُشير القيمة 0 إلى عدم وجود
قيد، بينما تُشير 1 و -1 إلى قيد زيادة رتيبة و
قيد نقصان رتيب، على التوالي::

  >>> from sklearn.ensemble import HistGradientBoostingRegressor

  ... # زيادة رتيبة، نقصان رتيب، وعدم وجود قيد على الميزات الثلاث
  >>> gbdt = HistGradientBoostingRegressor(monotonic_cst=[1, -1, 0])

في سياق التصنيف الثنائي، يعني فرض قيد زيادة رتيبة (نقصان) أن القيم الأعلى للميزة من المُفترض
أن يكون لها تأثير إيجابي (سلبي) على احتمالية العينات
للانتماء إلى الفئة الإيجابية.

ومع ذلك، فإن القيود الرتيبة تُقيّد بشكل هامشي فقط تأثيرات الميزات على الناتج.
على سبيل المثال، لا يمكن استخدام قيود الزيادة والنقصان الرتيبة لفرض
قيد النمذجة التالي:

.. math::
    x_1 \leq x_1' \implies F(x_1, x_2) \leq F(x_1', x_2')

أيضًا، القيود الرتيبة غير مدعومة للتصنيف متعدد الفئات.

.. note::
    نظرًا لأن الفئات هي كميات غير مُرتبة، فليس من الممكن فرض
    قيود رتيبة على الميزات الفئوية.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_monotonic_constraints.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_hgbt_regression.py`

.. _interaction_cst_hgbt:

قيود التفاعل
^^^^^^^^^^^^^^^^^^^^^^^

من حيث المبدأ، يُسمح لأشجار تعزيز التدرج الرسم البياني باستخدام أي ميزة
لتقسيم عقدة إلى عقد تابعة. هذا يخلق ما يسمى بالتفاعلات بين
الميزات، أي استخدام ميزات مُختلفة كتقسيم على طول فرع. في بعض الأحيان،
يريد المرء تقييد التفاعلات الممكنة، انظر [Mayer2022]_. يمكن
القيام بذلك بواسطة المعلمة ``interaction_cst``، حيث يمكن للمرء تحديد مؤشرات
الميزات المسموح لها بالتفاعل.
على سبيل المثال، مع 3 ميزات إجمالاً، ``interaction_cst=[{0}, {1}, {2}]``
يمنع جميع التفاعلات.
تُحدد القيود ``[{0, 1}, {1, 2}]`` مجموعتين من الميزات التي يُحتمل
أن تتفاعل. قد تتفاعل الميزات 0 و 1 مع بعضها البعض، وكذلك
الميزات 1 و 2. لكن لاحظ أنه يُمنع تفاعل الميزات 0 و 2.
يُصوِّر ما يلي شجرة والتقسيمات الممكنة للشجرة:

.. code-block:: none

      1      <- يمكن تطبيق مجموعتي القيود من الآن فصاعدًا
     / \
    1   2    <- لا يزال التقسيم الأيسر يُلبي مجموعتي القيود.
   / \ / \      التقسيم الأيمن عند الميزة 2 لديه المجموعة {1، 2} فقط من الآن فصاعدًا.

يستخدم LightGBM نفس المنطق للمجموعات المتداخلة.

لاحظ أن الميزات غير المدرجة في ``interaction_cst`` يتم تعيينها تلقائيًا
مجموعة تفاعل لأنفسهم. مع 3 ميزات مرة أخرى، هذا
يعني أن ``[{0}]`` يُعادل ``[{0}, {1, 2}]``.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_inspection_plot_partial_dependence.py`

.. rubric:: المراجع

.. [Mayer2022] M. Mayer, S.C. Bourassa, M. Hoesli, and D.F. Scognamiglio.
    2022. :doi:`تطبيقات التعلم الآلي لتقييم الأراضي والهياكل
    <10.3390/jrfm15050193>`.
    Journal of Risk and Financial Management 15, no. 5: 193

التوازي منخفض المستوى
^^^^^^^^^^^^^^^^^^^^^


:class:`HistGradientBoostingClassifier` و
:class:`HistGradientBoostingRegressor` يستخدمان OpenMP
للتوازي من خلال Cython. لمزيد من التفاصيل حول كيفية التحكم في
عدد سلاسل العمليات، يُرجى الرجوع إلى ملاحظات :ref:`التوازي` الخاصة بنا.

الأجزاء التالية متوازية:

- تعيين العينات من القيم الحقيقية إلى الصناديق ذات القيم الصحيحة (إيجاد عتبات
  الصناديق هو تسلسلي)
- بناء الرسوم البيانية متوازي على الميزات
- إيجاد أفضل نقطة تقسيم عند عقدة متوازي على الميزات
- أثناء الملاءمة، تعيين العينات في العقد التابعة اليسرى واليمنى
  متوازي على العينات
- حسابات التدرج والهيسيات متوازية على العينات
- التنبؤ متوازي على العينات

.. _Why_it's_faster:

لماذا هو أسرع
^^^^^^^^^^^^^^^

عنق الزجاجة في إجراء تعزيز التدرج هو بناء أشجار القرار.
يتطلب بناء شجرة قرار تقليدية (كما هو الحال في GBDTs الأخرى
:class:`GradientBoostingClassifier` و :class:`GradientBoostingRegressor`)
فرز العينات عند كل عقدة (لكل
ميزة). الفرز ضروري بحيث يمكن حساب المكسب المُحتمل لنقطة تقسيم
بكفاءة. وبالتالي، فإن تقسيم عقدة واحدة له تعقيد
:math:`\mathcal{O}(n_\text{features} \times n \log(n))` حيث :math:`n`
هو عدد العينات عند العقدة.

:class:`HistGradientBoostingClassifier` و
:class:`HistGradientBoostingRegressor`، على النقيض من ذلك، لا يتطلبان فرز
قيم الميزات ويستخدمان بدلاً من ذلك بنية بيانات تسمى الرسم البياني، حيث
يتم ترتيب العينات ضمنيًا. بناء رسم بياني له
تعقيد :math:`\mathcal{O}(n)`، لذا فإن إجراء تقسيم العقدة له
تعقيد :math:`\mathcal{O}(n_\text{features} \times n)`، أصغر بكثير
من السابق. بالإضافة إلى ذلك، بدلاً من النظر في :math:`n` نقاط تقسيم،
نحن نعتبر فقط ``max_bins`` نقاط تقسيم، والتي قد تكون أصغر
بكثير.

من أجل بناء الرسوم البيانية، يجب تجميع بيانات الإدخال `X` في
صناديق ذات قيم صحيحة. يتطلب إجراء التجميع هذا فرز قيم الميزات،
ولكنه يحدث مرة واحدة فقط في بداية عملية التعزيز
(ليس عند كل عقدة، كما هو الحال في :class:`GradientBoostingClassifier` و
:class:`GradientBoostingRegressor`).

أخيرًا، العديد من أجزاء تطبيق
:class:`HistGradientBoostingClassifier` و
:class:`HistGradientBoostingRegressor` متوازية.

.. rubric:: المراجع

.. [XGBoost] Tianqi Chen, Carlos Guestrin, :arxiv:`"XGBoost: نظام تعزيز شجرة قابل للتطوير" <1603.02754>`

.. [LightGBM] Ke et. al. `"LightGBM: شجرة قرار تعزيز تدرج فعالة للغاية" <https://papers.nips.cc/paper/
   6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree>`_

.. [Fisher1958] Fisher, W.D. (1958). `"حول التجميع لأقصى تجانس"
   <http://csiss.ncgia.ucsb.edu/SPACE/workshops/2004/SAC/files/fisher.pdf>`_
   Journal of the American Statistical Association, 53, 789-798.



:class:`GradientBoostingClassifier` و :class:`GradientBoostingRegressor`
----------------------------------------------------------------------------

يتم وصف استخدام ومعلمات :class:`GradientBoostingClassifier` و
:class:`GradientBoostingRegressor` أدناه. أهم معلمتين
لهؤلاء المُقدِّرين هما `n_estimators` و `learning_rate`.

.. dropdown:: التصنيف

  :class:`GradientBoostingClassifier` يدعم التصنيف الثنائي ومتعدد
  الفئات.
  يوضح المثال التالي كيفية ملاءمة مُصنف تعزيز التدرج
  مع 100 جدعة قرار كمُتعلمين ضعفاء::

      >>> from sklearn.datasets import make_hastie_10_2
      >>> from sklearn.ensemble import GradientBoostingClassifier

      >>> X, y = make_hastie_10_2(random_state=0)
      >>> X_train, X_test = X[:2000], X[2000:]
      >>> y_train, y_test = y[:2000], y[2000:]

      >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=1.0,
      ...     max_depth=1, random_state=0).fit(X_train, y_train)
      >>> clf.score(X_test, y_test)
      0.913...

  يتم التحكم في عدد المُتعلمين الضعفاء (أي أشجار الانحدار) بواسطة
  المعلمة ``n_estimators``؛ :ref:`حجم كل شجرة
  <gradient_boosting_tree_size>` يمكن التحكم فيه إما عن طريق تعيين عمق الشجرة
  عبر ``max_depth`` أو عن طريق تعيين عدد العقد الورقية عبر
  ``max_leaf_nodes``. ``learning_rate`` هي معلمة فائقة في النطاق
  (0.0، 1.0] التي تتحكم في التجاوز عبر :ref:`الانكماش
  <gradient_boosting_shrinkage>`.

  .. note::

    يتطلب التصنيف مع أكثر من فئتين حث
    ``n_classes`` أشجار انحدار في كل تكرار،
    وبالتالي، فإن العدد الإجمالي للأشجار المُستحثة يساوي
    ``n_classes * n_estimators``. بالنسبة لمجموعات البيانات التي تحتوي على عدد كبير
    من الفئات، نوصي بشدة باستخدام
    :class:`HistGradientBoostingClassifier` كبديل لـ
    :class:`GradientBoostingClassifier`.

.. dropdown:: الانحدار

  :class:`GradientBoostingRegressor` يدعم عددًا من
  :ref:`دوال الخسارة المختلفة <gradient_boosting_loss>`
  للانحدار والتي يمكن تحديدها عبر الوسيطة
  ``loss``؛ دالة الخسارة الافتراضية للانحدار هي الخطأ التربيعي
  (``'squared_error'``).

  ::

      >>> import numpy as np
      >>> from sklearn.metrics import mean_squared_error
      >>> from sklearn.datasets import make_friedman1
      >>> from sklearn.ensemble import GradientBoostingRegressor

      >>> X, y = make_friedman1(n_samples=1200, random_state=0, noise=1.0)
      >>> X_train, X_test = X[:200], X[200:]
      >>> y_train, y_test = y[:200], y[200:]
      >>> est = GradientBoostingRegressor(
      ...     n_estimators=100, learning_rate=0.1, max_depth=1, random_state=0,
      ...     loss='squared_error'
      ... ).fit(X_train, y_train)
      >>> mean_squared_error(y_test, est.predict(X_test))
      5.00...

  يوضح الشكل أدناه نتائج تطبيق :class:`GradientBoostingRegressor`
  مع خسارة المربعات الصغرى و 500 مُتعلم أساسي على مجموعة بيانات مرض السكري
  (:func:`sklearn.datasets.load_diabetes`).
  يوضح الرسم البياني خطأ التدريب والاختبار في كل تكرار.
  يتم تخزين خطأ التدريب في كل تكرار في
  السمة `train_score_` لنموذج تعزيز التدرج.
  يمكن الحصول على خطأ الاختبار في كل تكرار
  عبر أسلوب :meth:`~GradientBoostingRegressor.staged_predict` الذي يُعيد
  مُولِّدًا يُعطي التنبؤات في كل مرحلة. يمكن استخدام الرسوم البيانية مثل هذه
  لتحديد العدد الأمثل للأشجار (أي ``n_estimators``) عن طريق الإيقاف المُبكر.

  .. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_gradient_boosting_regression_001.png
    :target: ../auto_examples/ensemble/plot_gradient_boosting_regression.html
    :align: center
    :scale: 75

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_regression.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_oob.py`

.. _gradient_boosting_warm_start:

ملاءمة مُتعلمين ضعفاء إضافيين
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

يدعم كل من :class:`GradientBoostingRegressor` و :class:`GradientBoostingClassifier`
``warm_start=True`` الذي يسمح لك بإضافة المزيد من المُقدِّرات إلى نموذج مُناسب
بالفعل.

::

  >>> import numpy as np
  >>> from sklearn.metrics import mean_squared_error
  >>> from sklearn.datasets import make_friedman1
  >>> from sklearn.ensemble import GradientBoostingRegressor

  >>> X, y = make_friedman1(n_samples=1200, random_state=0, noise=1.0)
  >>> X_train, X_test = X[:200], X[200:]
  >>> y_train, y_test = y[:200], y[200:]
  >>> est = GradientBoostingRegressor(
  ...     n_estimators=100, learning_rate=0.1, max_depth=1, random_state=0,
  ...      loss='squared_error'
  ... )
  >>> est = est.fit(X_train, y_train)  # ملاءمة مع 100 شجرة
  >>> mean_squared_error(y_test, est.predict(X_test))
  5.00...
  >>> _ = est.set_params(n_estimators=200, warm_start=True)  # تعيين warm_start وزيادة عدد الأشجار
  >>> _ = est.fit(X_train, y_train) # ملاءمة 100 شجرة إضافية إلى est
  >>> mean_squared_error(y_test, est.predict(X_test))
  3.84...

.. _gradient_boosting_tree_size:

التحكم في حجم الشجرة
^^^^^^^^^^^^^^^^^^^^^^^^^^

يُحدد حجم مُتعلمي أساس شجرة الانحدار مستوى تفاعلات المتغيرات
التي يمكن التقاطها بواسطة نموذج تعزيز التدرج. بشكل عام،
يمكن لشجرة بعمق ``h`` التقاط تفاعلات من الرتبة ``h``.
هناك طريقتان للتحكم في حجم أشجار الانحدار الفردية.

إذا حددت ``max_depth=h``، فسيتم تنمية أشجار ثنائية كاملة
بعمق ``h``. سيكون لهذه الأشجار (على الأكثر) ``2**h`` عقد ورقية
و ``2**h - 1`` عقد تقسيم.

بدلاً من ذلك، يمكنك التحكم في حجم الشجرة عن طريق تحديد عدد
العقد الورقية عبر المعلمة ``max_leaf_nodes``. في هذه الحالة،
سيتم تنمية الأشجار باستخدام بحث أفضل أولاً حيث يتم توسيع العقد ذات أعلى تحسين
في النجاسة أولاً.
شجرة ذات ``max_leaf_nodes=k`` تحتوي على ``k - 1`` عقد تقسيم وبالتالي يمكنها
نمذجة تفاعلات تصل إلى رتبة ``max_leaf_nodes - 1``.

وجدنا أن ``max_leaf_nodes=k`` تُعطي نتائج مُقارنة لـ ``max_depth=k-1``
ولكنها أسرع بشكل ملحوظ في التدريب على حساب خطأ تدريب أعلى قليلاً.
تقابل المعلمة ``max_leaf_nodes`` المتغير ``J`` في
الفصل الخاص بتعزيز التدرج في [Friedman2001]_ وترتبط بالمعلمة
``interaction.depth`` في حزمة gbm في R حيث ``max_leaf_nodes == interaction.depth + 1``.

.. _gradient_boosting_formulation:

الصيغة الرياضية
^^^^^^^^^^^^^^^^^^^^^^^^

نُقدم أولاً GBRT للانحدار، ثم نُفصِّل حالة
التصنيف.

.. dropdown:: الانحدار

  مُنحدرات GBRT هي نماذج مضافة يكون تنبؤها :math:`\hat{y}_i` لـ
  إدخال مُعين :math:`x_i` بالشكل التالي:

  .. math::

    \hat{y}_i = F_M(x_i) = \sum_{m=1}^{M} h_m(x_i)

  حيث :math:`h_m` هي مُقدِّرات تُسمى *مُتعلمين ضعفاء* في سياق
  التعزيز. يستخدم تعزيز شجرة التدرج :ref:`مُنحدرات شجرة القرار
  <tree>` ذات حجم ثابت كمُتعلمين ضعفاء. الثابت M يقابل
  معلمة `n_estimators`.

  على غرار خوارزميات التعزيز الأخرى، يتم بناء GBRT بطريقة جشعة:

  .. math::

    F_m(x) = F_{m-1}(x) + h_m(x),

  حيث يتم ملاءمة الشجرة المُضافة حديثًا :math:`h_m` من أجل تقليل مجموع
  الخسائر :math:`L_m`، بالنظر إلى المجموعة السابقة :math:`F_{m-1}`:

  .. math::

    h_m =  \arg\min_{h} L_m = \arg\min_{h} \sum_{i=1}^{n}
    l(y_i, F_{m-1}(x_i) + h(x_i)),

  حيث يتم تعريف :math:`l(y_i, F(x_i))` بواسطة معلمة `loss`، مُفصَّلة
  في القسم التالي.

  افتراضيًا، يتم اختيار النموذج الأولي :math:`F_{0}` كثابت
  يُقلل الخسارة: بالنسبة لخسارة المربعات الصغرى، هذا هو المتوسط التجريبي لـ
  القيم المستهدفة. يمكن أيضًا تحديد النموذج الأولي عبر وسيطة ``init``.

  باستخدام تقريب تايلور من الدرجة الأولى، يمكن
  تقريب قيمة :math:`l` على النحو التالي:

  .. math::

    l(y_i, F_{m-1}(x_i) + h_m(x_i)) \approx
    l(y_i, F_{m-1}(x_i))
    + h_m(x_i)
    \left[ \frac{\partial l(y_i, F(x_i))}{\partial F(x_i)} \right]_{F=F_{m - 1}}.

  .. note::

    باختصار، يقول تقريب تايلور من الدرجة الأولى أن
    :math:`l(z) \approx l(a) + (z - a) \frac{\partial l}{\partial z}(a)`.
    هنا، :math:`z` يقابل :math:`F_{m - 1}(x_i) + h_m(x_i)`، و
    :math:`a` يقابل :math:`F_{m-1}(x_i)`

  الكمية :math:`\left[ \frac{\partial l(y_i, F(x_i))}{\partial F(x_i)}
  \right]_{F=F_{m - 1}}` هي مُشتق الخسارة بالنسبة لمعلمتها
  الثانية، مُقيَّمة عند :math:`F_{m-1}(x)`. من السهل حسابها لـ
  أي :math:`F_{m - 1}(x_i)` مُعطى في شكل مُغلق لأن الخسارة
  قابلة للاشتقاق. سنُشير إليها بـ :math:`g_i`.

  بإزالة المُصطلحات الثابتة، لدينا:

  .. math::

    h_m \approx \arg\min_{h} \sum_{i=1}^{n} h(x_i) g_i

  يتم تقليل هذا إذا تم ملاءمة :math:`h(x_i)` للتنبؤ بقيمة
  تتناسب مع التدرج السالب :math:`-g_i`. لذلك، في كل
  تكرار، **يتم ملاءمة المُقدِّر** :math:`h_m` **للتنبؤ بالتدرجات
  السالبة للعينات**. يتم تحديث التدرجات في كل تكرار.
  يمكن اعتبار هذا نوعًا من النزول التدرجي في فضاء
  دالة.

  .. note::

    بالنسبة لبعض الخسائر، على سبيل المثال ``'absolute_error'`` حيث التدرجات
    هي :math:`\pm 1`، فإن القيم التي يتنبأ بها :math:`h_m` المُناسب ليست
    دقيقة بما يكفي: يمكن للشجرة إخراج قيم صحيحة فقط. نتيجة لذلك،
    يتم تعديل قيم أوراق الشجرة :math:`h_m` بمجرد ملاءمة الشجرة،
    بحيث تُقلل قيم الأوراق من الخسارة :math:`L_m`. التحديث يعتمد على
    الخسارة: بالنسبة لخسارة الخطأ المُطلق، يتم تحديث قيمة
    ورقة إلى متوسط العينات في تلك الورقة.

.. dropdown:: التصنيف

  يشبه تعزيز التدرج للتصنيف حالة الانحدار إلى حد كبير.
  ومع ذلك، فإن مجموع الأشجار :math:`F_M(x_i) = \sum_m h_m(x_i)` ليس
  متجانسًا مع التنبؤ: لا يمكن أن يكون فئة، لأن الأشجار تتنبأ
  بقيم مُستمرة.

  التعيين من القيمة :math:`F_M(x_i)` إلى فئة أو احتمال
  يعتمد على الخسارة. بالنسبة لخسارة السجل، يتم نمذجة احتمال أن
  :math:`x_i` ينتمي إلى الفئة الإيجابية على أنه :math:`p(y_i = 1 |
  x_i) = \sigma(F_M(x_i))` حيث :math:`\sigma` هي دالة السيني أو
  expit.

  بالنسبة للتصنيف متعدد الفئات، يتم بناء K شجرة (لفئات K) في كل
  من تكرارات :math:`M`. احتمال أن :math:`x_i` ينتمي إلى الفئة
  k مُنمذج على أنه softmax لقيم :math:`F_{M,k}(x_i)`.

  لاحظ أنه حتى بالنسبة لمهمة تصنيف، فإن المُقدِّر الفرعي :math:`h_m`
  لا يزال مُنحدِرًا، وليس مُصنِّفًا. هذا لأن المُقدِّرات الفرعية
  مُدرَّبة للتنبؤ بـ *تدرجات* (سالبة)، وهي دائمًا كميات
  مُستمرة.

.. _gradient_boosting_loss:

دوال الخسارة
^^^^^^^^^^^^^^

يتم دعم دوال الخسارة التالية ويمكن تحديدها باستخدام
معلمة ``loss``:

.. dropdown:: الانحدار

  * الخطأ التربيعي (``'squared_error'``): الخيار الطبيعي للانحدار
    نظرًا لخصائصه الحسابية المُتفوقة. النموذج الأولي
    مُعطى بمتوسط القيم المستهدفة.
  * الخطأ المُطلق (``'absolute_error'``): دالة خسارة قوية لـ
    الانحدار. النموذج الأولي مُعطى بمتوسط
    القيم المستهدفة.
  * Huber (``'huber'``): دالة خسارة قوية أخرى تجمع بين
    المربعات الصغرى وانحراف المُطلق الأقل؛ استخدم ``alpha`` لـ
    التحكم في الحساسية فيما يتعلق بالقيم المتطرفة (انظر [Friedman2001]_ لـ
    مزيد من التفاصيل).
  * المُكمِّم (``'quantile'``): دالة خسارة لانحدار المُكمِّم.
    استخدم ``0 < alpha < 1`` لتحديد المُكمِّم. يمكن استخدام دالة الخسارة هذه لإنشاء فترات تنبؤ
    (انظر :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_quantile.py`).

.. dropdown:: التصنيف

  * خسارة السجل الثنائية (``'log-loss'``): ذات الحدين
    دالة خسارة الاحتمالية السالبة للتصنيف الثنائي. إنها تُوفر
    تقديرات احتمالية. النموذج الأولي مُعطى بواسطة
    نسبة احتمالات السجل.
  * خسارة السجل متعددة الفئات (``'log-loss'``): متعددة الحدود
    دالة خسارة الاحتمالية السالبة للتصنيف متعدد الفئات مع
    ``n_classes`` فئات مُتبادلة الاستبعاد. إنها تُوفر
    تقديرات احتمالية. النموذج الأولي مُعطى بواسطة
    الاحتمال المُسبق لكل فئة. في كل تكرار ``n_classes``
    يجب إنشاء أشجار انحدار مما يجعل GBRT
    غير فعال لمجموعات البيانات التي تحتوي على عدد كبير من الفئات.
  * الخسارة الأسية (``'exponential'``): نفس دالة الخسارة
    مثل :class:`AdaBoostClassifier`. أقل قوة للأمثلة
    ذات التصنيف الخاطئ من ``'log-loss'``؛ لا يمكن استخدامها إلا للتصنيف
    الثنائي.

.. _gradient_boosting_shrinkage:

الانكماش عبر مُعدل التعلم
^^^^^^^^^^^^^^^^^^^^^^^^^^^

[Friedman2001]_ اقترح إستراتيجية تنظيم بسيطة تُغيّر مقياس
مساهمة كل مُتعلم ضعيف بواسطة عامل ثابت :math:`\nu`:

.. math::

    F_m(x) = F_{m-1}(x) + \nu h_m(x)

تُسمى المعلمة :math:`\nu` أيضًا **مُعدل التعلم** لأنها
تُغيّر مقياس طول الخطوة لإجراء النزول التدرجي؛ يمكن
تعيينها عبر معلمة ``learning_rate``.

تتفاعل المعلمة ``learning_rate`` بقوة مع المعلمة
``n_estimators``، عدد المُتعلمين الضعفاء المناسبين. القيم الأصغر
لـ ``learning_rate`` تتطلب أعدادًا أكبر من المُتعلمين الضعفاء للحفاظ على
خطأ تدريب ثابت. تُشير الأدلة التجريبية إلى أن القيم الصغيرة
لـ ``learning_rate`` تُفضل خطأ اختبار أفضل. [HTF]_
يوصي بتعيين مُعدل التعلم إلى ثابت صغير
(على سبيل المثال ``learning_rate <= 0.1``) واختيار ``n_estimators`` كبيرًا بما يكفي
لتطبيق الإيقاف المُبكر،
انظر :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_early_stopping.py`
لمناقشة أكثر تفصيلاً للتفاعل بين
``learning_rate`` و ``n_estimators`` انظر [R2007]_.

أخذ عينات فرعية
^^^^^^^^^^^^

[Friedman2002]_ اقترح تعزيز التدرج العشوائي، الذي يجمع بين تعزيز
التدرج ومتوسط التمهيد (التجميع). في كل تكرار
يتم تدريب المُصنف الأساسي على جزء ``subsample`` من
بيانات التدريب المتاحة. يتم رسم العينة الفرعية بدون استبدال.
قيمة نموذجية لـ ``subsample`` هي 0.5.

يوضح الشكل أدناه تأثير الانكماش وأخذ العينات الفرعية
على جودة ملاءمة النموذج. يمكننا أن نرى بوضوح أن الانكماش
يتفوق على عدم الانكماش. يمكن لأخذ العينات الفرعية مع الانكماش زيادة
دقة النموذج بشكل أكبر. من ناحية أخرى، فإن أخذ العينات الفرعية بدون انكماش
يؤدي بشكل سيئ.

.. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_gradient_boosting_regularization_001.png
   :target: ../auto_examples/ensemble/plot_gradient_boosting_regularization.html
   :align: center
   :scale: 75

إستراتيجية أخرى لتقليل التباين هي عن طريق أخذ عينات فرعية من الميزات
بشكل مُماثل للتقسيمات العشوائية في :class:`RandomForestClassifier`.
يمكن التحكم في عدد الميزات التي تم أخذ عينات فرعية منها عبر معلمة ``max_features``.

.. note:: يمكن أن يؤدي استخدام قيمة ``max_features`` صغيرة إلى تقليل وقت التشغيل بشكل كبير.

يسمح تعزيز التدرج العشوائي بحساب تقديرات خارج الحقيبة
لانحراف الاختبار عن طريق حساب التحسين في الانحراف على الأمثلة التي
لم يتم تضمينها في عينة التمهيد (أي أمثلة خارج الحقيبة).
يتم تخزين التحسينات في السمة `oob_improvement_`.
``oob_improvement_[i]`` يحمل التحسين من حيث الخسارة على عينات OOB
إذا أضفت المرحلة i إلى التنبؤات الحالية.
يمكن استخدام التقديرات خارج الحقيبة لاختيار النموذج، على سبيل المثال لتحديد
العدد الأمثل للتكرارات. عادةً ما تكون تقديرات OOB متشائمة جدًا، وبالتالي
نوصي باستخدام التحقق المتبادل بدلاً من ذلك واستخدام OOB فقط إذا كان التحقق
المتبادل يستغرق وقتًا طويلاً جدًا.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_regularization.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_oob.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_ensemble_oob.py`

تفسير مع أهمية الميزة
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

يمكن تفسير أشجار القرار الفردية بسهولة عن طريق ببساطة
تصور هيكل الشجرة. نماذج تعزيز التدرج، مع ذلك،
تتكون من مئات من أشجار الانحدار، وبالتالي لا يمكن تفسيرها بسهولة
عن طريق الفحص البصري للأشجار الفردية. لحسن الحظ،
تم اقتراح عدد من التقنيات لتلخيص وتفسير
نماذج تعزيز التدرج.

غالبًا لا تُساهم الميزات بالتساوي في التنبؤ باستجابة
الهدف؛ في كثير من الحالات، تكون غالبية الميزات في الواقع
غير ذات صلة.
عند تفسير نموذج، فإن السؤال الأول عادةً ما يكون: ما هي
تلك الميزات المهمة وكيف تُساهم في التنبؤ
باستجابة الهدف؟

تؤدي أشجار القرار الفردية اختيار الميزات بشكل جوهري عن طريق اختيار
نقاط تقسيم مناسبة. يمكن استخدام هذه المعلومات لقياس
أهمية كل ميزة؛ الفكرة الأساسية هي: كلما زاد استخدام
ميزة في نقاط تقسيم الشجرة، زادت أهمية تلك
الميزة. يمكن توسيع مفهوم الأهمية هذا ليشمل مجموعات شجرة القرار
عن طريق حساب متوسط أهمية الميزة القائمة على النجاسة لكل شجرة (انظر
:ref:`random_forest_feature_importance` لمزيد من التفاصيل).

يمكن الوصول إلى درجات أهمية الميزة لنموذج تعزيز التدرج المُناسب
عبر الخاصية ``feature_importances_``::

    >>> from sklearn.datasets import make_hastie_10_2
    >>> from sklearn.ensemble import GradientBoostingClassifier

    >>> X, y = make_hastie_10_2(random_state=0)
    >>> clf = GradientBoostingClassifier(n_estimators=100, learning_rate=1.0,
    ...     max_depth=1, random_state=0).fit(X, y)
    >>> clf.feature_importances_
    array([0.10..., 0.10..., 0.11..., ...

لاحظ أن حساب أهمية الميزة هذا يعتمد على الانتروبيا، و
إنه مُختلف عن :func:`sklearn.inspection.permutation_importance` الذي
يعتمد على تبديل الميزات.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_gradient_boosting_regression.py`

.. rubric:: المراجع

.. [Friedman2001] Friedman, J.H. (2001). :doi:`تقريب دالة جشع: آلة تعزيز التدرج <10.1214/aos/1013203451>`.
   Annals of Statistics, 29, 1189-1232.

.. [Friedman2002] Friedman, J.H. (2002). `تعزيز التدرج العشوائي.
   <https://statweb.stanford.edu/~jhf/ftp/stobst.pdf>`_.
   Computational Statistics & Data Analysis, 38, 367-378.

.. [R2007] G. Ridgeway (2006). `نماذج مُعززة مُعممة: دليل لحزمة gbm
   <https://cran.r-project.org/web/packages/gbm/vignettes/gbm.pdf>`_

.. _forest:

الغابات العشوائية ومجموعات الأشجار العشوائية الأخرى
===================================================

تتضمن وحدة :mod:`sklearn.ensemble` خوارزميتين للمتوسط بناءً على
:ref:`أشجار القرار <tree>` العشوائية: خوارزمية RandomForest
وأسلوب Extra-Trees. كلتا الخوارزميتين هما تقنيات اضطراب وتجميع
[B1998]_ مُصممة خصيصًا للأشجار. هذا يعني مجموعة مُتنوعة
من المُصنِّفات يتم إنشاؤها عن طريق إدخال العشوائية في مُنشئ
المُصنف. يتم إعطاء تنبؤ المجموعة على أنه متوسط
تنبؤ المُصنِّفات الفردية.

مثل المُصنِّفات الأخرى، يجب ملاءمة مُصنِّفات الغابات بمصفوفتين:
مصفوفة متفرقة أو كثيفة X ذات شكل ``(n_samples, n_features)``
تحمل عينات التدريب، ومصفوفة Y ذات شكل ``(n_samples,)``
تحمل القيم المستهدفة (تصنيفات الفئات) لعينات التدريب::

    >>> from sklearn.ensemble import RandomForestClassifier
    >>> X = [[0, 0], [1, 1]]
    >>> Y = [0, 1]
    >>> clf = RandomForestClassifier(n_estimators=10)
    >>> clf = clf.fit(X, Y)

مثل :ref:`أشجار القرار <tree>`، تمتد غابات الأشجار أيضًا إلى
:ref:`مشاكل الإخراج المتعدد <tree_multioutput>` (إذا كانت Y مصفوفة
ذات شكل ``(n_samples, n_outputs)``).

الغابات العشوائية
--------------

في الغابات العشوائية (انظر فئات :class:`RandomForestClassifier` و
:class:`RandomForestRegressor`)، يتم بناء كل شجرة في المجموعة
من عينة مرسومة مع استبدال (أي عينة تمهيد) من
مجموعة التدريب.

علاوة على ذلك، عند تقسيم كل عقدة أثناء بناء شجرة،
يتم إيجاد أفضل تقسيم من خلال بحث شامل عن قيم الميزات لـ
إما جميع ميزات الإدخال أو مجموعة فرعية عشوائية من الحجم ``max_features``.
(راجع :ref:`إرشادات ضبط المعلمات <random_forest_parameters>` لمزيد من التفاصيل.)

الغرض من هذين المصدرين للعشوائية هو تقليل تباين
مُقدِّر الغابة. في الواقع، تُظهر أشجار القرار الفردية عادةً تباينًا عاليًا وتميل إلى
التجاوز. ينتج عن العشوائية المحقونة في الغابات أشجار قرار ذات أخطاء تنبؤ
مفصولة إلى حد ما. عن طريق حساب متوسط تلك
التنبؤات، يمكن إلغاء بعض الأخطاء. تُحقق الغابات العشوائية تباينًا
مُنخفضًا من خلال دمج الأشجار المُتنوعة، وأحيانًا على حساب زيادة طفيفة في
التحيز. في الممارسة العملية، غالبًا ما يكون تقليل التباين كبيرًا، مما يؤدي إلى
نموذج أفضل بشكل عام.

على عكس المنشور الأصلي [B2001]_، فإن تطبيق scikit-learn
يجمع المُصنِّفات عن طريق حساب متوسط تنبؤها الاحتمالي،
بدلاً من السماح لكل مُصنف بالتصويت على فئة واحدة.

بديل تنافسي للغابات العشوائية هو
نماذج :ref:`histogram_based_gradient_boosting` (HGBT):

-  بناء الأشجار: تعتمد الغابات العشوائية عادةً على الأشجار العميقة (التي تُفرط
   في الملاءمة بشكل فردي) والتي تستخدم الكثير من موارد الحساب، حيث تتطلب
   العديد من التقسيمات وتقييمات التقسيمات المُرشحة. نماذج التعزيز
   تبني أشجارًا ضحلة (تُفرط في الملاءمة بشكل فردي) وهي أسرع في الملاءمة
   والتنبؤ.

-  التعزيز المتسلسل: في HGBT، يتم بناء أشجار القرار بالتسلسل،
   حيث يتم تدريب كل شجرة لتصحيح الأخطاء التي ارتكبتها الأشجار السابقة.
   هذا يسمح لهم بتحسين أداء النموذج بشكل متكرر باستخدام
   عدد قليل نسبيًا من الأشجار. على النقيض من ذلك، تستخدم الغابات العشوائية تصويت الأغلبية لـ
   التنبؤ بالنتيجة، الأمر الذي قد يتطلب عددًا أكبر من الأشجار لتحقيق
   نفس مستوى الدقة.

-  التجميع الفعال: يستخدم HGBT خوارزمية تجميع فعالة يمكنها التعامل مع
   مجموعات البيانات الكبيرة التي تحتوي على عدد كبير من الميزات. يمكن لخوارزمية التجميع
   مُعالجة البيانات مُسبقًا لتسريع بناء الشجرة اللاحق (انظر
   :ref:`لماذا هو أسرع <Why_it's_faster>`). على النقيض من ذلك، تطبيق scikit-learn
   للغابات العشوائية لا يستخدم التجميع ويعتمد على التقسيم
   الدقيق، والذي قد يكون مكلفًا من الناحية الحسابية.

بشكل عام، تعتمد التكلفة الحسابية لـ HGBT مقابل RF على الخصائص المحددة
لمجموعة البيانات ومهمة النمذجة. إنها لفكرة جيدة
تجربة كلا النموذجين ومقارنة أدائهما وكفاءتهما الحسابية
في مشكلتك المحددة لتحديد النموذج الأنسب.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_forest_hist_grad_boosting_comparison.py`

أشجار عشوائية للغاية
--------------------------

في الأشجار العشوائية للغاية (انظر فئات :class:`ExtraTreesClassifier`
و :class:`ExtraTreesRegressor`)، تذهب العشوائية خطوة أخرى إلى الأمام في طريقة حساب
التقسيمات. كما هو الحال في الغابات العشوائية، يتم استخدام
مجموعة فرعية عشوائية من الميزات المُرشحة، ولكن بدلاً من البحث عن
العتبات الأكثر تمييزًا، يتم رسم العتبات عشوائيًا لكل
ميزة مُرشحة ويتم اختيار أفضل هذه العتبات التي تم إنشاؤها عشوائيًا
كقاعدة تقسيم. هذا يسمح عادةً بتقليل تباين
النموذج أكثر قليلاً، على حساب زيادة طفيفة في
التحيز::

    >>> from sklearn.model_selection import cross_val_score
    >>> from sklearn.datasets import make_blobs
    >>> from sklearn.ensemble import RandomForestClassifier
    >>> from sklearn.ensemble import ExtraTreesClassifier
    >>> from sklearn.tree import DecisionTreeClassifier

    >>> X, y = make_blobs(n_samples=10000, n_features=10, centers=100,
    ...     random_state=0)

    >>> clf = DecisionTreeClassifier(max_depth=None, min_samples_split=2,
    ...     random_state=0)
    >>> scores = cross_val_score(clf, X, y, cv=5)
    >>> scores.mean()
    0.98...

    >>> clf = RandomForestClassifier(n_estimators=10, max_depth=None,
    ...     min_samples_split=2, random_state=0)
    >>> scores = cross_val_score(clf, X, y, cv=5)
    >>> scores.mean()
    0.999...

    >>> clf = ExtraTreesClassifier(n_estimators=10, max_depth=None,
    ...     min_samples_split=2, random_state=0)
    >>> scores = cross_val_score(clf, X, y, cv=5)
    >>> scores.mean() > 0.999
    True

.. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_forest_iris_001.png
    :target: ../auto_examples/ensemble/plot_forest_iris.html
    :align: center
    :scale: 75%

.. _random_forest_parameters:

المعلمات
----------

المعلمات الرئيسية التي يجب تعديلها عند استخدام هذه الأساليب هي ``n_estimators`` و
``max_features``. الأولى هي عدد الأشجار في الغابة. كلما زاد
كان ذلك أفضل، ولكن أيضًا كلما استغرق حسابه وقتًا أطول. بالإضافة إلى ذلك، لاحظ أن
النتائج ستتوقف عن التحسن بشكل كبير بعدد حرج من
الأشجار. الأخيرة هي حجم المجموعات الفرعية العشوائية من الميزات التي يجب مراعاتها
عند تقسيم عقدة. كلما انخفض، زاد تقليل التباين، ولكن
أيضًا زادت الزيادة في التحيز. قيم افتراضية تجريبية جيدة هي
``max_features=1.0`` أو بشكل مُكافئ ``max_features=None`` (مع مراعاة
جميع الميزات دائمًا بدلاً من مجموعة فرعية عشوائية) لمشاكل الانحدار، و
``max_features="sqrt"`` (باستخدام مجموعة فرعية عشوائية من الحجم ``sqrt(n_features)``)
لمهام التصنيف (حيث ``n_features`` هو عدد الميزات في
البيانات). القيمة الافتراضية لـ ``max_features=1.0`` تُعادل الأشجار المُجمَّعة
ويمكن تحقيق المزيد من العشوائية عن طريق تعيين قيم أصغر (على سبيل المثال 0.3
هو افتراضي نموذجي في الأدبيات). غالبًا ما يتم تحقيق نتائج جيدة عند
تعيين ``max_depth=None`` مع ``min_samples_split=2`` (أي
عند تطوير الأشجار بالكامل). ضع في اعتبارك أن هذه القيم
عادةً ما لا تكون مثالية، وقد تؤدي إلى نماذج تستهلك الكثير من ذاكرة الوصول العشوائي.
يجب دائمًا التحقق من أفضل قيم المعلمات بشكل متبادل. بالإضافة إلى ذلك، لاحظ
أنه في الغابات العشوائية، يتم استخدام عينات التمهيد افتراضيًا
(``bootstrap=True``) بينما الإستراتيجية الافتراضية للأشجار الإضافية هي استخدام
مجموعة البيانات بأكملها (``bootstrap=False``). عند استخدام أخذ عينات التمهيد،
يمكن تقدير خطأ التعميم على العينات المتروكة أو خارج الحقيبة.
يمكن تمكين ذلك عن طريق تعيين ``oob_score=True``.

.. note::

    حجم النموذج بالمعلمات الافتراضية هو :math:`O( M * N * log (N) )`،
    حيث :math:`M` هو عدد الأشجار و :math:`N` هو عدد العينات.
    لتقليل حجم النموذج، يمكنك تغيير هذه المعلمات:
    ``min_samples_split`` و ``max_leaf_nodes`` و ``max_depth`` و ``min_samples_leaf``.

التوازي
---------------

أخيرًا، تُظهر هذه الوحدة أيضًا البناء المتوازي للأشجار
والحساب المتوازي للتنبؤات من خلال المعلمة ``n_jobs``.
إذا كانت ``n_jobs=k``، فسيتم تقسيم الحسابات إلى
``k`` وظائف، وتشغيلها على ``k`` نوى للآلة. إذا كانت ``n_jobs=-1``،
فسيتم استخدام جميع النوى المتاحة على الآلة. لاحظ أنه بسبب
النفقات العامة للاتصال بين العمليات، قد لا يكون التسريع خطيًا
(أي أن استخدام ``k`` وظائف للأسف لن يكون أسرع ``k`` مرة).
لا يزال من الممكن تحقيق تسريع كبير عند بناء
عدد كبير من الأشجار، أو عندما يتطلب بناء شجرة واحدة قدرًا
لا بأس به من الوقت (على سبيل المثال، على مجموعات البيانات الكبيرة).

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_forest_iris.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_forest_importances_faces.py`
* :ref:`sphx_glr_auto_examples_miscellaneous_plot_multioutput_face_completion.py`

.. rubric:: المراجع

.. [B2001] L. Breiman, "الغابات العشوائية", Machine Learning, 45(1), 5-32, 2001.

.. [B1998] L. Breiman, "مُصنِّفات الأقواس", Annals of Statistics 1998.

* P. Geurts, D. Ernst., and L. Wehenkel, "أشجار
  عشوائية للغاية", Machine Learning, 63(1), 3-42, 2006.

.. _random_forest_feature_importance:

تقييم أهمية الميزة
-----------------------------

يمكن استخدام الرتبة النسبية (أي العمق) لميزة تُستخدم كعقدة قرار في
شجرة لتقييم الأهمية النسبية لتلك الميزة فيما يتعلق بـ
قابلية التنبؤ بالمتغير الهدف. تُساهم الميزات المُستخدمة في
أعلى الشجرة في قرار التنبؤ النهائي لـ
جزء أكبر من عينات الإدخال. **الجزء المتوقع من
العينات** التي تُساهم فيها يمكن استخدامه كتقدير لـ
**الأهمية النسبية للميزات**. في scikit-learn، يتم دمج جزء
العينات التي تُساهم فيها ميزة مع انخفاض النجاسة
من تقسيمها لإنشاء تقدير مُقيَّس للقدرة التنبؤية
لتلك الميزة.

عن طريق **حساب متوسط** تقديرات القدرة التنبؤية على عدة
أشجار عشوائية، يمكن للمرء **تقليل تباين** هذا التقدير واستخدامه لـ
اختيار الميزات. يُعرف هذا باسم متوسط الانخفاض في النجاسة، أو MDI.
راجع [L2014]_ لمزيد من المعلومات حول MDI وتقييم أهمية
الميزات مع الغابات العشوائية.

.. warning::

  أهمية الميزات القائمة على النجاسة المحسوبة على النماذج القائمة على الأشجار تعاني
  من عيبين يمكن أن يؤديا إلى استنتاجات مُضللة. أولاً، يتم
  حسابها على إحصاءات مُشتقة من مجموعة بيانات التدريب، وبالتالي **لا
  تُخبرنا بالضرورة عن الميزات الأكثر أهمية لإجراء تنبؤات جيدة على
  مجموعة بيانات مُخصصة للاختبار**. ثانيًا، **تُفضل
  الميزات ذات العدد الكبير من العناصر**، أي الميزات ذات العديد من القيم الفريدة.
  :ref:`permutation_importance` هو بديل لأهمية الميزات القائمة على النجاسة
  التي لا تعاني من هذه العيوب. يتم استكشاف هاتين الطريقتين لـ
الحصول على أهمية الميزات في:
:ref:`sphx_glr_auto_examples_inspection_plot_permutation_importance.py`.

يوضح المثال التالي تمثيلًا مُرمَّزًا بالألوان لـ
أهمية كل بكسل فردي لمهمة التعرف على الوجه باستخدام
نموذج :class:`ExtraTreesClassifier`.

.. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_forest_importances_faces_001.png
   :target: ../auto_examples/ensemble/plot_forest_importances_faces.html
   :align: center
   :scale: 75

في الممارسة العملية، يتم تخزين هذه التقديرات كسمة تُسمى
``feature_importances_`` على النموذج المُناسب. هذه مصفوفة ذات شكل
``(n_features,)`` قيمها موجبة ومجموعها 1.0. كلما ارتفعت
القيمة، زادت أهمية مساهمة الميزة المُطابقة
لدالة التنبؤ.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_forest_importances_faces.py`
* :ref:`sphx_glr_auto_examples_ensemble_plot_forest_importances.py`

.. rubric:: المراجع

.. [L2014] G. Louppe, :arxiv:`"فهم الغابات العشوائية: من النظرية إلى
   الممارسة" <1407.7502>`،
   أطروحة دكتوراه، جامعة لييج، 2014.

.. _random_trees_embedding:

تضمين الأشجار العشوائية تمامًا
------------------------------

:class:`RandomTreesEmbedding` يُطبق تحويلًا غير خاضع للإشراف لـ
البيانات. باستخدام غابة من الأشجار العشوائية تمامًا، :class:`RandomTreesEmbedding`
يُرمِّز البيانات بواسطة مؤشرات الأوراق التي تنتهي بها نقطة البيانات. هذا
الفهرس يتم ترميزه بعد ذلك بطريقة واحد من K، مما يؤدي إلى ترميز ثنائي متفرق عالي
الأبعاد.
يمكن حساب هذا الترميز بكفاءة عالية ويمكن استخدامه كأساس
لمهام التعلم الأخرى.
يمكن التأثير على حجم وتفرق الكود عن طريق اختيار عدد
الأشجار والحد الأقصى للعمق لكل شجرة. لكل شجرة في المجموعة،
يحتوي الترميز على إدخال واحد من واحد. حجم الترميز هو على الأكثر ``n_estimators * 2
** max_depth``، الحد الأقصى لعدد الأوراق في الغابة.

نظرًا لأن نقاط البيانات المجاورة من المرجح أن تقع داخل نفس ورقة
الشجرة، فإن التحويل يُجري تقديرًا ضمنيًا غير معلمي
للكثافة.

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_random_forest_embedding.py`

* :ref:`sphx_glr_auto_examples_manifold_plot_lle_digits.py` تُقارن تقنيات
  تقليل الأبعاد غير الخطية على الأرقام المكتوبة بخط اليد.

* :ref:`sphx_glr_auto_examples_ensemble_plot_feature_transformation.py` تُقارن
  تحويلات الميزات القائمة على الأشجار الخاضعة للإشراف وغير الخاضعة للإشراف.

.. seealso::

   يمكن أن تكون تقنيات :ref:`manifold` مفيدة أيضًا لاشتقاق تمثيلات غير خطية
   لمساحة الميزات، كما تُركز هذه الأساليب أيضًا على
   تقليل الأبعاد.

.. _tree_ensemble_warm_start:

ملاءمة أشجار إضافية
------------------------

RandomForest و Extra-Trees و مُقدِّرات :class:`RandomTreesEmbedding` تدعم جميعها
``warm_start=True`` الذي يسمح لك بإضافة المزيد من الأشجار إلى نموذج مُناسب
بالفعل.

::

  >>> from sklearn.datasets import make_classification
  >>> from sklearn.ensemble import RandomForestClassifier

  >>> X, y = make_classification(n_samples=100, random_state=1)
  >>> clf = RandomForestClassifier(n_estimators=10)
  >>> clf = clf.fit(X, y)  # ملاءمة مع 10 أشجار
  >>> len(clf.estimators_)
  10
  >>> # تعيين warm_start وزيادة عدد المُقدِّرات
  >>> _ = clf.set_params(n_estimators=20, warm_start=True)
  >>> _ = clf.fit(X, y) # ملاءمة 10 أشجار إضافية
  >>> len(clf.estimators_)
  20

عندما يتم تعيين ``random_state`` أيضًا، يتم أيضًا الحفاظ على الحالة العشوائية الداخلية
بين استدعاءات ``fit``. هذا يعني أن تدريب نموذج مرة واحدة مع ``n`` مُقدِّر هو
نفس بناء النموذج بشكل متكرر عبر استدعاءات ``fit`` متعددة، حيث
العدد النهائي للمُقدِّرات يساوي ``n``.

::

  >>> clf = RandomForestClassifier(n_estimators=20)  # تعيين `n_estimators` إلى 10 + 10
  >>> _ = clf.fit(X, y)  # ملاءمة `estimators_` ستكون نفس `clf` أعلاه

لاحظ أن هذا يختلف عن السلوك المعتاد لـ :term:`random_state` من حيث أنه *لا* يؤدي
إلى نفس النتيجة عبر استدعاءات مختلفة.

.. _bagging:

مُقدِّر التعريف التجميعي
======================

في خوارزميات المجموعات، تُشكِّل أساليب التجميع فئة من الخوارزميات التي تبني
العديد من مثيلات مُقدِّر الصندوق الأسود على مجموعات فرعية عشوائية من
مجموعة التدريب الأصلية ثم تجمع تنبؤاتها الفردية لتشكيل
تنبؤ نهائي. تُستخدم هذه الأساليب كطريقة لتقليل تباين
مُقدِّر أساسي (على سبيل المثال، شجرة قرار)، عن طريق إدخال العشوائية في
إجراء بنائه ثم صنع مجموعة منه. في كثير من الحالات،
تُشكِّل أساليب التجميع طريقة بسيطة للغاية للتحسين فيما يتعلق بـ
نموذج واحد، دون جعل من الضروري تكييف خوارزمية
الأساس الأساسية. نظرًا لأنها تُوفر طريقة لتقليل التجاوز، فإن أساليب التجميع تعمل
بشكل أفضل مع النماذج القوية والمعقدة (على سبيل المثال، أشجار القرار المُطوَّرة بالكامل)،
على عكس أساليب التعزيز التي تعمل عادةً بشكل أفضل مع النماذج الضعيفة (على سبيل المثال،
أشجار القرار الضحلة).

تأتي أساليب التجميع في العديد من النكهات ولكنها تختلف في الغالب عن بعضها البعض بالطريقة
التي ترسم بها مجموعات فرعية عشوائية من مجموعة التدريب:

* عندما يتم رسم مجموعات فرعية عشوائية من مجموعة البيانات كمجموعات فرعية عشوائية من
  العينات، تُعرف هذه الخوارزمية باسم اللصق [B1999]_.

* عندما يتم رسم العينات مع الاستبدال، تُعرف الطريقة باسم
  التجميع [B1996]_.

* عندما يتم رسم مجموعات فرعية عشوائية من مجموعة البيانات كمجموعات فرعية عشوائية من
  الميزات، تُعرف الطريقة باسم الفضاءات الفرعية العشوائية [H1998]_.

* أخيرًا، عندما يتم بناء المُقدِّرات الأساسية على مجموعات فرعية من كل من العينات و
  الميزات، تُعرف الطريقة باسم الرقع العشوائية [LG2012]_.

في scikit-learn، يتم تقديم أساليب التجميع كوحدة
مُقدِّر التعريف :class:`BaggingClassifier` (أو :class:`BaggingRegressor`)،
مع أخذ مُقدِّر مُحدد من قبل المستخدم كمدخلات جنبًا إلى جنب مع معلمات
تُحدد إستراتيجية رسم مجموعات فرعية عشوائية. على وجه الخصوص، ``max_samples``
و ``max_features`` يتحكمان في حجم المجموعات الفرعية (من حيث العينات و
الميزات)، بينما يتحكم ``bootstrap`` و ``bootstrap_features`` فيما إذا
كانت العينات والميزات مرسومة مع أو بدون استبدال. عند استخدام مجموعة فرعية
من العينات المتاحة، يمكن تقدير دقة التعميم مع
العينات خارج الحقيبة عن طريق تعيين ``oob_score=True``. على سبيل المثال،
يوضح المقتطف أدناه كيفية إنشاء مجموعة تجميع من
مُقدِّرات :class:`~sklearn.neighbors.KNeighborsClassifier`، كل منها مبني على مجموعات فرعية
عشوائية من 50% من العينات و 50% من الميزات.

    >>> from sklearn.ensemble import BaggingClassifier
    >>> from sklearn.neighbors import KNeighborsClassifier
    >>> bagging = BaggingClassifier(KNeighborsClassifier(),
    ...                             max_samples=0.5, max_features=0.5)

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_bias_variance.py`

.. rubric:: المراجع

.. [B1999] L. Breiman, "لصق أصوات صغيرة للتصنيف في قواعد بيانات
   كبيرة وعلى الإنترنت", Machine Learning, 36(1), 85-103, 1999.

.. [B1996] L. Breiman, "مُتنبِّئات التجميع", Machine Learning, 24(2),
   123-140, 1996.

.. [H1998] T. Ho, "أسلوب الفضاء الفرعي العشوائي لبناء غابات
   القرار", Pattern Analysis and Machine Intelligence, 20(8), 832-844, 1998.

.. [LG2012] G. Louppe and P. Geurts, "المجموعات على الرقع العشوائية",
   Machine Learning and Knowledge Discovery in Databases, 346-361, 2012.



.. _voting_classifier:

مُصنف التصويت
========================

الفكرة وراء :class:`VotingClassifier` هي دمج
مُصنِّفات التعلم الآلي المختلفة من الناحية النظرية واستخدام تصويت الأغلبية
أو متوسط الاحتمالات المتوقعة (التصويت الناعم) للتنبؤ بتصنيفات
الفئات.
يمكن أن يكون هذا المُصنف مفيدًا لمجموعة من النماذج ذات الأداء الجيد على حد سواء
من أجل موازنة نقاط ضعفها الفردية.


تصنيفات فئات الأغلبية (التصويت بالأغلبية / الصلب)
--------------------------------------------

في التصويت بالأغلبية، يكون تصنيف الفئة المتوقع لعينة مُعينة
هو تصنيف الفئة الذي يُمثِّل أغلبية (الوضع) تصنيفات الفئات
المتوقعة بواسطة كل مُصنف فردي.

على سبيل المثال، إذا كان التنبؤ لعينة مُعينة هو

- المُصنف 1 -> الفئة 1
- المُصنف 2 -> الفئة 1
- المُصنف 3 -> الفئة 2

فإن VotingClassifier (مع ``voting='hard'``) سيُصنف العينة
على أنها "الفئة 1" بناءً على تصنيف الفئة الأكثر شيوعًا.

في حالات التعادل، سيختار :class:`VotingClassifier` الفئة
بناءً على ترتيب الفرز التصاعدي. على سبيل المثال، في السيناريو التالي

- المُصنف 1 -> الفئة 2
- المُصنف 2 -> الفئة 1

سيتم تعيين تصنيف الفئة 1 للعينة.

الاستخدام
-----

يوضح المثال التالي كيفية ملاءمة مُصنف قاعدة الأغلبية::

   >>> from sklearn import datasets
   >>> from sklearn.model_selection import cross_val_score
   >>> from sklearn.linear_model import LogisticRegression
   >>> from sklearn.naive_bayes import GaussianNB
   >>> from sklearn.ensemble import RandomForestClassifier
   >>> from sklearn.ensemble import VotingClassifier

   >>> iris = datasets.load_iris()
   >>> X, y = iris.data[:, 1:3], iris.target

   >>> clf1 = LogisticRegression(random_state=1)
   >>> clf2 = RandomForestClassifier(n_estimators=50, random_state=1)
   >>> clf3 = GaussianNB()

   >>> eclf = VotingClassifier(
   ...     estimators=[('lr', clf1), ('rf', clf2), ('gnb', clf3)],
   ...     voting='hard')

   >>> for clf, label in zip([clf1, clf2, clf3, eclf], ['Logistic Regression', 'Random Forest', 'naive Bayes', 'Ensemble']):
   ...     scores = cross_val_score(clf, X, y, scoring='accuracy', cv=5)
   ...     print("Accuracy: %0.2f (+/- %0.2f) [%s]" % (scores.mean(), scores.std(), label))
   Accuracy: 0.95 (+/- 0.04) [Logistic Regression]
   Accuracy: 0.94 (+/- 0.04) [Random Forest]
   Accuracy: 0.91 (+/- 0.04) [naive Bayes]
   Accuracy: 0.95 (+/- 0.04) [Ensemble]


متوسط الاحتمالات الموزونة (التصويت الناعم)
--------------------------------------------

على عكس التصويت بالأغلبية (التصويت الصلب)، يُعيد التصويت الناعم
تصنيف الفئة كـ argmax لمجموع الاحتمالات المتوقعة.

يمكن تعيين أوزان مُحددة لكل مُصنف عبر معلمة ``weights``.
عندما يتم توفير الأوزان، يتم جمع احتمالات الفئة المتوقعة
لكل مُصنف، وضربها في وزن المُصنف،
وحساب متوسطها. ثم يتم اشتقاق تصنيف الفئة النهائي من تصنيف
الفئة ذات أعلى احتمال متوسط.

لتوضيح ذلك بمثال بسيط، لنفترض أن لدينا 3
مُصنِّفات ومشاكل تصنيف من 3 فئات حيث نُعيِّن
أوزانًا متساوية لجميع المُصنِّفات: w1 = 1، w2 = 1، w3 = 1.

ثم يتم حساب متوسط الاحتمالات الموزونة لعينة
على النحو التالي:

================  ==========    ==========      ==========
المُصنف          الفئة 1       الفئة 2         الفئة 3
================  ==========    ==========      ==========
المُصنف 1	  w1 * 0.2      w1 * 0.5        w1 * 0.3
المُصنف 2	  w2 * 0.6      w2 * 0.3        w2 * 0.1
المُصنف 3      w3 * 0.3      w3 * 0.4        w3 * 0.3
المتوسط الموزون  0.37	        0.4             0.23
================  ==========    ==========      ==========

هنا، تصنيف الفئة المتوقع هو 2، نظرًا لأنه يحتوي على
أعلى احتمال متوسط.

يوضح المثال التالي كيف يمكن أن تتغير مناطق القرار
عند استخدام :class:`VotingClassifier` ناعم بناءً على آلة متجه
دعم خطية وشجرة قرار ومُصنف أقرب جار K::

   >>> from sklearn import datasets
   >>> from sklearn.tree import DecisionTreeClassifier
   >>> from sklearn.neighbors import KNeighborsClassifier
   >>> from sklearn.svm import SVC
   >>> from itertools import product
   >>> from sklearn.ensemble import VotingClassifier

   >>> # تحميل بعض بيانات المثال
   >>> iris = datasets.load_iris()
   >>> X = iris.data[:, [0, 2]]
   >>> y = iris.target

   >>> # تدريب المُصنِّفات
   >>> clf1 = DecisionTreeClassifier(max_depth=4)
   >>> clf2 = KNeighborsClassifier(n_neighbors=7)
   >>> clf3 = SVC(kernel='rbf', probability=True)
   >>> eclf = VotingClassifier(estimators=[('dt', clf1), ('knn', clf2), ('svc', clf3)],
   ...                         voting='soft', weights=[2, 1, 2])

   >>> clf1 = clf1.fit(X, y)
   >>> clf2 = clf2.fit(X, y)
   >>> clf3 = clf3.fit(X, y)
   >>> eclf = eclf.fit(X, y)

.. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_voting_decision_regions_001.png
    :target: ../auto_examples/ensemble/plot_voting_decision_regions.html
    :align: center
    :scale: 75%

الاستخدام
-----

من أجل التنبؤ بتصنيفات الفئات بناءً على
احتمالات الفئة المتوقعة (يجب أن تدعم مُقدِّرات scikit-learn في VotingClassifier
أسلوب ``predict_proba``)::

   >>> eclf = VotingClassifier(
   ...     estimators=[('lr', clf1), ('rf', clf2), ('gnb', clf3)],
   ...     voting='soft'
   ... )

اختياريًا، يمكن توفير أوزان للمُصنِّفات الفردية::

   >>> eclf = VotingClassifier(
   ...     estimators=[('lr', clf1), ('rf', clf2), ('gnb', clf3)],
   ...     voting='soft', weights=[2,5,1]
   ... )

.. dropdown:: استخدام :class:`VotingClassifier` مع :class:`~sklearn.model_selection.GridSearchCV`

  يمكن أيضًا استخدام :class:`VotingClassifier` مع
  :class:`~sklearn.model_selection.GridSearchCV` من أجل ضبط
  المعلمات الفائقة للمُقدِّرات الفردية::

    >>> from sklearn.model_selection import GridSearchCV
    >>> clf1 = LogisticRegression(random_state=1)
    >>> clf2 = RandomForestClassifier(random_state=1)
    >>> clf3 = GaussianNB()
    >>> eclf = VotingClassifier(
    ...     estimators=[('lr', clf1), ('rf', clf2), ('gnb', clf3)],
    ...     voting='soft'
    ... )

    >>> params = {'lr__C': [1.0, 100.0], 'rf__n_estimators': [20, 200]}

    >>> grid = GridSearchCV(estimator=eclf, param_grid=params, cv=5)
    >>> grid = grid.fit(iris.data, iris.target)

.. _voting_regressor:

مُنحدِر التصويت
================

الفكرة وراء :class:`VotingRegressor` هي دمج مُنحدرات
التعلم الآلي المختلفة من الناحية النظرية وإعادة القيم المتوقعة
المتوسطة.
يمكن أن يكون هذا المُنحدِر مفيدًا لمجموعة من النماذج ذات الأداء الجيد
على حد سواء من أجل موازنة نقاط ضعفها الفردية.

الاستخدام
-----

يوضح المثال التالي كيفية ملاءمة VotingRegressor::

   >>> from sklearn.datasets import load_diabetes
   >>> from sklearn.ensemble import GradientBoostingRegressor
   >>> from sklearn.ensemble import RandomForestRegressor
   >>> from sklearn.linear_model import LinearRegression
   >>> from sklearn.ensemble import VotingRegressor

   >>> # تحميل بعض بيانات المثال
   >>> X, y = load_diabetes(return_X_y=True)

   >>> # تدريب المُصنِّفات
   >>> reg1 = GradientBoostingRegressor(random_state=1)
   >>> reg2 = RandomForestRegressor(random_state=1)
   >>> reg3 = LinearRegression()
   >>> ereg = VotingRegressor(estimators=[('gb', reg1), ('rf', reg2), ('lr', reg3)])
   >>> ereg = ereg.fit(X, y)

.. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_voting_regressor_001.png
    :target: ../auto_examples/ensemble/plot_voting_regressor.html
    :align: center
    :scale: 75%

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_voting_regressor.py`

.. _stacking:

التعميم المُكدَّس
======================

التعميم المُكدَّس هو أسلوب لدمج المُقدِّرات لتقليل
انحيازاتها [W1992]_ [HTF]_. بشكل أكثر تحديدًا، يتم تجميع تنبؤات كل مُقدِّر
فردي معًا واستخدامها كمدخلات لمُقدِّر نهائي لـ
حساب التنبؤ. يتم تدريب هذا المُقدِّر النهائي من خلال
التحقق المتبادل.

يُوفر :class:`StackingClassifier` و :class:`StackingRegressor` هذه
الإستراتيجيات التي يمكن تطبيقها على مشاكل التصنيف والانحدار.

تقابل معلمة `estimators` قائمة المُقدِّرات التي
يتم تجميعها معًا بالتوازي على بيانات الإدخال. يجب إعطاؤها كـ
قائمة من الأسماء والمُقدِّرات::

  >>> from sklearn.linear_model import RidgeCV, LassoCV
  >>> from sklearn.neighbors import KNeighborsRegressor
  >>> estimators = [('ridge', RidgeCV()),
  ...               ('lasso', LassoCV(random_state=42)),
  ...               ('knr', KNeighborsRegressor(n_neighbors=20,
  ...                                           metric='euclidean'))]

سيستخدم `final_estimator` تنبؤات `estimators` كمدخلات.
يجب أن يكون مُصنفًا أو مُنحدِرًا عند استخدام :class:`StackingClassifier`
أو :class:`StackingRegressor`، على التوالي::

  >>> from sklearn.ensemble import GradientBoostingRegressor
  >>> from sklearn.ensemble import StackingRegressor
  >>> final_estimator = GradientBoostingRegressor(
  ...     n_estimators=25, subsample=0.5, min_samples_leaf=25, max_features=1,
  ...     random_state=42)
  >>> reg = StackingRegressor(
  ...     estimators=estimators,
  ...     final_estimator=final_estimator)

لتدريب `estimators` و `final_estimator`، يجب استدعاء أسلوب `fit`
على بيانات التدريب::

  >>> from sklearn.datasets import load_diabetes
  >>> X, y = load_diabetes(return_X_y=True)
  >>> from sklearn.model_selection import train_test_split
  >>> X_train, X_test, y_train, y_test = train_test_split(X, y,
  ...                                                     random_state=42)
  >>> reg.fit(X_train, y_train)
  StackingRegressor(...)

أثناء التدريب، يتم ملاءمة `estimators` على بيانات التدريب الكاملة
`X_train`. سيتم استخدامها عند استدعاء `predict` أو `predict_proba`. لـ
التعميم وتجنب التجاوز، يتم تدريب `final_estimator` على
عينات خارجية باستخدام :func:`sklearn.model_selection.cross_val_predict` داخليًا.

بالنسبة لـ :class:`StackingClassifier`، لاحظ أن ناتج ``estimators``
يتم التحكم فيه بواسطة المعلمة `stack_method` ويتم استدعاؤه بواسطة كل مُقدِّر.
هذه المعلمة إما سلسلة، وهي أسماء أساليب المُقدِّر، أو `'auto'`
التي ستُحدد تلقائيًا أسلوبًا مُتاحًا اعتمادًا على
التوفر، ويتم اختبارها بترتيب التفضيل: `predict_proba` و
`decision_function` و `predict`.

يمكن استخدام :class:`StackingRegressor` و :class:`StackingClassifier` كـ
أي مُنحدِر أو مُصنف آخر، يُظهِر أسلوب `predict` أو `predict_proba` أو
`decision_function`، على سبيل المثال::

   >>> y_pred = reg.predict(X_test)
   >>> from sklearn.metrics import r2_score
   >>> print('R2 score: {:.2f}'.format(r2_score(y_test, y_pred)))
   R2 score: 0.53

لاحظ أنه من الممكن أيضًا الحصول على ناتج `estimators`
المُكدَّس باستخدام أسلوب `transform`::

  >>> reg.transform(X_test[:5])
  array([[142..., 138..., 146...],
         [179..., 182..., 151...],
         [139..., 132..., 158...],
         [286..., 292..., 225...],
         [126..., 124..., 164...]])

عمليًا، يتنبأ مُتنبئ التكديس بنفس جودة أفضل مُتنبئ للطبقة
الأساسية، بل ويتفوق عليه في بعض الأحيان من خلال الجمع بين نقاط القوة المختلفة
لهؤلاء المُتنبئين. ومع ذلك، فإن تدريب مُتنبئ التكديس
مكلف من الناحية الحسابية.

.. note::
   بالنسبة لـ :class:`StackingClassifier`، عند استخدام `stack_method_='predict_proba'`،
   يتم إسقاط العمود الأول عندما تكون المشكلة مشكلة تصنيف
   ثنائية. في الواقع، كلا عمودي الاحتمال المتوقعين بواسطة كل مُقدِّر
   متساويان تمامًا.

.. note::
   يمكن تحقيق طبقات تكديس متعددة عن طريق تعيين `final_estimator` إلى
   :class:`StackingClassifier` أو :class:`StackingRegressor`::

    >>> final_layer_rfr = RandomForestRegressor(
    ...     n_estimators=10, max_features=1, max_leaf_nodes=5,random_state=42)
    >>> final_layer_gbr = GradientBoostingRegressor(
    ...     n_estimators=10, max_features=1, max_leaf_nodes=5,random_state=42)
    >>> final_layer = StackingRegressor(
    ...     estimators=[('rf', final_layer_rfr),
    ...                 ('gbrt', final_layer_gbr)],
    ...     final_estimator=RidgeCV()
    ...     )
    >>> multi_layer_regressor = StackingRegressor(
    ...     estimators=[('ridge', RidgeCV()),
    ...                 ('lasso', LassoCV(random_state=42)),
    ...                 ('knr', KNeighborsRegressor(n_neighbors=20,
    ...                                             metric='euclidean'))],
    ...     final_estimator=final_layer
    ... )
    >>> multi_layer_regressor.fit(X_train, y_train)
    StackingRegressor(...)
    >>> print('R2 score: {:.2f}'
    ...       .format(multi_layer_regressor.score(X_test, y_test)))
    R2 score: 0.53

.. rubric:: المراجع

.. [W1992] Wolpert, David H. "التعميم المُكدَّس." Neural networks 5.2
   (1992): 241-259.



.. _adaboost:

AdaBoost
========

تتضمن الوحدة :mod:`sklearn.ensemble` خوارزمية التعزيز الشهيرة
AdaBoost، التي تم تقديمها في عام 1995 بواسطة Freund و Schapire [FS1995]_.

المبدأ الأساسي لـ AdaBoost هو ملاءمة تسلسل من المُتعلمين الضعفاء (أي
النماذج التي هي أفضل قليلاً فقط من التخمين العشوائي، مثل أشجار القرار
الصغيرة) على إصدارات مُعدلة بشكل متكرر من البيانات. ثم يتم دمج
التنبؤات من جميعها من خلال تصويت الأغلبية الموزون (أو المجموع) لـ
إنتاج التنبؤ النهائي. تتكون تعديلات البيانات في كل ما يسمى بتكرار
التعزيز من تطبيق أوزان :math:`w_1` و :math:`w_2` و ... و :math:`w_N`
على كل من عينات التدريب. في البداية، يتم تعيين جميع هذه الأوزان إلى
:math:`w_i = 1/N`، بحيث تُدرِّب الخطوة الأولى ببساطة مُتعلمًا ضعيفًا على
البيانات الأصلية. لكل تكرار لاحق، يتم
تعديل أوزان العينة بشكل فردي ويتم إعادة تطبيق خوارزمية التعلم على البيانات
المُعاد وزنها. في خطوة مُعينة، عينات التدريب التي تم التنبؤ بها بشكل غير صحيح
بواسطة النموذج المُعزز المُستحث في الخطوة السابقة تزداد أوزانها،
بينما تتناقص الأوزان بالنسبة لتلك التي تم التنبؤ بها بشكل صحيح. مع
استمرار التكرارات، تتلقى الأمثلة التي يصعب التنبؤ بها
تأثيرًا متزايدًا باستمرار. وبالتالي، يُجبر كل مُتعلم ضعيف لاحق على
التركيز على الأمثلة التي فاتها المُتعلمون السابقون في التسلسل
[HTF]_.

.. figure:: ../auto_examples/ensemble/images/sphx_glr_plot_adaboost_multiclass_001.png
   :target: ../auto_examples/ensemble/plot_adaboost_multiclass.html
   :align: center
   :scale: 75

يمكن استخدام AdaBoost لكل من مشاكل التصنيف والانحدار:

- للتصنيف متعدد الفئات، :class:`AdaBoostClassifier` يُطبق
  AdaBoost.SAMME [ZZRH2009]_.

- للانحدار، :class:`AdaBoostRegressor` يُطبق AdaBoost.R2 [D1997]_.

الاستخدام
-----

يوضح المثال التالي كيفية ملاءمة مُصنف AdaBoost مع 100 مُتعلم
ضعيف::

    >>> from sklearn.model_selection import cross_val_score
    >>> from sklearn.datasets import load_iris
    >>> from sklearn.ensemble import AdaBoostClassifier

    >>> X, y = load_iris(return_X_y=True)
    >>> clf = AdaBoostClassifier(n_estimators=100, algorithm="SAMME",)
    >>> scores = cross_val_score(clf, X, y, cv=5)
    >>> scores.mean()
    0.9...

يتم التحكم في عدد المُتعلمين الضعفاء بواسطة المعلمة ``n_estimators``.
تتحكم معلمة ``learning_rate`` في مساهمة المُتعلمين الضعفاء في
المجموعة النهائية. افتراضيًا، المُتعلمون الضعفاء هم جذوع القرار. يمكن تحديد
مُتعلمين ضعفاء مُختلفين من خلال المعلمة ``estimator``.
المعلمات الرئيسية التي يجب ضبطها للحصول على نتائج جيدة هي ``n_estimators`` و
تعقيد المُقدِّرات الأساسية (على سبيل المثال، عمقها ``max_depth`` أو
الحد الأدنى لعدد العينات المطلوب للنظر في تقسيم ``min_samples_split``).

.. rubric:: أمثلة

* :ref:`sphx_glr_auto_examples_ensemble_plot_adaboost_multiclass.py` يُظهر أداء
  AdaBoost على مشكلة متعددة الفئات.

* :ref:`sphx_glr_auto_examples_ensemble_plot_adaboost_twoclass.py` يُظهر حدود القرار
  وقيم دالة القرار لمشكلة ثنائية الفئات غير قابلة للفصل خطيًا
  باستخدام AdaBoost-SAMME.

* :ref:`sphx_glr_auto_examples_ensemble_plot_adaboost_regression.py` يُوضح الانحدار
  مع خوارزمية AdaBoost.R2.

.. rubric:: المراجع

.. [FS1995] Y. Freund, and R. Schapire, "تعميم نظري للقرار
   للتعلم على الإنترنت وتطبيق على التعزيز", 1997.

.. [ZZRH2009] J. Zhu, H. Zou, S. Rosset, T. Hastie. "AdaBoost متعدد الفئات", 2009.

.. [D1997] H. Drucker. "تحسين المُنحدرات باستخدام تقنيات التعزيز", 1997.

.. [HTF] T. Hastie, R. Tibshirani and J. Friedman, "عناصر التعلم الإحصائي
   الطبعة الثانية", Springer, 2009.


