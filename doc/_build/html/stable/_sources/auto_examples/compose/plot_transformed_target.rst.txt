
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/compose/plot_transformed_target.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_compose_plot_transformed_target.py>`
        to download the full example code. or to run this example in your browser via JupyterLite or Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_compose_plot_transformed_target.py:


=========================================
تأثير تحويل الأهداف في نموذج الانحدار
=========================================

في هذا المثال، نقدم نظرة عامة على
:class:`~sklearn.compose.TransformedTargetRegressor`. نستخدم مثالين
لتوضيح فائدة تحويل الأهداف قبل تعلم نموذج الانحدار الخطي. يستخدم المثال الأول بيانات اصطناعية بينما يعتمد المثال
الثاني على مجموعة بيانات إسكان إيمز.

.. GENERATED FROM PYTHON SOURCE LINES 12-29

.. code-block:: Python


    # المؤلفون: مطوري سكايت-ليرن
    # معرف الترخيص: BSD-3-Clause

    from sklearn.preprocessing import QuantileTransformer
    from sklearn.preprocessing import quantile_transform
    from sklearn.datasets import fetch_openml
    from sklearn.metrics import PredictionErrorDisplay
    from sklearn.linear_model import RidgeCV
    from sklearn.compose import TransformedTargetRegressor
    from sklearn.metrics import median_absolute_error, r2_score
    from sklearn.model_selection import train_test_split
    import matplotlib.pyplot as plt
    from sklearn.datasets import make_regression
    import numpy as np
    print(__doc__)








.. GENERATED FROM PYTHON SOURCE LINES 30-44

مثال اصطناعي
#################

يتم إنشاء مجموعة بيانات تراجعية عشوائية اصطناعية. يتم تعديل الأهداف ``y``
من خلال:

1. ترجمة جميع الأهداف بحيث تكون
   جميع الإدخالات غير سلبية (بإضافة القيمة المطلقة لأصغر ``y``) و
2. تطبيق دالة أسية للحصول على أهداف غير خطية
   والتي لا يمكن ملاءمتها باستخدام نموذج خطي بسيط.

لذلك، سيتم استخدام دالة لوغاريتمية (`np.log1p`) ودالة أسية
(`np.expm1`) لتحويل الأهداف قبل تدريب نموذج الانحدار الخطي
واستخدامه للتنبؤ.

.. GENERATED FROM PYTHON SOURCE LINES 44-50

.. code-block:: Python



    X, y = make_regression(n_samples=10_000, noise=100, random_state=0)
    y = np.expm1((y + abs(y.min())) / 200)
    y_trans = np.log1p(y)








.. GENERATED FROM PYTHON SOURCE LINES 51-53

فيما يلي، نرسم دالة الكثافة الاحتمالية للأهداف
قبل وبعد تطبيق الدوال اللوغاريتمية.

.. GENERATED FROM PYTHON SOURCE LINES 53-73

.. code-block:: Python



    f, (ax0, ax1) = plt.subplots(1, 2)

    ax0.hist(y, bins=100, density=True)
    ax0.set_xlim([0, 2000])
    ax0.set_ylabel("Probability")
    ax0.set_xlabel("Target")
    ax0.set_title("Target distribution")

    ax1.hist(y_trans, bins=100, density=True)
    ax1.set_ylabel("Probability")
    ax1.set_xlabel("Target")
    ax1.set_title("Transformed target distribution")

    f.suptitle("Synthetic data", y=1.05)
    plt.tight_layout()

    X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)




.. image-sg:: /auto_examples/compose/images/sphx_glr_plot_transformed_target_001.png
   :alt: Synthetic data, Target distribution, Transformed target distribution
   :srcset: /auto_examples/compose/images/sphx_glr_plot_transformed_target_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 74-78

في البداية، سيتم تطبيق نموذج خطي على الأهداف الأصلية. بسبب
عدم الخطية، لن يكون النموذج المدرب دقيقاً خلال
التنبؤ. بعد ذلك، يتم استخدام دالة لوغاريتمية لخطية الأهداف، مما يسمح بتنبؤ أفضل حتى مع نموذج خطي مشابه كما
تم الإبلاغ عنه بواسطة الخطأ المتوسط المطلق (MedAE).

.. GENERATED FROM PYTHON SOURCE LINES 78-87

.. code-block:: Python



    def compute_score(y_true, y_pred):
        return {
            "R2": f"{r2_score(y_true, y_pred):.3f}",
            "MedAE": f"{median_absolute_error(y_true, y_pred):.3f}",
        }









.. GENERATED FROM PYTHON SOURCE LINES 88-129

.. code-block:: Python


    f, (ax0, ax1) = plt.subplots(1, 2, sharey=True)

    ridge_cv = RidgeCV().fit(X_train, y_train)
    y_pred_ridge = ridge_cv.predict(X_test)

    ridge_cv_with_trans_target = TransformedTargetRegressor(
        regressor=RidgeCV(), func=np.log1p, inverse_func=np.expm1
    ).fit(X_train, y_train)
    y_pred_ridge_with_trans_target = ridge_cv_with_trans_target.predict(X_test)

    PredictionErrorDisplay.from_predictions(
        y_test,
        y_pred_ridge,
        kind="actual_vs_predicted",
        ax=ax0,
        scatter_kwargs={"alpha": 0.5},
    )
    PredictionErrorDisplay.from_predictions(
        y_test,
        y_pred_ridge_with_trans_target,
        kind="actual_vs_predicted",
        ax=ax1,
        scatter_kwargs={"alpha": 0.5},
    )

    # Add the score in the legend of each axis
    for ax, y_pred in zip([ax0, ax1], [y_pred_ridge, y_pred_ridge_with_trans_target]):
        for name, score in compute_score(y_test, y_pred).items():
            ax.plot([], [], " ", label=f"{name}={score}")
        ax.legend(loc="upper left")

    ax0.set_title("Ridge regression \n without target transformation")
    ax1.set_title("Ridge regression \n with target transformation")
    f.suptitle("Synthetic data", y=1.05)
    plt.tight_layout()
    ax0.set_title("Ridge regression \n without target transformation")
    ax1.set_title("Ridge regression \n with target transformation")
    f.suptitle("Synthetic data", y=1.05)
    plt.tight_layout()




.. image-sg:: /auto_examples/compose/images/sphx_glr_plot_transformed_target_002.png
   :alt: Synthetic data, Ridge regression   without target transformation, Ridge regression   with target transformation
   :srcset: /auto_examples/compose/images/sphx_glr_plot_transformed_target_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 130-136

مجموعة بيانات واقعية
###################

بطريقة مماثلة، يتم استخدام مجموعة بيانات إسكان إيمز لإظهار التأثير
لتحويل الأهداف قبل تعلم نموذج. في هذا المثال،
الهدف المراد التنبؤ به هو سعر البيع لكل منزل.

.. GENERATED FROM PYTHON SOURCE LINES 136-148

.. code-block:: Python


    ames = fetch_openml(name="house_prices", as_frame=True)
    # Keep only numeric columns
    X = ames.data.select_dtypes(np.number)
    # Remove columns with NaN or Inf values
    X = X.drop(columns=["LotFrontage", "GarageYrBlt", "MasVnrArea"])
    # Let the price be in k$
    y = ames.target / 1000
    y_trans = quantile_transform(
        y.to_frame(), n_quantiles=900, output_distribution="normal", copy=True
    ).squeeze()








.. GENERATED FROM PYTHON SOURCE LINES 149-152

يتم استخدام :class:`~sklearn.preprocessing.QuantileTransformer` لتطبيع
توزيع الهدف قبل تطبيق
:class:`~sklearn.linear_model.RidgeCV` model.

.. GENERATED FROM PYTHON SOURCE LINES 152-167

.. code-block:: Python

    f, (ax0, ax1) = plt.subplots(1, 2)

    ax0.hist(y, bins=100, density=True)
    ax0.set_ylabel("Probability")
    ax0.set_xlabel("Target")
    ax0.set_title("Target distribution")

    ax1.hist(y_trans, bins=100, density=True)
    ax1.set_ylabel("Probability")
    ax1.set_xlabel("Target")
    ax1.set_title("Transformed target distribution")

    f.suptitle("Ames housing data: selling price", y=1.05)
    plt.tight_layout()




.. image-sg:: /auto_examples/compose/images/sphx_glr_plot_transformed_target_003.png
   :alt: Ames housing data: selling price, Target distribution, Transformed target distribution
   :srcset: /auto_examples/compose/images/sphx_glr_plot_transformed_target_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 168-170

.. code-block:: Python

    X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1)








.. GENERATED FROM PYTHON SOURCE LINES 171-177

تأثير المحول أضعف من تأثير البيانات الاصطناعية. ومع ذلك،
يؤدي التحول إلى زيادة في :math:`R^2` وانخفاض كبير
في MedAE. يأخذ مخطط البقايا (القيمة المستهدفة المتنبأ بها - القيمة المستهدفة الحقيقية مقابل القيمة المستهدفة المتنبأ بها)
بدون تحويل الهدف شكلًا منحنيًا، على شكل "ابتسامة عكسية"
بسبب قيم البقايا التي تختلف حسب قيمة الهدف المتنبأ به. مع تحويل الهدف، يكون الشكل أكثر خطية مما يشير
إلى ملاءمة أفضل للنموذج.

.. GENERATED FROM PYTHON SOURCE LINES 177-236

.. code-block:: Python


    f, (ax0, ax1) = plt.subplots(2, 2, sharey="row", figsize=(6.5, 8))

    ridge_cv = RidgeCV().fit(X_train, y_train)
    y_pred_ridge = ridge_cv.predict(X_test)

    ridge_cv_with_trans_target = TransformedTargetRegressor(
        regressor=RidgeCV(),
        transformer=QuantileTransformer(
            n_quantiles=900, output_distribution="normal"),
    ).fit(X_train, y_train)
    y_pred_ridge_with_trans_target = ridge_cv_with_trans_target.predict(X_test)

    # plot the actual vs predicted values
    PredictionErrorDisplay.from_predictions(
        y_test,
        y_pred_ridge,
        kind="actual_vs_predicted",
        ax=ax0[0],
        scatter_kwargs={"alpha": 0.5},
    )
    PredictionErrorDisplay.from_predictions(
        y_test,
        y_pred_ridge_with_trans_target,
        kind="actual_vs_predicted",
        ax=ax0[1],
        scatter_kwargs={"alpha": 0.5},
    )

    # Add the score in the legend of each axis
    for ax, y_pred in zip([ax0[0], ax0[1]], [y_pred_ridge, y_pred_ridge_with_trans_target]):
        for name, score in compute_score(y_test, y_pred).items():
            ax.plot([], [], " ", label=f"{name}={score}")
        ax.legend(loc="upper left")

    ax0[0].set_title("Ridge regression \n without target transformation")
    ax0[1].set_title("Ridge regression \n with target transformation")

    # plot the residuals vs the predicted values
    PredictionErrorDisplay.from_predictions(
        y_test,
        y_pred_ridge,
        kind="residual_vs_predicted",
        ax=ax1[0],
        scatter_kwargs={"alpha": 0.5},
    )
    PredictionErrorDisplay.from_predictions(
        y_test,
        y_pred_ridge_with_trans_target,
        kind="residual_vs_predicted",
        ax=ax1[1],
        scatter_kwargs={"alpha": 0.5},
    )
    ax1[0].set_title("Ridge regression \n without target transformation")
    ax1[1].set_title("Ridge regression \n with target transformation")

    f.suptitle("Ames housing data: selling price", y=1.05)
    plt.tight_layout()
    plt.show()



.. image-sg:: /auto_examples/compose/images/sphx_glr_plot_transformed_target_004.png
   :alt: Ames housing data: selling price, Ridge regression   without target transformation, Ridge regression   with target transformation, Ridge regression   without target transformation, Ridge regression   with target transformation
   :srcset: /auto_examples/compose/images/sphx_glr_plot_transformed_target_004.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.644 seconds)


.. _sphx_glr_download_auto_examples_compose_plot_transformed_target.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/scikit-learn/scikit-learn/main?urlpath=lab/tree/notebooks/auto_examples/compose/plot_transformed_target.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: lite-badge

      .. image:: images/jupyterlite_badge_logo.svg
        :target: ../../lite/lab/index.html?path=auto_examples/compose/plot_transformed_target.ipynb
        :alt: Launch JupyterLite
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_transformed_target.ipynb <plot_transformed_target.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_transformed_target.py <plot_transformed_target.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_transformed_target.zip <plot_transformed_target.zip>`


.. include:: plot_transformed_target.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
