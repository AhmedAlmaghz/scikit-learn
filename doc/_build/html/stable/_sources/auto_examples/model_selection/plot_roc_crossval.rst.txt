
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/model_selection/plot_roc_crossval.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_model_selection_plot_roc_crossval.py>`
        to download the full example code. or to run this example in your browser via JupyterLite or Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_model_selection_plot_roc_crossval.py:


=============================================================
منحنى المستقبل التشغيلي (ROC) مع التحقق المتقاطع
=============================================================

يقدم هذا المثال كيفية تقدير وتصوير تباين مقياس منحنى المستقبل التشغيلي (ROC) باستخدام التحقق المتقاطع.

عادةً ما تتميز منحنيات ROC بمعدل الإيجابيات الحقيقية (TPR) على محور Y، ومعدل الإيجابيات الخاطئة (FPR) على محور X. وهذا يعني أن الركن العلوي الأيسر من الرسم البياني هو النقطة "المثالية" - حيث يكون معدل الإيجابيات الخاطئة صفرًا، ومعدل الإيجابيات الحقيقية واحدًا. وهذا ليس واقعيًا جدًا، ولكنه يعني أن المساحة الأكبر تحت المنحنى (AUC) تكون أفضل عادةً. كما أن "انحدار" منحنيات ROC مهم أيضًا، حيث أنه من المثالي تعظيم معدل الإيجابيات الحقيقية مع تقليل معدل الإيجابيات الخاطئة.

يوضح هذا المثال استجابة ROC لمجموعات بيانات مختلفة، تم إنشاؤها من التحقق المتقاطع K-fold. وبأخذ جميع هذه المنحنيات، يمكن حساب متوسط AUC، ورؤية تباين المنحنى عندما يتم تقسيم مجموعة التدريب إلى مجموعات فرعية مختلفة. وهذا يُظهر تقريبًا كيف يتأثر ناتج التصنيف بالتغيرات في بيانات التدريب، وكيف تختلف التقسيمات التي يولدها التحقق المتقاطع K-fold عن بعضها البعض.

.. note::

    راجع :ref:`sphx_glr_auto_examples_model_selection_plot_roc.py` لمكمل هذا المثال الذي يوضح استراتيجيات المتوسط لتعميم المقاييس للتصنيفات متعددة الفئات.

.. GENERATED FROM PYTHON SOURCE LINES 16-20

.. code-block:: Python


    # المؤلفون: مطوري scikit-learn
    # معرف الترخيص: BSD-3-Clause








.. GENERATED FROM PYTHON SOURCE LINES 21-32

تحميل وإعداد البيانات
=====================

نحن نستورد :ref:`iris_dataset` الذي يحتوي على 3 فئات، كل منها
يقابل نوعًا من نبات الزنبق. يمكن فصل فئة واحدة خطيًا
عن الفئتين الأخريين؛ الفئتان الأخريان **ليستا** قابلتين للفصل الخطي عن بعضهما البعض.

في ما يلي، نقوم بتجنيس مجموعة البيانات عن طريق إسقاط فئة "virginica"
(`class_id=2`). وهذا يعني أن فئة "versicolor" (`class_id=1`)
تعتبر الفئة الإيجابية و"setosa" كالفئة السلبية
(`class_id=0`).

.. GENERATED FROM PYTHON SOURCE LINES 32-43

.. code-block:: Python


    import numpy as np

    from sklearn.datasets import load_iris

    iris = load_iris()
    target_names = iris.target_names
    X, y = iris.data, iris.target
    X, y = X[y != 2], y[y != 2]
    n_samples, n_features = X.shape








.. GENERATED FROM PYTHON SOURCE LINES 44-45

نضيف أيضًا ميزات عشوائية لجعل المشكلة أكثر صعوبة.

.. GENERATED FROM PYTHON SOURCE LINES 45-48

.. code-block:: Python

    random_state = np.random.RandomState(0)
    X = np.concatenate([X, random_state.randn(n_samples, 200 * n_features)], axis=1)








.. GENERATED FROM PYTHON SOURCE LINES 49-55

التصنيف وتحليل ROC
-------------------------------

هنا نقوم بتشغيل مصنف :class:`~sklearn.svm.SVC` مع التحقق المتقاطع ورسم
منحنيات ROC لكل طية. لاحظ أن الخط الأساسي لتحديد مستوى الفرصة
(منحنى ROC المتقطع) هو مصنف سيقوم دائمًا بالتنبؤ بالفئة الأكثر تكرارًا.

.. GENERATED FROM PYTHON SOURCE LINES 55-119

.. code-block:: Python


    import matplotlib.pyplot as plt

    from sklearn import svm
    from sklearn.metrics import RocCurveDisplay, auc
    from sklearn.model_selection import StratifiedKFold

    n_splits = 6
    cv = StratifiedKFold(n_splits=n_splits)
    classifier = svm.SVC(kernel="linear", probability=True, random_state=random_state)

    tprs = []
    aucs = []
    mean_fpr = np.linspace(0, 1, 100)

    fig, ax = plt.subplots(figsize=(6, 6))
    for fold, (train, test) in enumerate(cv.split(X, y)):
        classifier.fit(X[train], y[train])
        viz = RocCurveDisplay.from_estimator(
            classifier,
            X[test],
            y[test],
            name=f"ROC fold {fold}",
            alpha=0.3,
            lw=1,
            ax=ax,
            plot_chance_level=(fold == n_splits - 1),
        )
        interp_tpr = np.interp(mean_fpr, viz.fpr, viz.tpr)
        interp_tpr[0] = 0.0
        tprs.append(interp_tpr)
        aucs.append(viz.roc_auc)

    mean_tpr = np.mean(tprs, axis=0)
    mean_tpr[-1] = 1.0
    mean_auc = auc(mean_fpr, mean_tpr)
    std_auc = np.std(aucs)
    ax.plot(
        mean_fpr,
        mean_tpr,
        color="b",
        label=r"Mean ROC (AUC = %0.2f $\pm$ %0.2f)" % (mean_auc, std_auc),
        lw=2,
        alpha=0.8,
    )

    std_tpr = np.std(tprs, axis=0)
    tprs_upper = np.minimum(mean_tpr + std_tpr, 1)
    tprs_lower = np.maximum(mean_tpr - std_tpr, 0)
    ax.fill_between(
        mean_fpr,
        tprs_lower,
        tprs_upper,
        color="grey",
        alpha=0.2,
        label=r"$\pm$ 1 std. dev.",
    )

    ax.set(
        xlabel="False Positive Rate",
        ylabel="True Positive Rate",
        title=f"Mean ROC curve with variability\n(Positive label '{target_names[1]}')",
    )
    ax.legend(loc="lower right")
    plt.show()


.. image-sg:: /auto_examples/model_selection/images/sphx_glr_plot_roc_crossval_001.png
   :alt: Mean ROC curve with variability (Positive label 'versicolor')
   :srcset: /auto_examples/model_selection/images/sphx_glr_plot_roc_crossval_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.224 seconds)


.. _sphx_glr_download_auto_examples_model_selection_plot_roc_crossval.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/scikit-learn/scikit-learn/main?urlpath=lab/tree/notebooks/auto_examples/model_selection/plot_roc_crossval.ipynb
        :alt: Launch binder
        :width: 150 px

    .. container:: lite-badge

      .. image:: images/jupyterlite_badge_logo.svg
        :target: ../../lite/lab/index.html?path=auto_examples/model_selection/plot_roc_crossval.ipynb
        :alt: Launch JupyterLite
        :width: 150 px

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_roc_crossval.ipynb <plot_roc_crossval.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_roc_crossval.py <plot_roc_crossval.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_roc_crossval.zip <plot_roc_crossval.zip>`


.. include:: plot_roc_crossval.recommendations


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
